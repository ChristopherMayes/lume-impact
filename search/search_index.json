{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LUME-Impact","text":"<p>Tools for using Impact-T and Impact-Z in LUME.</p> <p>Basic usage: <pre><code>from impact import Impact\n\n# Prepare Impact object. This will call I.configure() automatically. \nI = Impact('/path/to/ImpactT.in', verbose=True)\n\n# Change some things\nI.header['Np'] = 10000\nI.header['Nx'] = 32\nI.header['Ny'] = 32\nI.header['Nz'] = 32\n\n# Run\nI.run()\n...\n\n\n# Plot the results\nI.plot()\n</code></pre></p> <p></p> <pre><code># Archive all output\nI.archive('test.h5')\n\n# Plot particle phase space projection\nI.particles['final_particles'].plot('z', 'pz')\n</code></pre> <p></p>"},{"location":"#current-release-info","title":"Current release info","text":"Name Downloads Version Platforms"},{"location":"#installing-lume-impact","title":"Installing lume-impact","text":"<p>Installing <code>lume-impact</code> from the <code>conda-forge</code> channel can be achieved by adding <code>conda-forge</code> to your channels with:</p> <pre><code>conda config --add channels conda-forge\nconda config --set channel_priority strict\n</code></pre> <p>Once the <code>conda-forge</code> channel has been enabled, <code>lume-impact</code> can be installed with:</p> <pre><code>conda install lume-impact\n</code></pre> <p>It is possible to list all of the versions of <code>lume-impact</code> available on your platform with:</p> <pre><code>conda search lume-impact --channel conda-forge\n</code></pre>"},{"location":"#impact-t-executables","title":"Impact-T Executables","text":"<p>Impact-T is available through conda-forge and can be installed via: <pre><code>conda create -n impact\nsource activate impact # or conda activate impact\n# For non-MPI\nconda install -c conda-forge impact-t\n\n# For OpenMPI\nconda install -c conda-forge impact-t=*=mpi_openmpi*\n\n# For MPICH\nconda install -c conda-forge impact-t=*=mpi_mpich*\n</code></pre> After these steps, the IMPACT-T executable <code>ImpactTexe</code> or <code>ImpactTexe-mpi</code>, respectively, will be in your PATH environment variable and is thus ready to use like any regular command-line command.</p> <p>Visit https://github.com/impact-lbl/IMPACT-T for these and further instructions, including those to build from source.</p>"},{"location":"api/impact/","title":"Impact","text":"<p>             Bases: <code>CommandWrapper</code></p> <p>Files will be written into a temporary directory within workdir. If workdir=None, a location will be determined by the system.</p> Source code in <code>impact/impact.py</code> <pre><code>class Impact(CommandWrapper):\n\"\"\"\n\n    Files will be written into a temporary directory within workdir.\n    If workdir=None, a location will be determined by the system.\n\n\n    \"\"\"\n    COMMAND = 'ImpactTexe'\n    COMMAND_MPI = 'ImpactTexe-mpi'\n\n    MPI_RUN = tools.find_mpirun()\n    WORKDIR = tools.find_workdir()    \n\n    # Environmental variables to search for executables\n    command_env='IMPACTT_BIN'\n    command_mpi_env='IMPACTT_MPI_BIN'\n\n    def __init__(self, *args,\n                 group=None,\n                 always_autophase=False,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n        # Save init\n        self.original_input_file = self.input_file\n\n        self.input = {'header':{}, 'lattice':[]}\n        self.output = {}\n        self._units = {}\n        self._units.update(EXTRA_UNITS)\n        self.group = {}\n\n        # MPI\n        self._nnode = 1        \n\n        # Convenience lookup of elements in lattice by name\n        self.ele = {}\n\n        # Autophase settings to be applied.\n        # This will be cleared when actually autophasing\n        self._autophase_settings = {}\n        self.always_autophase = always_autophase\n\n        # Call configure\n        if self.input_file:\n            infile = tools.full_path(self.input_file)\n            assert os.path.exists(infile), f'Impact input file does not exist: {infile}'\n            self.load_input(self.input_file)\n            self.configure()\n\n            # Add groups, if any.\n            if group:\n                for k, v in group.items():\n                    self.add_group(k, **v)\n\n        else:            \n            self.vprint('Using default input: 1 m drift lattice')\n            self.input = deepcopy(DEFAULT_INPUT)\n            self.configure()\n\n\n    def add_ele(self, ele):\n\"\"\"\n        Adds an element to .lattice\n        \"\"\"\n        name = ele['name']\n        assert name not in self.lattice, 'Element already exists'\n        insert_ele_by_s(ele, self.lattice, verbose=self.verbose)\n        # Add to the ele dict\n        self.ele[name] = ele\n\n    def add_group(self, name, **kwargs):\n\"\"\"\n        Add a control group. See control.py\n        \"\"\"\n        assert name not in self.ele\n        if name in self.group:\n            self.vprint(f'Warning: group {name} already exists, overwriting.')\n\n        g = ControlGroup(**kwargs, name=name)\n        g.link(self.ele)\n        self.group[name] = g\n\n        return self.group[name]\n\n    def configure(self):\n        self.configure_impact(workdir=self._workdir)\n\n    def configure_impact(self, input_filepath=None, workdir=None):\n        if input_filepath:\n            self.load_input(input_filepath)\n\n        # Header Bookkeeper\n        self.input['header'] = header_bookkeeper(self.header, verbose=self.verbose)\n\n        if  len(self.input['lattice']) == 0:\n            self.vprint('Warning: lattice is empty. Not configured')\n            self.configured = False\n            return\n\n        # Set ele dict from the lattice\n        self.ele_bookkeeper()\n\n        self.setup_workdir(workdir)\n        self.vprint('Configured to run in:', self.path)\n        self.configured = True\n\n    def input_parser(self, path):\n        return parse_impact_input(path, verbose=self.verbose)\n\n    def load_output(self):\n\"\"\"\n        Loads stats, slice_info, and particles.\n        \"\"\"\n        self.output['stats'], u = load_stats(self.path, species=self.species, types=FORT_STAT_TYPES, verbose=self.verbose)\n        self._units.update(u)\n\n        # This is not always present\n        dipole_stats, u = load_stats(self.path, species=self.species, types=FORT_DIPOLE_STAT_TYPES, verbose=self.verbose)\n        if dipole_stats:\n            self.output['dipole_stats'] = dipole_stats\n            self._units.update(u)\n\n        self.output['slice_info'], u = load_slice_info(self.path, self.verbose)\n        self._units.update(u)\n\n        self.load_particles()\n\n    def load_particles(self):\n        # Standard output\n        self.vprint('Loading particles')\n        self.output['particles'] = load_many_fort(self.path, FORT_PARTICLE_TYPES, verbose=self.verbose)\n\n        # Additional particle files:\n        for e in self.input['lattice']:\n            if e['type'] == 'write_beam':\n                name = e['name']\n                fname = e['filename']\n                full_fname = os.path.join(self.path, fname)\n                if os.path.exists(full_fname):\n                    self.particles[name] = parse_impact_particles(full_fname)\n                    self.vprint(f'Loaded write beam particles {name} {fname}')\n\n        # Convert all to ParticleGroup\n\n        # Interpolate stats to get the time.\n        time_f = interp1d(self.output['stats']['mean_z'], self.output['stats']['t'],\n                                  assume_sorted=True, fill_value='extrapolate')\n\n        for name, pdata in self.particles.items():\n            # Initial particles have special z = beta_ref*c. See: impact_particles_to_particle_data\n            if name == 'initial_particles' and self.header['Flagimg']:\n                cathode_kinetic_energy_ref = self.header['Bkenergy']\n            else:\n                cathode_kinetic_energy_ref = None\n\n            time = time_f(pdata['z'].mean())\n\n            pg_data = impact_particles_to_particle_data(pdata,\n                                                        mc2=self.mc2,\n                                                        species=self.species,\n                                                        time=time,\n                                                        macrocharge=self.macrocharge,\n                                                        cathode_kinetic_energy_ref=cathode_kinetic_energy_ref,\n                                                        verbose=self.verbose)\n            self.particles[name] = ParticleGroup(data = pg_data)\n            self.vprint(f'Converted {name} to ParticleGroup')\n\n    def ele_bookkeeper(self):\n\"\"\"\n        Link .ele = dict to the lattice elements by their 'name' field\n        \"\"\"\n        self.ele = ele_dict_from(self.input['lattice'])\n\n    @property\n    def nnode(self):\n\"\"\"\n        Number of MPI nodes to use\n        \"\"\"\n        return self._nnode\n\n    @nnode.setter\n    def nnode(self, n):\n        self._nnode = n          \n\n    # Convenience routines\n    @property\n    def header(self):\n\"\"\"Convenience pointer to .input['header']\"\"\"\n        return self.input['header']\n    @property\n    def lattice(self):\n\"\"\"Convenience pointer to .input['lattice']\"\"\"\n        return self.input['lattice']\n    @property\n    def particles(self):\n\"\"\"Convenience pointer to .input['lattice']\"\"\"\n        return self.output['particles']\n    @property\n    def fieldmaps(self):\n\"\"\"Convenience pointer to .input['fieldmaps']\"\"\"\n        return self.input['fieldmaps']\n\n    def field(self, z=0, t=0, x=0, y=0, component='Ez'):\n\"\"\"\n        Return the field component at a longitudinal\n        position z at time t.\n\n        Warking: This is based on the parsed fieldmaps,\n        and not calculated directly from Impact. Not all elements/parameters\n        are implemented. Currently x, y must be 0. \n        \"\"\"\n        return lattice_field(self.lattice, x=x, y=y, z=z, t=t, component=component,\n                      fmaps = self.fieldmaps)\n\n    def centroid_field(self, component='Ez'):\n        zlist = self.stat('mean_z')\n        tlist = self.stat('t')\n        return np.array([self.field(z=z, t=t, component=component) for z, t in zip(zlist, tlist)])\n\n    def stat(self, key):\n\"\"\"Array from .output['stats'][key] \"\"\"\n\n        if key in ('Ez', 'Bz'):\n            return self.centroid_field(component=key[0:2])\n\n        return self.output['stats'][key]\n\n    def units(self, key):\n\"\"\"pmd_unit of a given key\"\"\"\n        return self._units[key]\n\n\n    #def field(self, *, x=0, y=0, z=0, t=0):\n\n\n\n\n    #--------------\n    # Run\n    def run(self):\n        if not self.configured:\n            self.vprint('not configured to run')\n            return\n        self.run_impact(verbose=self.verbose, timeout=self.timeout)\n\n    def get_executable(self):\n\"\"\"\n        Gets the full path of the executable from .command, .command_mpi\n        Will search environmental variables:\n                Impact.command_env='IMPACTT_BIN'\n                Impact.command_mpi_env='IMPACTT_MPI_BIN'\n\n        \"\"\"\n        if self.use_mpi:\n            exe = tools.find_executable(exename=self.command_mpi, envname=self.command_mpi_env)\n        else:\n            exe = tools.find_executable(exename=self.command, envname=self.command_env)\n        return exe\n\n    @property\n    def numprocs(self):\n\"\"\"Number of MPI processors = Npcol*Nprow\"\"\"\n        return self.input['header']['Npcol'] * self.input['header']['Nprow']\n\n    @numprocs.setter\n    def numprocs(self, n):\n\"\"\"Sets the number of processors\"\"\"\n        assert n &gt; 0, 'numprocs must be positive'\n        Nz = self.header['Nz']\n        Ny = self.header['Ny']\n        Npcol, Nprow = suggested_processor_domain(Nz, Ny, n)\n\n\n        self.vprint(f'Setting Npcol, Nprow = {Npcol}, {Nprow}')\n        self.header['Nprow'] = Nprow\n        self.header['Npcol'] = Npcol\n\n        if self.use_mpi and n ==1:\n            self.vprint('Disabling MPI')\n            self.use_mpi = False\n\n        if n &gt; 1 and not self.use_mpi:\n            self.vprint('Enabling MPI')\n            self.use_mpi = True\n\n    def get_run_script(self, write_to_path=False, path=None):\n\"\"\"\n        Assembles the run script using self.mpi_run string of the form:\n            'mpirun -n {n} {command_mpi}'\n\n        Optionally writes a file 'run' with this line to path.\n        \"\"\"\n\n        n_procs = self.numprocs\n\n        exe = self.get_executable()\n\n        if self.use_mpi:\n            # mpi_exe could be a complicated string like:\n            # 'srun -N 1 --cpu_bind=cores {n} {command_mpi}'\n            # 'mpirun -n {n} {command_mpi}'\n\n            runscript = self.mpi_run.format(nnode = self.nnode, nproc=n_procs, command_mpi=exe)\n\n        else:\n            if n_procs &gt; 1:\n                raise ValueError('Error: n_procs &gt; 1 but use_mpi = False')\n            runscript = exe\n\n        if write_to_path:\n            if path is None:\n                path = self.path\n            path=os.path.join(path, 'run')\n            with open(path, 'w') as f:\n                f.write(runscript)\n            tools.make_executable(path)\n        return runscript\n\n    def run_impact(self, verbose=False, timeout=None):\n\"\"\"\n        Runs Impact-T\n\n        \"\"\"\n\n        # Clear output\n        self.output = {}\n\n        # Autophase\n        autophase_settings = self.autophase_bookkeeper()        \n        if autophase_settings:\n            self.output['autophase_info'] = autophase_settings\n\n        run_info = self.output['run_info'] = {'error':False}\n\n        # Run script, gets executables\n        runscript = self.get_run_script()\n        run_info['run_script'] = runscript\n\n        t1 = time()\n        run_info['start_time'] = t1\n\n        self.vprint('Running Impact-T in '+self.path)\n        self.vprint(runscript)\n        # Write input\n        self.write_input()\n\n        # Remove previous files\n        for f in fort_files(self.path):\n            os.remove(f)\n\n        try:\n            if timeout:\n                res = tools.execute2(runscript.split(), timeout=timeout, cwd=self.path)\n                log = res['log']\n                self.error = res['error']\n                run_info['error'] = self.error\n                run_info['why_run_error'] = res['why_error']\n\n            else:\n                # Interactive output, for Jupyter\n                log = []\n                counter = 0\n                for path in tools.execute(runscript.split(), cwd=self.path):\n                    # Fancy clearing of old lines\n                    counter +=1\n                    if verbose:\n                        if counter &lt; 15:\n                            print(path, end='')\n                        else:\n                            print('\\r', path.strip()+', elapsed: '+str(time()-t1), end='')\n                    log.append(path)\n                self.vprint('Finished.')\n            self.log = log\n\n            # Load output\n            self.load_output()\n\n        except Exception as ex:\n            self.vprint('Exception in Impact:', ex)\n            run_info['error'] = True\n            run_info['why_run_error'] = str(ex)\n        finally:\n            run_info['run_time'] = time() - t1\n\n        self.finished = True\n\n\n    def write_initial_particles(self, fname=None, update_header=False, path=None):\n        if not fname:\n            if path is None:\n                path = self.path\n            fname = os.path.join(path, 'partcl.data')\n\n        assert self.initial_particles.species == self.species, 'Species mismatch'\n\n        H = self.header\n        # check for cathode start\n        if self.cathode_start:\n            cathode_kinetic_energy_ref = H['Bkenergy']\n            start_str = 'Cathode start'\n\n            if not all(self.initial_particles.z == 0):\n                self.vprint('Some initial particles z !=0, disabling cathode_start')\n                self.cathode_start = False\n                cathode_kinetic_energy_ref = None\n                start_str = 'Normal start'\n        else:\n            cathode_kinetic_energy_ref = None\n            start_str = 'Normal start'\n\n        # Call the openPMD-beamphysics writer routine\n        res = self.initial_particles.write_impact(fname, verbose=self.verbose,\n                                          cathode_kinetic_energy_ref=cathode_kinetic_energy_ref)\n\n        if update_header:\n            for k, v in res.items():\n                if k in H:\n                    H[k] = v\n                    self.vprint(f'{start_str}: Replaced {k} with {v} according to initial particles')\n\n            # These need to be set\n            H['Flagdist'] = 16\n            # Clear out scale factors\n            for k in ['xscale', 'pxscale', 'yscale', 'pyscale', 'zscale', 'pzscale']:\n                if H[k] != 1.0:\n                    H[k] = 1.0\n                    self.vprint(f'Changing particle scale factor {k} to 1.0')\n            # Zero out offsets.\n            for k in ['xmu1(m)', 'xmu2', 'ymu1(m)', 'ymu2', 'zmu1(m)', 'zmu2']:\n                if H[k] != 0:\n                    H[k] = 0\n                    self.vprint(f'Changing particle offset factor {k} to 0')\n\n\n            # Single particle must track with no space charge.\n            if len(self.initial_particles) == 1:\n                self.vprint('Single particle, turning space charge off')\n                self.total_charge = 0\n\n            # This will also set the header.\n            # total_charge = 0 switches off space charge, so don't update.\n            if self.total_charge != 0:\n                charge = self.initial_particles.charge\n                self.vprint(f'Setting total charge to {charge} C')\n                self.total_charge = charge\n\n    def write_input(self, input_filename='ImpactT.in', path=None):\n\"\"\"\n        Write all input.\n\n        If .initial_particles are given,\n        \"\"\"\n\n        if path is None:\n            path = self.path\n\n        assert os.path.exists(path)\n\n        filePath = os.path.join(path, input_filename)\n\n        # Write fieldmaps\n        for name, fieldmap in self.input['fieldmaps'].items():\n            file = os.path.join(path, name)\n            fieldmaps.write_fieldmap(file, fieldmap)\n\n        # Initial particles (ParticleGroup)\n        if self.initial_particles:\n            self.write_initial_particles(update_header=True, path=path)\n\n            # Check consistency\n            if self.header['Flagimg'] ==1 and self.header['Nemission'] &lt; 1 and self.total_charge &gt; 0:\n                raise ValueError(f\"Cathode start with space charge must \"\n                                 f\"set header['Nemission'] &gt; 0. \"\n                                 f\"The current value is {self.header['Nemission']}.\")            \n\n\n        # Symlink\n        elif self.header['Flagdist'] == 16:\n            src = self.input['input_particle_file']\n            dest = os.path.join(path, 'partcl.data')\n\n            # Don't worry about overwriting in temporary directories\n            if self._tempdir and os.path.exists(dest):\n                os.remove(dest)\n\n            if not os.path.exists(dest):\n                writers.write_input_particles_from_file(src, dest, self.header['Np'] )\n            else:\n                self.vprint('partcl.data already exits, will not overwrite.')\n\n        # Write main input file. This should come last.\n        writers.write_impact_input(filePath, self.header, self.lattice)\n\n        # Write run script\n        self.get_run_script(write_to_path=True, path=path)\n\n    @property\n    def stop(self):\n        return get_stop(self.lattice)\n\n    @stop.setter\n    def stop(self, s):\n\"\"\"\n        Sets the stop by inserting a stop element at the end of the lattice.\n\n        Any other stop elements are removed.\n        \"\"\"\n\n        self.input['lattice'], removed_eles = set_stop(self.input['lattice'], s)\n\n        # Bookkeeping\n        if self.ele:\n            for ele in removed_eles:\n                name = ele['name']\n                if name in self.ele:\n                    self.ele.pop(name)\n                    self.vprint(f'Removed element: {name}')\n\n        self.vprint(f'Set stop to s = {s}')\n\n    def archive(self, h5=None):\n\"\"\"\n        Archive all data to an h5 handle or filename.\n\n        If no file is given, a file based on the fingerprint will be created.\n\n        \"\"\"\n        if not h5:\n            h5 = 'impact_'+self.fingerprint()+'.h5'\n\n        if isinstance(h5, str):\n            fname = os.path.expandvars(h5)\n            g = h5py.File(fname, 'w')\n            self.vprint(f'Archiving to file {fname}')\n        else:\n            g = h5\n\n        # Write basic attributes\n        archive.impact_init(g)\n\n        # Initial particles\n        if self.initial_particles:\n            self.initial_particles.write(g, name='initial_particles')\n\n        # All input\n        archive.write_input_h5(g, self.input, name='input')\n\n        # All output\n        archive.write_output_h5(g, self.output, name='output', units=self._units)\n\n        # Control groups\n        if self.group:\n             archive.write_control_groups_h5(g, self.group, name='control_groups')\n\n        return h5\n\n\n    def load_archive(self, h5, configure=True):\n\"\"\"\n        Loads input and output from archived h5 file.\n\n        See: Impact.archive\n        \"\"\"\n        if isinstance(h5, str):\n            fname = os.path.expandvars(h5)\n            g = h5py.File(fname, 'r')\n\n            glist = archive.find_impact_archives(g)\n            n = len(glist)\n            if n == 0:\n                # legacy: try top level\n                message = 'legacy'\n            elif n == 1:\n                gname = glist[0]\n                message = f'group {gname} from'\n                g = g[gname]\n            else:\n                raise ValueError(f'Multiple archives found in file {fname}: {glist}')\n\n            self.vprint(f'Reading {message} archive file {h5}')\n        else:\n            g = h5\n\n        self.input = archive.read_input_h5(g['input'], verbose=self.verbose)\n        self.output, self._units = archive.read_output_h5(g['output'], verbose=self.verbose)\n        self._units.update(EXTRA_UNITS)\n\n        if 'initial_particles' in g:\n            self.initial_particles = ParticleGroup(h5=g['initial_particles'])\n\n        if 'control_groups' in g:\n            self.group = archive.read_control_groups_h5(g['control_groups'], verbose=self.verbose)\n        self.vprint('Loaded from archive. Note: Must reconfigure to run again.')\n        self.configured = False\n\n        if configure:\n            self.configure()\n\n            # Re-link groups\n            # TODO: cleaner logic\n            for _, cg  in self.group.items():\n                cg.link(self.ele)\n\n    @property\n    def cathode_start(self):\n\"\"\"Returns a bool if cathode_start is requested. Can also be set as a bool.\"\"\"\n        return self.header['Flagimg'] == 1\n\n    @cathode_start.setter\n    def cathode_start(self, val):\n        if val:\n            self.header['Flagimg'] = 1\n        else:\n            self.header['Flagimg'] = 0\n\n    @property\n    def total_charge(self):\n\"\"\"Returns the total bunch charge in C. Can be set.\"\"\"\n        return self.header['Bcurr']/self.header['Bfreq']\n\n    @total_charge.setter\n    def total_charge(self, val):\n        self.header['Bcurr'] = val * self.header['Bfreq']\n        # Keep particles up-to-date.\n        if self.initial_particles and val &gt; 0:\n            self.initial_particles.charge = val\n\n    @property\n    def species(self):\n        return identify_species(self.header['Bmass'], self.header['Bcharge'])\n\n    @property\n    def mc2(self):\n        return self.header['Bmass']\n\n    @property\n    def macrocharge(self):\n        H = self.header\n        Np = H['Np']\n        if Np == 0:\n            self.vprint('Error: zero particles. Returning zero macrocharge')\n            return 0\n        else:\n            return H['Bcurr']/H['Bfreq']/Np\n\n\n\n\n    # Phasing\n    #--------\n    def autophase_bookkeeper(self):\n\"\"\"\n        Searches for `'autophase_deg'` attribute in all eles.\n        If one is found, autophase is called. \n\n        If .always_autophase == True, calls autophase is called.\n\n        Returns\n        -------\n        settings: dict\n            Autophase settings found\n        \"\"\"\n        if self._autophase_settings or self.always_autophase:\n            if self.verbose:\n                print('Autophase bookkeeper found settings, applying them')\n\n            # Actual found settings\n            settings = self.autophase(settings=self._autophase_settings)\n\n            # Clear\n            self._autophase_settings = {}\n\n        else:\n            settings = {}\n\n        return settings\n\n\n    def autophase(self,\n                 settings=None,\n                 full_output=False):\n\"\"\"\n        Calculate the relative phases of each rf element\n        by tracking a single particle.\n        This uses a fast method that operates outside of Impact\n\n        Parameters\n        ----------\n        settings: dict, optional=None\n            dict of ele_name:rel_phase_deg \n\n        full_output: bool, optional = False\n            type of output to return (see Returns)   \n\n\n        Returns\n        -------\n        if full_output = True retuns a dict of:\n                ele_name:info_dict\n\n        Otherwise returns a dict of:\n            ele_name:rel_phase_deg \n        which is the same format as settings.\n\n\n        \"\"\"\n\n        if self.initial_particles:\n            t0 = self.initial_particles['mean_t']\n            pz0 = self.initial_particles['mean_pz']\n        else:\n            t0=0\n            pz0=0\n\n        return fast_autophase_impact(self,\n                              settings=settings,\n                              t0=t0,\n                              pz0=pz0,\n                              full_output=full_output,\n                              verbose=self.verbose)\n\n\n\n\n\n    # Tracking\n    #---------\n\n    def track(self, particles, s=None):\n\"\"\"\n        Track a ParticleGroup. An optional stopping s can be given.\n        \"\"\"\n        if not s:\n            s = self.stop\n        return track_to_s(self, particles, s)\n\n    def track1(self,\n                  x0=0,\n                  px0=0,\n                  y0=0,\n                  py0=0,\n                  z0=0,\n                  pz0=1e-15,\n                  t0=0,\n                  s=None, # final s\n                  species=None):\n\"\"\"\n        Tracks a single particle with starting coordinates:\n        x0, y0, z0 in meters\n        px0, py0, pz0 in eV/c\n        t0 in seconds\n\n        to a position 's' in meters\n\n        Used for phasing and scaling elements.\n\n        If successful, returns a ParticleGroup with the final particle.\n\n        Otherwise, returns None\n\n        \"\"\"\n        if not s:\n            s = self.stop\n\n        if not species:\n            species = self.species\n\n        # Change to serial exe just for this\n        n_procs_save = self.numprocs\n        self.numprocs = 1\n        result = track1_to_s(self, s=s, x0=x0, px0=px0, y0=y0, py0=py0, z0=z0, pz0=pz0, t0=t0, species=species)\n        self.numprocs = n_procs_save\n        return result\n\n    def old_plot(self, y='sigma_x', x='mean_z', nice=True, include_layout=True):\n\"\"\"\n        Simple stat plot\n        \"\"\"\n        return plot_stat(self, y=y, x=x, nice=nice)\n\n    def plot(self, y=['sigma_x', 'sigma_y'], x='mean_z', xlim=None, ylim=None, ylim2=None, y2=[],\n            nice=True,\n            include_layout=True,\n            include_labels=False,\n            include_markers=True,\n            include_particles=True,\n            include_field=True,\n            field_t=None,\n            include_legend=True,\n            return_figure=False,\n            tex=True,\n             **kwargs):\n\"\"\"\n\n\n        \"\"\"\n\n\n        # Just plot fieldmaps if there are no stats\n        if 'stats' not in self.output:\n            return plot_layout(self, xlim=xlim,\n                               include_markers=include_markers,\n                               include_labels=include_labels,\n                               include_field=include_field,\n                               field_t=field_t,      \n                               return_figure=return_figure,\n                               **kwargs)\n\n\n        return plot_stats_with_layout(self, ykeys=y, ykeys2=y2,\n                           xkey=x, xlim=xlim, ylim=ylim, ylim2=ylim2,\n                           nice=nice,\n                           tex=tex,\n                           include_layout=include_layout,\n                           include_labels=include_labels,\n                           include_field=include_field,\n                           field_t=field_t,                                      \n                           include_markers=include_markers,\n                           include_particles=include_particles,\n                           include_legend=include_legend,\n                           return_figure=return_figure,\n                           **kwargs)\n\n\n    def print_lattice(self):\n\"\"\"\n        Pretty printing of the lattice\n        \"\"\"\n        for ele in self.input['lattice']:\n            line = ele_str(ele)\n            print(line)\n\n    def vprint(self, *args):\n\"\"\"verbose print\"\"\"\n        if self.verbose:\n            print(*args)\n\n    def reset(self):\n        if self.use_temp_dir:\n            self.path = None\n            self.configured = False\n\n\n\n    @classmethod\n    @functools.wraps(impact_from_tao) \n    def from_tao(cls, tao, fieldmap_style='fourier'):\n        return impact_from_tao(tao, fieldmap_style=fieldmap_style)\n\n\n    def __getitem__(self, key):\n\"\"\"\n        Convenience syntax to get a header or element attribute.\n\n        Special syntax:\n\n        end_X\n            will return the final item in a stat array X\n            Example:\n            'end_norm_emit_x'\n\n        particles:X\n            will return a ParticleGroup named X\n            Example:\n                'particles:initial_particles'\n                returns the readback of initial particles.\n        particles:X:Y\n            ParticleGroup named X's property Y\n            Example:\n                'particles:final_particles:sigma_x'\n\n\n        See: __setitem__\n        \"\"\"\n\n        # Object attributes\n        if hasattr(self, key):\n            return getattr(self, key)\n\n        # Send back ele or group object.\n        # Do not add these to __setitem__. The user shouldn't be allowed to change them as a whole,\n        #   because it will break all the links.\n        if key in self.group:\n            return self.group[key]\n        if key in self.ele:\n            return self.ele[key]\n\n        if key.startswith('end_'):\n            key2 = key[len('end_'):]\n            assert key2 in self.output['stats'], f'{key} does not have valid output stat: {key2}'\n            return self.output['stats'][key2][-1]\n\n        if key.startswith('particles:'):\n            key2 = key[len('particles:'):]\n            x = key2.split(':')\n            if len(x) == 1:\n                return self.particles[x[0]]\n            else:\n                return self.particles[x[0]][x[1]]\n\n        # key isn't an ele or group, should have property s\n\n        x = key.split(':')\n        assert len(x) == 2, f'{x} was not found in group or ele dict, so should have : '\n        name, attrib = x[0], x[1]\n\n        if name == 'header':\n            return self.header[attrib]\n        elif name in self.ele:\n            return self.ele[name][attrib]\n        elif name in self.group:\n            return self.group[name][attrib]\n\n\n\n    def __setitem__(self, key, item):\n\"\"\"\n        Convenience syntax to set a header or element attribute.\n        attribute_string should be 'header:key' or 'ele_name:key'\n\n        Examples of attribute_string: 'header:Np', 'SOL1:solenoid_field_scale'\n\n        Settable attributes can also be given:\n\n        ['stop'] = 1.2345 will set Impact.stop = 1.2345\n\n        \"\"\"\n\n        # Set attributes\n        if hasattr(self, key):\n            setattr(self, key, item)\n            return\n\n        # Must be header:key or elename:attrib\n        name, attrib = key.split(':')\n        # Try header or lattice\n        if name == 'header':\n            self.header[attrib] = item\n        elif attrib == 'autophase_deg':\n            self._autophase_settings[name] = item\n        elif name in self.ele:\n            self.ele[name][attrib] = item\n        elif name in self.group:\n            self.group[name][attrib]  = item\n        else:\n            raise ValueError(f'{name} does not exist in eles or groups of the Impact object.')\n\n    def __str__(self):\n        path = self.path\n        s = header_str(self.header)\n        if self.finished:\n            s += 'Impact-T finished in '+path\n        elif self.configured:\n            s += 'Impact-T configured in '+path\n        else:\n            s += 'Impact-T not configured.'\n        return s\n\n    def __repr__(self):\n\"\"\"\n        Simple repr showing the number of particles and the stop z.\n        \"\"\"\n        memloc = hex(id(self))\n        np = self.header['Np']\n        z = self.stop\n        return f'&lt;Impact with {np} particles, stopping at {z} m, at {memloc}&gt;'\n</code></pre>"},{"location":"api/impact/#impact.Impact.cathode_start","title":"<code>cathode_start</code>  <code>property</code> <code>writable</code>","text":"<p>Returns a bool if cathode_start is requested. Can also be set as a bool.</p>"},{"location":"api/impact/#impact.Impact.fieldmaps","title":"<code>fieldmaps</code>  <code>property</code>","text":"<p>Convenience pointer to .input['fieldmaps']</p>"},{"location":"api/impact/#impact.Impact.header","title":"<code>header</code>  <code>property</code>","text":"<p>Convenience pointer to .input['header']</p>"},{"location":"api/impact/#impact.Impact.lattice","title":"<code>lattice</code>  <code>property</code>","text":"<p>Convenience pointer to .input['lattice']</p>"},{"location":"api/impact/#impact.Impact.nnode","title":"<code>nnode</code>  <code>property</code> <code>writable</code>","text":"<p>Number of MPI nodes to use</p>"},{"location":"api/impact/#impact.Impact.numprocs","title":"<code>numprocs</code>  <code>property</code> <code>writable</code>","text":"<p>Number of MPI processors = Npcol*Nprow</p>"},{"location":"api/impact/#impact.Impact.particles","title":"<code>particles</code>  <code>property</code>","text":"<p>Convenience pointer to .input['lattice']</p>"},{"location":"api/impact/#impact.Impact.total_charge","title":"<code>total_charge</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the total bunch charge in C. Can be set.</p>"},{"location":"api/impact/#impact.Impact.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Convenience syntax to get a header or element attribute.</p> <p>Special syntax:</p> <p>end_X     will return the final item in a stat array X     Example:     'end_norm_emit_x'</p> <p>particles:X     will return a ParticleGroup named X     Example:         'particles:initial_particles'         returns the readback of initial particles. particles:X:Y     ParticleGroup named X's property Y     Example:         'particles:final_particles:sigma_x'</p> <p>See: setitem</p> Source code in <code>impact/impact.py</code> <pre><code>def __getitem__(self, key):\n\"\"\"\n    Convenience syntax to get a header or element attribute.\n\n    Special syntax:\n\n    end_X\n        will return the final item in a stat array X\n        Example:\n        'end_norm_emit_x'\n\n    particles:X\n        will return a ParticleGroup named X\n        Example:\n            'particles:initial_particles'\n            returns the readback of initial particles.\n    particles:X:Y\n        ParticleGroup named X's property Y\n        Example:\n            'particles:final_particles:sigma_x'\n\n\n    See: __setitem__\n    \"\"\"\n\n    # Object attributes\n    if hasattr(self, key):\n        return getattr(self, key)\n\n    # Send back ele or group object.\n    # Do not add these to __setitem__. The user shouldn't be allowed to change them as a whole,\n    #   because it will break all the links.\n    if key in self.group:\n        return self.group[key]\n    if key in self.ele:\n        return self.ele[key]\n\n    if key.startswith('end_'):\n        key2 = key[len('end_'):]\n        assert key2 in self.output['stats'], f'{key} does not have valid output stat: {key2}'\n        return self.output['stats'][key2][-1]\n\n    if key.startswith('particles:'):\n        key2 = key[len('particles:'):]\n        x = key2.split(':')\n        if len(x) == 1:\n            return self.particles[x[0]]\n        else:\n            return self.particles[x[0]][x[1]]\n\n    # key isn't an ele or group, should have property s\n\n    x = key.split(':')\n    assert len(x) == 2, f'{x} was not found in group or ele dict, so should have : '\n    name, attrib = x[0], x[1]\n\n    if name == 'header':\n        return self.header[attrib]\n    elif name in self.ele:\n        return self.ele[name][attrib]\n    elif name in self.group:\n        return self.group[name][attrib]\n</code></pre>"},{"location":"api/impact/#impact.Impact.__repr__","title":"<code>__repr__()</code>","text":"<p>Simple repr showing the number of particles and the stop z.</p> Source code in <code>impact/impact.py</code> <pre><code>def __repr__(self):\n\"\"\"\n    Simple repr showing the number of particles and the stop z.\n    \"\"\"\n    memloc = hex(id(self))\n    np = self.header['Np']\n    z = self.stop\n    return f'&lt;Impact with {np} particles, stopping at {z} m, at {memloc}&gt;'\n</code></pre>"},{"location":"api/impact/#impact.Impact.__setitem__","title":"<code>__setitem__(key, item)</code>","text":"<p>Convenience syntax to set a header or element attribute. attribute_string should be 'header:key' or 'ele_name:key'</p> <p>Examples of attribute_string: 'header:Np', 'SOL1:solenoid_field_scale'</p> <p>Settable attributes can also be given:</p> <p>['stop'] = 1.2345 will set Impact.stop = 1.2345</p> Source code in <code>impact/impact.py</code> <pre><code>def __setitem__(self, key, item):\n\"\"\"\n    Convenience syntax to set a header or element attribute.\n    attribute_string should be 'header:key' or 'ele_name:key'\n\n    Examples of attribute_string: 'header:Np', 'SOL1:solenoid_field_scale'\n\n    Settable attributes can also be given:\n\n    ['stop'] = 1.2345 will set Impact.stop = 1.2345\n\n    \"\"\"\n\n    # Set attributes\n    if hasattr(self, key):\n        setattr(self, key, item)\n        return\n\n    # Must be header:key or elename:attrib\n    name, attrib = key.split(':')\n    # Try header or lattice\n    if name == 'header':\n        self.header[attrib] = item\n    elif attrib == 'autophase_deg':\n        self._autophase_settings[name] = item\n    elif name in self.ele:\n        self.ele[name][attrib] = item\n    elif name in self.group:\n        self.group[name][attrib]  = item\n    else:\n        raise ValueError(f'{name} does not exist in eles or groups of the Impact object.')\n</code></pre>"},{"location":"api/impact/#impact.Impact.add_ele","title":"<code>add_ele(ele)</code>","text":"<p>Adds an element to .lattice</p> Source code in <code>impact/impact.py</code> <pre><code>def add_ele(self, ele):\n\"\"\"\n    Adds an element to .lattice\n    \"\"\"\n    name = ele['name']\n    assert name not in self.lattice, 'Element already exists'\n    insert_ele_by_s(ele, self.lattice, verbose=self.verbose)\n    # Add to the ele dict\n    self.ele[name] = ele\n</code></pre>"},{"location":"api/impact/#impact.Impact.add_group","title":"<code>add_group(name, **kwargs)</code>","text":"<p>Add a control group. See control.py</p> Source code in <code>impact/impact.py</code> <pre><code>def add_group(self, name, **kwargs):\n\"\"\"\n    Add a control group. See control.py\n    \"\"\"\n    assert name not in self.ele\n    if name in self.group:\n        self.vprint(f'Warning: group {name} already exists, overwriting.')\n\n    g = ControlGroup(**kwargs, name=name)\n    g.link(self.ele)\n    self.group[name] = g\n\n    return self.group[name]\n</code></pre>"},{"location":"api/impact/#impact.Impact.archive","title":"<code>archive(h5=None)</code>","text":"<p>Archive all data to an h5 handle or filename.</p> <p>If no file is given, a file based on the fingerprint will be created.</p> Source code in <code>impact/impact.py</code> <pre><code>def archive(self, h5=None):\n\"\"\"\n    Archive all data to an h5 handle or filename.\n\n    If no file is given, a file based on the fingerprint will be created.\n\n    \"\"\"\n    if not h5:\n        h5 = 'impact_'+self.fingerprint()+'.h5'\n\n    if isinstance(h5, str):\n        fname = os.path.expandvars(h5)\n        g = h5py.File(fname, 'w')\n        self.vprint(f'Archiving to file {fname}')\n    else:\n        g = h5\n\n    # Write basic attributes\n    archive.impact_init(g)\n\n    # Initial particles\n    if self.initial_particles:\n        self.initial_particles.write(g, name='initial_particles')\n\n    # All input\n    archive.write_input_h5(g, self.input, name='input')\n\n    # All output\n    archive.write_output_h5(g, self.output, name='output', units=self._units)\n\n    # Control groups\n    if self.group:\n         archive.write_control_groups_h5(g, self.group, name='control_groups')\n\n    return h5\n</code></pre>"},{"location":"api/impact/#impact.Impact.autophase","title":"<code>autophase(settings=None, full_output=False)</code>","text":"<p>Calculate the relative phases of each rf element by tracking a single particle. This uses a fast method that operates outside of Impact</p>"},{"location":"api/impact/#impact.Impact.autophase--parameters","title":"Parameters","text":"<p>settings: dict, optional=None     dict of ele_name:rel_phase_deg </p> bool, optional = False <p>type of output to return (see Returns)   </p>"},{"location":"api/impact/#impact.Impact.autophase--returns","title":"Returns","text":"<p>if full_output = True retuns a dict of:         ele_name:info_dict</p> Otherwise returns a dict of <p>ele_name:rel_phase_deg </p> <p>which is the same format as settings.</p> Source code in <code>impact/impact.py</code> <pre><code>def autophase(self,\n             settings=None,\n             full_output=False):\n\"\"\"\n    Calculate the relative phases of each rf element\n    by tracking a single particle.\n    This uses a fast method that operates outside of Impact\n\n    Parameters\n    ----------\n    settings: dict, optional=None\n        dict of ele_name:rel_phase_deg \n\n    full_output: bool, optional = False\n        type of output to return (see Returns)   \n\n\n    Returns\n    -------\n    if full_output = True retuns a dict of:\n            ele_name:info_dict\n\n    Otherwise returns a dict of:\n        ele_name:rel_phase_deg \n    which is the same format as settings.\n\n\n    \"\"\"\n\n    if self.initial_particles:\n        t0 = self.initial_particles['mean_t']\n        pz0 = self.initial_particles['mean_pz']\n    else:\n        t0=0\n        pz0=0\n\n    return fast_autophase_impact(self,\n                          settings=settings,\n                          t0=t0,\n                          pz0=pz0,\n                          full_output=full_output,\n                          verbose=self.verbose)\n</code></pre>"},{"location":"api/impact/#impact.Impact.autophase_bookkeeper","title":"<code>autophase_bookkeeper()</code>","text":"<p>Searches for <code>'autophase_deg'</code> attribute in all eles. If one is found, autophase is called. </p> <p>If .always_autophase == True, calls autophase is called.</p>"},{"location":"api/impact/#impact.Impact.autophase_bookkeeper--returns","title":"Returns","text":"<p>settings: dict     Autophase settings found</p> Source code in <code>impact/impact.py</code> <pre><code>def autophase_bookkeeper(self):\n\"\"\"\n    Searches for `'autophase_deg'` attribute in all eles.\n    If one is found, autophase is called. \n\n    If .always_autophase == True, calls autophase is called.\n\n    Returns\n    -------\n    settings: dict\n        Autophase settings found\n    \"\"\"\n    if self._autophase_settings or self.always_autophase:\n        if self.verbose:\n            print('Autophase bookkeeper found settings, applying them')\n\n        # Actual found settings\n        settings = self.autophase(settings=self._autophase_settings)\n\n        # Clear\n        self._autophase_settings = {}\n\n    else:\n        settings = {}\n\n    return settings\n</code></pre>"},{"location":"api/impact/#impact.Impact.ele_bookkeeper","title":"<code>ele_bookkeeper()</code>","text":"<p>Link .ele = dict to the lattice elements by their 'name' field</p> Source code in <code>impact/impact.py</code> <pre><code>def ele_bookkeeper(self):\n\"\"\"\n    Link .ele = dict to the lattice elements by their 'name' field\n    \"\"\"\n    self.ele = ele_dict_from(self.input['lattice'])\n</code></pre>"},{"location":"api/impact/#impact.Impact.field","title":"<code>field(z=0, t=0, x=0, y=0, component='Ez')</code>","text":"<p>Return the field component at a longitudinal position z at time t.</p> <p>Warking: This is based on the parsed fieldmaps, and not calculated directly from Impact. Not all elements/parameters are implemented. Currently x, y must be 0.</p> Source code in <code>impact/impact.py</code> <pre><code>def field(self, z=0, t=0, x=0, y=0, component='Ez'):\n\"\"\"\n    Return the field component at a longitudinal\n    position z at time t.\n\n    Warking: This is based on the parsed fieldmaps,\n    and not calculated directly from Impact. Not all elements/parameters\n    are implemented. Currently x, y must be 0. \n    \"\"\"\n    return lattice_field(self.lattice, x=x, y=y, z=z, t=t, component=component,\n                  fmaps = self.fieldmaps)\n</code></pre>"},{"location":"api/impact/#impact.Impact.get_executable","title":"<code>get_executable()</code>","text":"<p>Gets the full path of the executable from .command, .command_mpi Will search environmental variables:         Impact.command_env='IMPACTT_BIN'         Impact.command_mpi_env='IMPACTT_MPI_BIN'</p> Source code in <code>impact/impact.py</code> <pre><code>def get_executable(self):\n\"\"\"\n    Gets the full path of the executable from .command, .command_mpi\n    Will search environmental variables:\n            Impact.command_env='IMPACTT_BIN'\n            Impact.command_mpi_env='IMPACTT_MPI_BIN'\n\n    \"\"\"\n    if self.use_mpi:\n        exe = tools.find_executable(exename=self.command_mpi, envname=self.command_mpi_env)\n    else:\n        exe = tools.find_executable(exename=self.command, envname=self.command_env)\n    return exe\n</code></pre>"},{"location":"api/impact/#impact.Impact.get_run_script","title":"<code>get_run_script(write_to_path=False, path=None)</code>","text":"<p>Assembles the run script using self.mpi_run string of the form:     'mpirun -n {n} {command_mpi}'</p> <p>Optionally writes a file 'run' with this line to path.</p> Source code in <code>impact/impact.py</code> <pre><code>def get_run_script(self, write_to_path=False, path=None):\n\"\"\"\n    Assembles the run script using self.mpi_run string of the form:\n        'mpirun -n {n} {command_mpi}'\n\n    Optionally writes a file 'run' with this line to path.\n    \"\"\"\n\n    n_procs = self.numprocs\n\n    exe = self.get_executable()\n\n    if self.use_mpi:\n        # mpi_exe could be a complicated string like:\n        # 'srun -N 1 --cpu_bind=cores {n} {command_mpi}'\n        # 'mpirun -n {n} {command_mpi}'\n\n        runscript = self.mpi_run.format(nnode = self.nnode, nproc=n_procs, command_mpi=exe)\n\n    else:\n        if n_procs &gt; 1:\n            raise ValueError('Error: n_procs &gt; 1 but use_mpi = False')\n        runscript = exe\n\n    if write_to_path:\n        if path is None:\n            path = self.path\n        path=os.path.join(path, 'run')\n        with open(path, 'w') as f:\n            f.write(runscript)\n        tools.make_executable(path)\n    return runscript\n</code></pre>"},{"location":"api/impact/#impact.Impact.load_archive","title":"<code>load_archive(h5, configure=True)</code>","text":"<p>Loads input and output from archived h5 file.</p> <p>See: Impact.archive</p> Source code in <code>impact/impact.py</code> <pre><code>def load_archive(self, h5, configure=True):\n\"\"\"\n    Loads input and output from archived h5 file.\n\n    See: Impact.archive\n    \"\"\"\n    if isinstance(h5, str):\n        fname = os.path.expandvars(h5)\n        g = h5py.File(fname, 'r')\n\n        glist = archive.find_impact_archives(g)\n        n = len(glist)\n        if n == 0:\n            # legacy: try top level\n            message = 'legacy'\n        elif n == 1:\n            gname = glist[0]\n            message = f'group {gname} from'\n            g = g[gname]\n        else:\n            raise ValueError(f'Multiple archives found in file {fname}: {glist}')\n\n        self.vprint(f'Reading {message} archive file {h5}')\n    else:\n        g = h5\n\n    self.input = archive.read_input_h5(g['input'], verbose=self.verbose)\n    self.output, self._units = archive.read_output_h5(g['output'], verbose=self.verbose)\n    self._units.update(EXTRA_UNITS)\n\n    if 'initial_particles' in g:\n        self.initial_particles = ParticleGroup(h5=g['initial_particles'])\n\n    if 'control_groups' in g:\n        self.group = archive.read_control_groups_h5(g['control_groups'], verbose=self.verbose)\n    self.vprint('Loaded from archive. Note: Must reconfigure to run again.')\n    self.configured = False\n\n    if configure:\n        self.configure()\n\n        # Re-link groups\n        # TODO: cleaner logic\n        for _, cg  in self.group.items():\n            cg.link(self.ele)\n</code></pre>"},{"location":"api/impact/#impact.Impact.load_output","title":"<code>load_output()</code>","text":"<p>Loads stats, slice_info, and particles.</p> Source code in <code>impact/impact.py</code> <pre><code>def load_output(self):\n\"\"\"\n    Loads stats, slice_info, and particles.\n    \"\"\"\n    self.output['stats'], u = load_stats(self.path, species=self.species, types=FORT_STAT_TYPES, verbose=self.verbose)\n    self._units.update(u)\n\n    # This is not always present\n    dipole_stats, u = load_stats(self.path, species=self.species, types=FORT_DIPOLE_STAT_TYPES, verbose=self.verbose)\n    if dipole_stats:\n        self.output['dipole_stats'] = dipole_stats\n        self._units.update(u)\n\n    self.output['slice_info'], u = load_slice_info(self.path, self.verbose)\n    self._units.update(u)\n\n    self.load_particles()\n</code></pre>"},{"location":"api/impact/#impact.Impact.old_plot","title":"<code>old_plot(y='sigma_x', x='mean_z', nice=True, include_layout=True)</code>","text":"<p>Simple stat plot</p> Source code in <code>impact/impact.py</code> <pre><code>def old_plot(self, y='sigma_x', x='mean_z', nice=True, include_layout=True):\n\"\"\"\n    Simple stat plot\n    \"\"\"\n    return plot_stat(self, y=y, x=x, nice=nice)\n</code></pre>"},{"location":"api/impact/#impact.Impact.print_lattice","title":"<code>print_lattice()</code>","text":"<p>Pretty printing of the lattice</p> Source code in <code>impact/impact.py</code> <pre><code>def print_lattice(self):\n\"\"\"\n    Pretty printing of the lattice\n    \"\"\"\n    for ele in self.input['lattice']:\n        line = ele_str(ele)\n        print(line)\n</code></pre>"},{"location":"api/impact/#impact.Impact.run_impact","title":"<code>run_impact(verbose=False, timeout=None)</code>","text":"<p>Runs Impact-T</p> Source code in <code>impact/impact.py</code> <pre><code>def run_impact(self, verbose=False, timeout=None):\n\"\"\"\n    Runs Impact-T\n\n    \"\"\"\n\n    # Clear output\n    self.output = {}\n\n    # Autophase\n    autophase_settings = self.autophase_bookkeeper()        \n    if autophase_settings:\n        self.output['autophase_info'] = autophase_settings\n\n    run_info = self.output['run_info'] = {'error':False}\n\n    # Run script, gets executables\n    runscript = self.get_run_script()\n    run_info['run_script'] = runscript\n\n    t1 = time()\n    run_info['start_time'] = t1\n\n    self.vprint('Running Impact-T in '+self.path)\n    self.vprint(runscript)\n    # Write input\n    self.write_input()\n\n    # Remove previous files\n    for f in fort_files(self.path):\n        os.remove(f)\n\n    try:\n        if timeout:\n            res = tools.execute2(runscript.split(), timeout=timeout, cwd=self.path)\n            log = res['log']\n            self.error = res['error']\n            run_info['error'] = self.error\n            run_info['why_run_error'] = res['why_error']\n\n        else:\n            # Interactive output, for Jupyter\n            log = []\n            counter = 0\n            for path in tools.execute(runscript.split(), cwd=self.path):\n                # Fancy clearing of old lines\n                counter +=1\n                if verbose:\n                    if counter &lt; 15:\n                        print(path, end='')\n                    else:\n                        print('\\r', path.strip()+', elapsed: '+str(time()-t1), end='')\n                log.append(path)\n            self.vprint('Finished.')\n        self.log = log\n\n        # Load output\n        self.load_output()\n\n    except Exception as ex:\n        self.vprint('Exception in Impact:', ex)\n        run_info['error'] = True\n        run_info['why_run_error'] = str(ex)\n    finally:\n        run_info['run_time'] = time() - t1\n\n    self.finished = True\n</code></pre>"},{"location":"api/impact/#impact.Impact.stat","title":"<code>stat(key)</code>","text":"<p>Array from .output'stats'</p> Source code in <code>impact/impact.py</code> <pre><code>def stat(self, key):\n\"\"\"Array from .output['stats'][key] \"\"\"\n\n    if key in ('Ez', 'Bz'):\n        return self.centroid_field(component=key[0:2])\n\n    return self.output['stats'][key]\n</code></pre>"},{"location":"api/impact/#impact.Impact.track","title":"<code>track(particles, s=None)</code>","text":"<p>Track a ParticleGroup. An optional stopping s can be given.</p> Source code in <code>impact/impact.py</code> <pre><code>def track(self, particles, s=None):\n\"\"\"\n    Track a ParticleGroup. An optional stopping s can be given.\n    \"\"\"\n    if not s:\n        s = self.stop\n    return track_to_s(self, particles, s)\n</code></pre>"},{"location":"api/impact/#impact.Impact.track1","title":"<code>track1(x0=0, px0=0, y0=0, py0=0, z0=0, pz0=1e-15, t0=0, s=None, species=None)</code>","text":"<p>Tracks a single particle with starting coordinates: x0, y0, z0 in meters px0, py0, pz0 in eV/c t0 in seconds</p> <p>to a position 's' in meters</p> <p>Used for phasing and scaling elements.</p> <p>If successful, returns a ParticleGroup with the final particle.</p> <p>Otherwise, returns None</p> Source code in <code>impact/impact.py</code> <pre><code>def track1(self,\n              x0=0,\n              px0=0,\n              y0=0,\n              py0=0,\n              z0=0,\n              pz0=1e-15,\n              t0=0,\n              s=None, # final s\n              species=None):\n\"\"\"\n    Tracks a single particle with starting coordinates:\n    x0, y0, z0 in meters\n    px0, py0, pz0 in eV/c\n    t0 in seconds\n\n    to a position 's' in meters\n\n    Used for phasing and scaling elements.\n\n    If successful, returns a ParticleGroup with the final particle.\n\n    Otherwise, returns None\n\n    \"\"\"\n    if not s:\n        s = self.stop\n\n    if not species:\n        species = self.species\n\n    # Change to serial exe just for this\n    n_procs_save = self.numprocs\n    self.numprocs = 1\n    result = track1_to_s(self, s=s, x0=x0, px0=px0, y0=y0, py0=py0, z0=z0, pz0=pz0, t0=t0, species=species)\n    self.numprocs = n_procs_save\n    return result\n</code></pre>"},{"location":"api/impact/#impact.Impact.units","title":"<code>units(key)</code>","text":"<p>pmd_unit of a given key</p> Source code in <code>impact/impact.py</code> <pre><code>def units(self, key):\n\"\"\"pmd_unit of a given key\"\"\"\n    return self._units[key]\n</code></pre>"},{"location":"api/impact/#impact.Impact.vprint","title":"<code>vprint(*args)</code>","text":"<p>verbose print</p> Source code in <code>impact/impact.py</code> <pre><code>def vprint(self, *args):\n\"\"\"verbose print\"\"\"\n    if self.verbose:\n        print(*args)\n</code></pre>"},{"location":"api/impact/#impact.Impact.write_input","title":"<code>write_input(input_filename='ImpactT.in', path=None)</code>","text":"<p>Write all input.</p> <p>If .initial_particles are given,</p> Source code in <code>impact/impact.py</code> <pre><code>def write_input(self, input_filename='ImpactT.in', path=None):\n\"\"\"\n    Write all input.\n\n    If .initial_particles are given,\n    \"\"\"\n\n    if path is None:\n        path = self.path\n\n    assert os.path.exists(path)\n\n    filePath = os.path.join(path, input_filename)\n\n    # Write fieldmaps\n    for name, fieldmap in self.input['fieldmaps'].items():\n        file = os.path.join(path, name)\n        fieldmaps.write_fieldmap(file, fieldmap)\n\n    # Initial particles (ParticleGroup)\n    if self.initial_particles:\n        self.write_initial_particles(update_header=True, path=path)\n\n        # Check consistency\n        if self.header['Flagimg'] ==1 and self.header['Nemission'] &lt; 1 and self.total_charge &gt; 0:\n            raise ValueError(f\"Cathode start with space charge must \"\n                             f\"set header['Nemission'] &gt; 0. \"\n                             f\"The current value is {self.header['Nemission']}.\")            \n\n\n    # Symlink\n    elif self.header['Flagdist'] == 16:\n        src = self.input['input_particle_file']\n        dest = os.path.join(path, 'partcl.data')\n\n        # Don't worry about overwriting in temporary directories\n        if self._tempdir and os.path.exists(dest):\n            os.remove(dest)\n\n        if not os.path.exists(dest):\n            writers.write_input_particles_from_file(src, dest, self.header['Np'] )\n        else:\n            self.vprint('partcl.data already exits, will not overwrite.')\n\n    # Write main input file. This should come last.\n    writers.write_impact_input(filePath, self.header, self.lattice)\n\n    # Write run script\n    self.get_run_script(write_to_path=True, path=path)\n</code></pre>"},{"location":"examples/autophase_example/","title":"Autophase and Autophase and Scale examples","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre># Nicer plotting\nimport matplotlib.pyplot as plt\nimport matplotlib\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nmatplotlib.rcParams['figure.figsize'] = (8,4)\n</pre> # Nicer plotting import matplotlib.pyplot as plt import matplotlib %matplotlib inline %config InlineBackend.figure_format = 'retina' matplotlib.rcParams['figure.figsize'] = (8,4) In\u00a0[3]: Copied! <pre>from impact import Impact\n\nimport numpy as np\nimport os\n</pre> from impact import Impact  import numpy as np import os <p>Make Impact object from the LCLS injector model:</p> In\u00a0[4]: Copied! <pre>ifile ='templates/lcls_injector/ImpactT.in'\n</pre> ifile ='templates/lcls_injector/ImpactT.in' In\u00a0[5]: Copied! <pre>I = Impact(ifile, verbose=True)\nI.numprocs=1\n</pre> I = Impact(ifile, verbose=True) I.numprocs=1 <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpw98umxhj\nSetting Npcol, Nprow = 1, 1\n</pre> In\u00a0[6]: Copied! <pre>from impact.autophase import autophase_and_scale\n\nfrom pmd_beamphysics import single_particle\n\nP0 = single_particle(pz=1e-15, z=1e-15)\n</pre> from impact.autophase import autophase_and_scale  from pmd_beamphysics import single_particle  P0 = single_particle(pz=1e-15, z=1e-15) In\u00a0[7]: Copied! <pre>autophase_and_scale(I, phase_ele_name='GUN', target=6e6, scale_range=(10e6, 100e6), initial_particles=P0, verbose=True)\n</pre> autophase_and_scale(I, phase_ele_name='GUN', target=6e6, scale_range=(10e6, 100e6), initial_particles=P0, verbose=True) <pre>Copied initial Impact object. \nPhasing GUN by changing theta0_deg\nScaling GUN by changing rf_field_scale\nBounds: 0.0, 0.15 m\nDisabling SOL1\nDisabling L0A_entrance\nDisabling L0A_body_1\nDisabling L0A_body_2\nDisabling L0A_exit\nDisabling L0B_entrance\nDisabling L0B_body_1\nDisabling L0B_body_2\nDisabling L0B_exit\nDefault brent2 algorithm\nPhase: 180, Scale: 10000000.0, 0.0 M\nPhase: 180, Scale: 10000000.0, 0.0 M\nPhase: 42.49224000000004, Scale: 10000000.0, 0.0 M\nPhase: 180, Scale: 10000000.0, 0.0 M\nPhase: 42.49223094384001, Scale: 10000000.0, 0.0 M\nPhase: 179.9999944029853, Scale: 10000000.0, 0.0 M\nPhase: 264.9844674846946, Scale: 10000000.0, 0.0 M\nPhase: 317.5077613212758, Scale: 10000000.0, 0.8975762459271919 MeV\nPhase: 349.96894270427333, Scale: 10000000.0, 0.0 M\nPhase: 307.4767050944839, Scale: 10000000.0, 1.0654416534635467 MeV\nPhase: 291.24611506362317, Scale: 10000000.0, 1.2336242492241303 MeV\nPhase: 278.00986809194796, Scale: 10000000.0, 1.296396252563295 MeV\nPhase: 272.194419504708, Scale: 10000000.0, 1.3058715711404754 MeV\nPhase: 270.11649510286486, Scale: 10000000.0, 1.3066460330097611 MeV\nPhase: 269.48637860775204, Scale: 10000000.0, 0.0 M\nPhase: 270.7466115979777, Scale: 10000000.0, 1.3065579605296482 MeV\nStep 1 phasing found: 270.11649510286486\nPhase: 270.11649510286486, Scale: 10000000.0, 1.3066460330097611 MeV\nPhase: 270.11649510286486, Scale: 100000000.0, 10.753504425396654 MeV\nPhase: 270.11649510286486, Scale: 54713473.991473176, 6.478874005337477 MeV\nPhase: 270.11649510286486, Scale: 50573648.65944831, 6.066700071163108 MeV\nPhase: 270.11649510286486, Scale: 49913108.51397763, 6.000425730820272 MeV\nPhase: 270.11649510286486, Scale: 49888151.95972064, 5.997918848517763 MeV\nStep 2  scale found: 49913108.51397763\nPhase: 269.11649510286486, Scale: 49913108.51397763, 0.0 M\nPhase: 271.11649510286486, Scale: 49913108.51397763, 6.00141593383749 MeV\nPhase: 274.35256310286485, Scale: 49913108.51397763, 6.014414497131033 MeV\nPhase: 272.7380383261756, Scale: 49913108.51397763, 6.006193877999476 MeV\nPhase: 279.58863115317683, Scale: 49913108.51397763, 6.058993766745926 MeV\nPhase: 288.06076728489535, Scale: 49913108.51397763, 6.157962967636211 MeV\nPhase: 301.7689715986444, Scale: 49913108.51397763, 6.273411298491424 MeV\nPhase: 323.5660628149726, Scale: 49913108.51397763, 6.050877274480177 MeV\nPhase: 301.7689715986444, Scale: 49913108.51397763, 6.273411298491424 MeV\nPhase: 310.0947193421804, Scale: 49913108.51397763, 6.262266360458263 MeV\nPhase: 296.53290362973894, Scale: 49913108.51397763, 6.24414356572568 MeV\nPhase: 304.6217025876324, Scale: 49913108.51397763, 6.278408531616231 MeV\nPhase: 304.746502961286, Scale: 49913108.51397763, 6.278429368798819 MeV\nPhase: 304.8409520620972, Scale: 49913108.51397763, 6.278433708677461 MeV\nPhase: 304.8353521187191, Scale: 49913108.51397763, 6.278433726656093 MeV\nPhase: 304.83504728335697, Scale: 49913108.51397763, 6.278433726656093 MeV\nPhase: 304.83474244829966, Scale: 49913108.51397763, 6.278433726503301 MeV\nStep 3 phase found:  304.83504728335697\nPhase: 304.83504728335697, Scale: 10000000.0, 1.100797374544621 MeV\nPhase: 304.83504728335697, Scale: 100000000.0, 12.026575464849873 MeV\nPhase: 304.83504728335697, Scale: 50356689.71551161, 6.330396865396243 MeV\nPhase: 304.83504728335697, Scale: 47807025.290329695, 6.031237566615368 MeV\nPhase: 304.83504728335697, Scale: 47542481.59253075, 6.0001286759877885 MeV\nPhase: 304.83504728335697, Scale: 47541388.043662004, 6.000000052316555 MeV\nPhase: 304.83504728335697, Scale: 47541364.27296798, 5.999997256379129 MeV\nStep 4 scale found:  47541388.043662004\nSet Phase: 304.83504728335697, Scale: 47541388.043662004\n</pre> Out[7]: <pre>(304.83504728335697, 47541388.043662004)</pre> <p>Check the energy:</p> In\u00a0[8]: Copied! <pre>I.verbose=False\nPF = I.track(P0, s=0.15)\nPF['mean_energy']\n</pre> I.verbose=False PF = I.track(P0, s=0.15) PF['mean_energy'] Out[8]: <pre>6000000.052316555</pre> <p>Examine this process using the debug flag. This will return the function used for phasing and scaling.</p> In\u00a0[9]: Copied! <pre>ps_f, Itest = autophase_and_scale(I, phase_ele_name='GUN', target=6e6, initial_particles=P0, verbose=False,\n                     debug = True)\n</pre> ps_f, Itest = autophase_and_scale(I, phase_ele_name='GUN', target=6e6, initial_particles=P0, verbose=False,                      debug = True)  <p>Plot various phases and scales:</p> In\u00a0[10]: Copied! <pre>ptry = np.linspace(-100, 50, 30)\nfor sc in np.linspace(10e6, 100e6, 5):\n    res = np.array([ps_f(p, sc)/1e6 for p in ptry])\n    plt.plot(ptry, res, label=f'{sc/1e6:0.2f} MV')\nplt.title('Final energy for various phases and scales')\nplt.ylabel('Final energy (MeV)')\nplt.xlabel('phase (deg)')\nplt.legend()\n</pre> ptry = np.linspace(-100, 50, 30) for sc in np.linspace(10e6, 100e6, 5):     res = np.array([ps_f(p, sc)/1e6 for p in ptry])     plt.plot(ptry, res, label=f'{sc/1e6:0.2f} MV') plt.title('Final energy for various phases and scales') plt.ylabel('Final energy (MeV)') plt.xlabel('phase (deg)') plt.legend() Out[10]: <pre>&lt;matplotlib.legend.Legend at 0x1552d60a0&gt;</pre> <p>Make a 3D data and plot the surface</p> In\u00a0[11]: Copied! <pre>X = np.linspace(-100, 50, 10)\nY = np.linspace(10e6, 100e6, 10)\nX, Y = np.meshgrid(X, Y)\n@np.vectorize\ndef f(phase, scale):\n    return ps_f(phase, scale)\nZ = f(X, Y)\n</pre> X = np.linspace(-100, 50, 10) Y = np.linspace(10e6, 100e6, 10) X, Y = np.meshgrid(X, Y) @np.vectorize def f(phase, scale):     return ps_f(phase, scale) Z = f(X, Y) In\u00a0[12]: Copied! <pre>fig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\nsurf = ax.plot_surface(X, Y/1e6, Z/1e6, cmap=matplotlib.cm.coolwarm,\n                       linewidth=0, antialiased=True)\n\n# Add a color bar which maps values to colors.\n#fig.colorbar(surf, shrink=0.5, aspect=5)\n\nax.set_xlabel('phase (deg)')\nax.set_ylabel('scale (MV)')\nax.set_zlabel('Final energy (MeV)')\nplt.show()\n</pre>  fig = plt.figure() ax = fig.add_subplot(111, projection='3d')  surf = ax.plot_surface(X, Y/1e6, Z/1e6, cmap=matplotlib.cm.coolwarm,                        linewidth=0, antialiased=True)  # Add a color bar which maps values to colors. #fig.colorbar(surf, shrink=0.5, aspect=5)  ax.set_xlabel('phase (deg)') ax.set_ylabel('scale (MV)') ax.set_zlabel('Final energy (MeV)') plt.show()   In\u00a0[13]: Copied! <pre>I.add_group('L0A', ele_names=['L0A_entrance', 'L0A_body_1', 'L0A_body_2', 'L0A_exit'], var_name='theta0_deg', attributes='theta0_deg')\nI.add_group('L0B', ele_names=['L0B_entrance', 'L0B_body_1', 'L0B_body_2', 'L0B_exit'], var_name='theta0_deg', attributes='theta0_deg')\n</pre> I.add_group('L0A', ele_names=['L0A_entrance', 'L0A_body_1', 'L0A_body_2', 'L0A_exit'], var_name='theta0_deg', attributes='theta0_deg') I.add_group('L0B', ele_names=['L0B_entrance', 'L0B_body_1', 'L0B_body_2', 'L0B_exit'], var_name='theta0_deg', attributes='theta0_deg') Out[13]: <pre>ControlGroup(**{\"ele_names\": [\"L0B_entrance\", \"L0B_body_1\", \"L0B_body_2\", \"L0B_exit\"], \"var_name\": \"theta0_deg\", \"attributes\": [\"theta0_deg\", \"theta0_deg\", \"theta0_deg\", \"theta0_deg\"], \"factors\": [1.0, 1.0, 1.0, 1.0], \"reference_values\": [42.27, 72.27, 132.27, 42.27], \"absolute\": false, \"value\": 0.0, \"name\": \"L0B\"})</pre> <p>These will control overall scaling, respecting the special factors:</p> In\u00a0[14]: Copied! <pre>I.add_group('L0A_scale', ele_names=['L0A_entrance', 'L0A_body_1', 'L0A_body_2', 'L0A_exit'],\n                   var_name = 'rf_field_scale',\n                  factors = [0.86571945106805, 1, 1, 0.86571945106805],  # sin(k*d) with d = 3.5e-2 m \n                  absolute=True)\n\nI.add_group('L0B_scale', ele_names=['L0B_entrance', 'L0B_body_1', 'L0B_body_2', 'L0B_exit'],\n                   var_name = 'rf_field_scale',\n                  factors = [0.86571945106805, 1, 1, 0.86571945106805],  # sin(k*d) with d = 3.5e-2 m \n                  absolute=True)\n\nI['L0A_scale']['rf_field_scale'] = 30e6\n#I['L0A_scale'].__dict__\n</pre> I.add_group('L0A_scale', ele_names=['L0A_entrance', 'L0A_body_1', 'L0A_body_2', 'L0A_exit'],                    var_name = 'rf_field_scale',                   factors = [0.86571945106805, 1, 1, 0.86571945106805],  # sin(k*d) with d = 3.5e-2 m                    absolute=True)  I.add_group('L0B_scale', ele_names=['L0B_entrance', 'L0B_body_1', 'L0B_body_2', 'L0B_exit'],                    var_name = 'rf_field_scale',                   factors = [0.86571945106805, 1, 1, 0.86571945106805],  # sin(k*d) with d = 3.5e-2 m                    absolute=True)  I['L0A_scale']['rf_field_scale'] = 30e6 #I['L0A_scale'].__dict__   <p>Now phase and scale L0A to 64 MeV:</p> In\u00a0[15]: Copied! <pre>res_L0A = autophase_and_scale(I, phase_ele_name='L0A', scale_ele_name='L0A_scale', target=64e6, scale_range=(10e6, 100e6), initial_particles=P0, verbose=True)\n</pre> res_L0A = autophase_and_scale(I, phase_ele_name='L0A', scale_ele_name='L0A_scale', target=64e6, scale_range=(10e6, 100e6), initial_particles=P0, verbose=True) <pre>Copied initial Impact object. \nPhasing L0A by changing theta0_deg\nScaling L0A_scale by changing rf_field_scale\nBounds: 1.485, 4.527856 m\nTracking initial particles to s = 1.485\nInitial particle:  1.48542826044 6000000.052316555\nDisabling GUN\nDisabling SOL1\nDisabling L0B_entrance\nDisabling L0B_body_1\nDisabling L0B_body_2\nDisabling L0B_exit\nDefault brent2 algorithm\nPhase: 180, Scale: 10000000.0, 14.167255568451399 MeV\nPhase: 180, Scale: 10000000.0, 14.167255568451399 MeV\nPhase: 42.49224000000004, Scale: 10000000.0, 19.900599221746855 MeV\nPhase: 264.9844890561601, Scale: 10000000.0, 8.713842837127276 MeV\nPhase: 42.49224000000004, Scale: 10000000.0, 19.900599221746855 MeV\nPhase: 42.49223440298533, Scale: 10000000.0, 19.90060061459368 MeV\nPhase: 264.9844709438398, Scale: 10000000.0, 8.713840068114541 MeV\nPhase: 222.49225961302204, Scale: 10000000.0, 10.405713584337981 MeV\nPhase: 127.47670402554945, Scale: 10000000.0, 8.198791876959703 MeV\nPhase: 333.73836403236214, Scale: 10000000.0, 23.41992448228477 MeV\nPhase: 291.24613451172445, Scale: 10000000.0, 14.431300814270562 MeV\nPhase: 4.88234763906803e-06, Scale: 10000000.0, 25.29364711479038 MeV\nPhase: 358.9200048774553, Scale: 10000000.0, 25.292053052340982 MeV\nPhase: 1.0800048872399657, Scale: 10000000.0, 25.288424614826123 MeV\nStep 1 phasing found: 4.88234763906803e-06\nPhase: 4.88234763906803e-06, Scale: 10000000.0, 25.29364711479038 MeV\nPhase: 4.88234763906803e-06, Scale: 100000000.0, 198.2786027688882 MeV\nPhase: 4.88234763906803e-06, Scale: 30138004.177858368, 64.08285768443744 MeV\nPhase: 4.88234763906803e-06, Scale: 30094987.36027264, 64.0001343260896 MeV\nPhase: 4.88234763906803e-06, Scale: 30079939.8665925, 63.97119721819594 MeV\nStep 2  scale found: 30094987.36027264\nPhase: 359.00000488234764, Scale: 30094987.36027264, 63.9352460536336 MeV\nPhase: 1.000004882347639, Scale: 30094987.36027264, 64.04753882304797 MeV\nPhase: 4.236072882347639, Scale: 30094987.36027264, 64.08051762064106 MeV\nPhase: 3.198610951060463, Scale: 30094987.36027264, 64.090035507204 MeV\nPhase: 3.198610951060463, Scale: 30094987.36027264, 64.090035507204 MeV\nPhase: 2.3588181854185004, Scale: 30094987.36027264, 64.08383986409696 MeV\nPhase: 3.5948861351065, Scale: 30094987.36027264, 64.08864219722666 MeV\nPhase: 3.1972720524922056, Scale: 30094987.36027264, 64.0900355204897 MeV\nPhase: 3.1973788430773293, Scale: 30094987.36027264, 64.0900355204897 MeV\nPhase: 3.1973254477847677, Scale: 30094987.36027264, 64.0900355204897 MeV\nPhase: 3.1973050525984488, Scale: 30094987.36027264, 64.0900355204897 MeV\nPhase: 3.1972924476798674, Scale: 30094987.36027264, 64.0900355204897 MeV\nPhase: 3.197284657411617, Scale: 30094987.36027264, 64.0900355204897 MeV\nPhase: 3.197279842760969, Scale: 30094987.36027264, 64.0900355204897 MeV\nPhase: 3.1972766454711263, Scale: 30094987.36027264, 64.0900355204897 MeV\nStep 3 phase found:  3.1972766454711263\nPhase: 3.1972766454711263, Scale: 10000000.0, 25.25831257110827 MeV\nPhase: 3.1972766454711263, Scale: 100000000.0, 198.9261415481004 MeV\nPhase: 3.1972766454711263, Scale: 30077131.66646534, 64.0555674254624 MeV\nPhase: 3.1972766454711263, Scale: 30048376.165037125, 64.00005859296365 MeV\nPhase: 3.1972766454711263, Scale: 30048345.811894644, 63.999999999932065 MeV\nPhase: 3.1972766454711263, Scale: 30048360.83606755, 64.00002900211835 MeV\nStep 4 scale found:  30048345.811894644\nSet Phase: 3.1972766454711263, Scale: 30048345.811894644\n</pre> <p>Do the same for L0B:</p> In\u00a0[16]: Copied! <pre>autophase_and_scale(I, phase_ele_name='L0B', scale_ele_name='L0B_scale', target=135e6, scale_range=(10e6, 100e6), initial_particles=P0, verbose=True)\n</pre> autophase_and_scale(I, phase_ele_name='L0B', scale_ele_name='L0B_scale', target=135e6, scale_range=(10e6, 100e6), initial_particles=P0, verbose=True) <pre>Copied initial Impact object. \nPhasing L0B by changing theta0_deg\nScaling L0B_scale by changing rf_field_scale\nBounds: 5.328756, 8.371612 m\nTracking initial particles to s = 5.328756\nInitial particle:  5.32879919802 63999921.091522284\nDisabling GUN\nDisabling SOL1\nDisabling L0A_entrance\nDisabling L0A_body_1\nDisabling L0A_body_2\nDisabling L0A_exit\nDefault brent2 algorithm\nPhase: 180, Scale: 10000000.0, 44.70994104082657 MeV\nPhase: 180, Scale: 10000000.0, 44.70994104082657 MeV\nPhase: 42.49224000000004, Scale: 10000000.0, 78.71763465173481 MeV\nPhase: 264.9844890561601, Scale: 10000000.0, 61.5952210094941 MeV\nPhase: 42.49224000000004, Scale: 10000000.0, 78.71763465173481 MeV\nPhase: 42.49223440298533, Scale: 10000000.0, 78.71763587198903 MeV\nPhase: 264.9844709438398, Scale: 10000000.0, 61.595214958381135 MeV\nPhase: 222.492250029454, Scale: 10000000.0, 49.29478897684319 MeV\nPhase: 127.47670402554945, Scale: 10000000.0, 52.83159870210305 MeV\nPhase: 333.7383603717651, Scale: 10000000.0, 80.97585983113255 MeV\nPhase: 291.2461285887539, Scale: 10000000.0, 70.3137459013076 MeV\nPhase: 2.61997411143966e-06, Scale: 10000000.0, 83.29039104727464 MeV\nPhase: 2.3470891902397852, Scale: 10000000.0, 83.30418962477839 MeV\nPhase: 1.2647421010394737, Scale: 10000000.0, 83.30185037017291 MeV\nPhase: 3.4294362794400968, Scale: 10000000.0, 83.29964054916793 MeV\nStep 1 phasing found: 2.3470891902397852\nPhase: 2.3470891902397852, Scale: 10000000.0, 83.30418962477839 MeV\nPhase: 2.3470891902397852, Scale: 100000000.0, 257.0347067328422 MeV\nPhase: 2.3470891902397852, Scale: 36780688.91532696, 135.0001104481728 MeV\nPhase: 2.3470891902397852, Scale: 36762298.5708693, 134.96461083261016 MeV\nStep 2  scale found: 36780688.91532696\nPhase: 1.3470891902397852, Scale: 36780688.91532696, 134.99218801678353 MeV\nPhase: 3.3470891902397852, Scale: 36780688.91532696, 134.98640557724622 MeV\nPhase: 358.1110211902398, Scale: 36780688.91532696, 134.81839744826186 MeV\nPhase: 1.3470891902397852, Scale: 36780688.91532696, 134.99218801678353 MeV\nPhase: 0.1110212405517852, Scale: 36780688.91532696, 134.95251244313832 MeV\nPhase: 2.1110211902397853, Scale: 36780688.91532696, 135.0001903391442 MeV\nPhase: 2.2135003506046598, Scale: 36780688.91532696, 135.00030370121428 MeV\nPhase: 2.2134093929020993, Scale: 36780688.91532696, 135.00030370121428 MeV\nPhase: 2.2134548717533793, Scale: 36780688.91532696, 135.00030370121428 MeV\nPhase: 2.2134375003784714, Scale: 36780688.91532696, 135.00030370121428 MeV\nPhase: 2.2134267642781515, Scale: 36780688.91532696, 135.00030370121428 MeV\nPhase: 2.2134201290031266, Scale: 36780688.91532696, 135.00030370121428 MeV\nPhase: 2.2134160281775617, Scale: 36780688.91532696, 135.00030370121428 MeV\nPhase: 2.2134134937279346, Scale: 36780688.91532696, 135.00030370121428 MeV\nStep 3 phase found:  2.2134134937279346\nPhase: 2.2134134937279346, Scale: 10000000.0, 83.30427355474856 MeV\nPhase: 2.2134134937279346, Scale: 100000000.0, 257.0349352814208 MeV\nPhase: 2.2134134937279346, Scale: 36780623.1429229, 135.00017673782156 MeV\nPhase: 2.2134134937279346, Scale: 36780531.58539701, 135.00000000034336 MeV\nPhase: 2.2134134937279346, Scale: 36780513.19513122, 134.9999645010803 MeV\nStep 4 scale found:  36780531.58539701\nSet Phase: 2.2134134937279346, Scale: 36780531.58539701\n</pre> Out[16]: <pre>(2.2134134937279346, 36780531.58539701)</pre> <p>Check the final energy and plot:</p> In\u00a0[17]: Copied! <pre>I.track(P0, s=8.371612)['mean_energy']\n</pre> I.track(P0, s=8.371612)['mean_energy'] Out[17]: <pre>134999248.954592</pre> In\u00a0[18]: Copied! <pre>plt.plot(I.stat('mean_z'), I.stat('mean_kinetic_energy')/1e6 + 0.511)\n</pre> plt.plot(I.stat('mean_z'), I.stat('mean_kinetic_energy')/1e6 + 0.511) Out[18]: <pre>[&lt;matplotlib.lines.Line2D at 0x15746b9a0&gt;]</pre> In\u00a0[19]: Copied! <pre>%%time\nI.autophase()\n</pre> %%time I.autophase() <pre>CPU times: user 3.11 s, sys: 5.15 ms, total: 3.12 s\nWall time: 3.12 s\n</pre> Out[19]: <pre>{'GUN': 0.9521663554547786,\n 'L0A': 0.012681210292811329,\n 'L0B': 0.009141795452762835}</pre> <p>Sending in a dict will set these phases as it goes:</p> In\u00a0[20]: Copied! <pre>I.verbose=True\n\nI.autophase({'GUN': 1,\n 'L0A': 2,\n 'L0B': 3})\n</pre> I.verbose=True  I.autophase({'GUN': 1,  'L0A': 2,  'L0B': 3}) <pre>Setting GUN relative phase = 1 deg\nFound GUN        relative phase = 1.00 deg\nSetting L0A relative phase = 2 deg\nFound L0A        relative phase = 2.00 deg\nSetting L0B relative phase = 3 deg\nFound L0B        relative phase = 3.00 deg\n</pre> Out[20]: <pre>{'GUN': 1.0, 'L0A': 2.0, 'L0B': 3.0}</pre> In\u00a0[21]: Copied! <pre>from impact.autophase import autophase\n\nifile2 = 'templates/apex_gun/ImpactT.in'\n\nI2 = Impact(ifile2, verbose=False)\n</pre> from impact.autophase import autophase  ifile2 = 'templates/apex_gun/ImpactT.in'  I2 = Impact(ifile2, verbose=False) In\u00a0[22]: Copied! <pre>autophase(I2, ele_name='APEX_GUN', initial_particles=P0, metric='mean_kinetic_energy', verbose=True)\n</pre> autophase(I2, ele_name='APEX_GUN', initial_particles=P0, metric='mean_kinetic_energy', verbose=True) <pre>Copied initial Impact object. \nPhasing APEX_GUN by changing theta0_deg\nBounds: 0.0, 0.199 m\nDisabling SOL1\nDefault brent2 algorithm\nPhase: 180, 0.7501400260547707 MeV\nPhase: 180, 0.7501400260547707 MeV\nPhase: 42.49224000000004, 0.0 M\nPhase: 180, 0.7501400260547707 MeV\nPhase: 42.49223094384001, 0.0 M\nPhase: 42.49223999999998, 0.0 M\nPhase: 222.49223547192, 0.46487921649929437 MeV\nPhase: 151.59398241178104, 0.714711059468071 MeV\nPhase: 171.3511003792883, 0.7585459504017038 MeV\nPhase: 171.34908462106745, 0.7585459029872261 MeV\nPhase: 171.4523027473299, 0.7585471358806966 MeV\nPhase: 171.45289970740637, 0.7585471359181192 MeV\nPhase: 171.45272825449666, 0.7585471359181192 MeV\nPhase: 171.45255680175842, 0.7585471359087637 MeV\nSet Phase: 171.45272825449666\n</pre> Out[22]: <pre>171.45272825449666</pre> In\u00a0[23]: Copied! <pre>phase_f, Itest = autophase(I2, ele_name='APEX_GUN', metric='mean_kinetic_energy', initial_particles=P0, debug = True)\n</pre> phase_f, Itest = autophase(I2, ele_name='APEX_GUN', metric='mean_kinetic_energy', initial_particles=P0, debug = True) In\u00a0[24]: Copied! <pre># Phases to try\nptry = np.linspace(0, 360, 60)\n\nenergies = np.array([phase_f(p)/1e3 for p in ptry]) \n\nplt.plot(ptry, energies)\nplt.ylim(0, 800)\nplt.title('Final energy for various phases in the APEX gun')\nplt.ylabel('Final kinetic energy (keV)')\nplt.xlabel('phase (deg)')\n</pre> # Phases to try ptry = np.linspace(0, 360, 60)  energies = np.array([phase_f(p)/1e3 for p in ptry])   plt.plot(ptry, energies) plt.ylim(0, 800) plt.title('Final energy for various phases in the APEX gun') plt.ylabel('Final kinetic energy (keV)') plt.xlabel('phase (deg)')  Out[24]: <pre>Text(0.5, 0, 'phase (deg)')</pre> In\u00a0[25]: Copied! <pre>from distgen import Generator\n\n\nifile = 'templates/lcls_injector/ImpactT.in'\ngfile = 'templates/lcls_injector/distgen.yaml'\n\nG = Generator(gfile)\nG['n_particle'] = 2000\nG.run()\nP0 = G.particles\n</pre> from distgen import Generator   ifile = 'templates/lcls_injector/ImpactT.in' gfile = 'templates/lcls_injector/distgen.yaml'  G = Generator(gfile) G['n_particle'] = 2000 G.run() P0 = G.particles  In\u00a0[26]: Copied! <pre>%%time\nI = Impact(ifile, initial_particles=P0, verbose=False)\nI.stop = 0.16\nI.numprocs=4\nI.run()\n</pre> %%time I = Impact(ifile, initial_particles=P0, verbose=False) I.stop = 0.16 I.numprocs=4 I.run() <pre>CPU times: user 42.3 ms, sys: 20.6 ms, total: 62.9 ms\nWall time: 10.7 s\n</pre> In\u00a0[27]: Copied! <pre>phase_f, Itest = autophase(I, ele_name='GUN', metric='sigma_pz', maximize=False, initial_particles=P0, debug = True, verbose=True)\n</pre> phase_f, Itest = autophase(I, ele_name='GUN', metric='sigma_pz', maximize=False, initial_particles=P0, debug = True, verbose=True) <pre>Copied initial Impact object. \nPhasing GUN by changing theta0_deg\nBounds: 0.0, 0.15 m\nDisabling SOL1\nDisabling L0A_entrance\nDisabling L0A_body_1\nDisabling L0A_body_2\nDisabling L0A_exit\nDisabling L0B_entrance\nDisabling L0B_body_1\nDisabling L0B_body_2\nDisabling L0B_exit\n</pre> In\u00a0[28]: Copied! <pre>I.particles['final_particles'].plot('z', 'pz')\n</pre> I.particles['final_particles'].plot('z', 'pz') In\u00a0[29]: Copied! <pre># Phases to try\nptry = np.linspace(290, 310, 20)\n\nsigma_pzs = np.array([phase_f(p) for p in ptry]) \n\nplt.plot(ptry, sigma_pzs)\n#plt.ylim(0, 800)\n#plt.title('Final energy for various phases in the APEX gun')\n#plt.ylabel('Final kinetic energy (keV)')\nplt.xlabel('phase (deg)')\n</pre> # Phases to try ptry = np.linspace(290, 310, 20)  sigma_pzs = np.array([phase_f(p) for p in ptry])   plt.plot(ptry, sigma_pzs) #plt.ylim(0, 800) #plt.title('Final energy for various phases in the APEX gun') #plt.ylabel('Final kinetic energy (keV)') plt.xlabel('phase (deg)') <pre>Phase: 290.0, 0.009106227078428706 MeV/c\nPhase: 291.05263157894734, 0.006605349204520739 MeV/c\nPhase: 292.10526315789474, 0.004250315506050118 MeV/c\nPhase: 293.1578947368421, 0.0023315139934531855 MeV/c\nPhase: 294.2105263157895, 0.002270098175340596 MeV/c\nPhase: 295.2631578947368, 0.004090322347295973 MeV/c\nPhase: 296.3157894736842, 0.006313757601189942 MeV/c\nPhase: 297.36842105263156, 0.008619720108184637 MeV/c\nPhase: 298.42105263157896, 0.010951504151510517 MeV/c\nPhase: 299.4736842105263, 0.013288444993249347 MeV/c\nPhase: 300.5263157894737, 0.01562918610793116 MeV/c\nPhase: 301.57894736842104, 0.017975166945619375 MeV/c\nPhase: 302.63157894736844, 0.02032086816927392 MeV/c\nPhase: 303.6842105263158, 0.022673318400329007 MeV/c\nPhase: 304.7368421052632, 0.02502747591944281 MeV/c\nPhase: 305.7894736842105, 0.02739003632177207 MeV/c\nPhase: 306.8421052631579, 0.029756102948928064 MeV/c\nPhase: 307.89473684210526, 0.03213287988114859 MeV/c\nPhase: 308.9473684210526, 0.03451511241009492 MeV/c\nPhase: 310.0, 0.03690995361387939 MeV/c\n</pre> Out[29]: <pre>Text(0.5, 0, 'phase (deg)')</pre> In\u00a0[30]: Copied! <pre>phase_f(293.5)\n</pre> phase_f(293.5) <pre>Phase: 293.5, 0.0020044868626914263 MeV/c\n</pre> Out[30]: <pre>2004.4868626914263</pre> In\u00a0[31]: Copied! <pre>Itest.particles['final_particles'].plot('z', 'pz')\n</pre> Itest.particles['final_particles'].plot('z', 'pz') In\u00a0[32]: Copied! <pre>phase_f, Itest = autophase(I, ele_name='GUN', metric='sigma_pz',\n                           maximize=False, initial_particles=P0, debug = True,\n                           s_stop = 1.45,\n                           verbose=True)\n# Phases to try\nptry = np.linspace(270, 290, 30)\n\nsigma_pzs = np.array([phase_f(p) for p in ptry]) \n\nplt.plot(ptry, sigma_pzs)\n#plt.ylim(0, 800)\n#plt.title('Final energy for various phases in the APEX gun')\n#plt.ylabel('Final kinetic energy (keV)')\nplt.xlabel('phase (deg)')\n</pre> phase_f, Itest = autophase(I, ele_name='GUN', metric='sigma_pz',                            maximize=False, initial_particles=P0, debug = True,                            s_stop = 1.45,                            verbose=True) # Phases to try ptry = np.linspace(270, 290, 30)  sigma_pzs = np.array([phase_f(p) for p in ptry])   plt.plot(ptry, sigma_pzs) #plt.ylim(0, 800) #plt.title('Final energy for various phases in the APEX gun') #plt.ylabel('Final kinetic energy (keV)') plt.xlabel('phase (deg)') <pre>Copied initial Impact object. \nPhasing GUN by changing theta0_deg\nBounds: 0.0, 1.45 m\nDisabling SOL1\nDisabling L0A_entrance\nDisabling L0A_body_1\nDisabling L0A_body_2\nDisabling L0A_exit\nDisabling L0B_entrance\nDisabling L0B_body_1\nDisabling L0B_body_2\nDisabling L0B_exit\nPhase: 270.0, 0.06020800143839181 MeV/c\nPhase: 270.6896551724138, 0.05282518150121898 MeV/c\nPhase: 271.37931034482756, 0.04781286856710534 MeV/c\nPhase: 272.0689655172414, 0.04413012157350279 MeV/c\nPhase: 272.7586206896552, 0.03870396510755223 MeV/c\nPhase: 273.44827586206895, 0.034061008652399034 MeV/c\nPhase: 274.13793103448273, 0.032244268179933026 MeV/c\nPhase: 274.82758620689657, 0.029851046782785325 MeV/c\nPhase: 275.51724137931035, 0.028498231557931193 MeV/c\nPhase: 276.2068965517241, 0.026431988379873955 MeV/c\nPhase: 276.8965517241379, 0.024552733266184845 MeV/c\nPhase: 277.58620689655174, 0.022689324417420397 MeV/c\nPhase: 278.2758620689655, 0.021455856019700598 MeV/c\nPhase: 278.9655172413793, 0.02036842851081785 MeV/c\nPhase: 279.6551724137931, 0.01951107002906529 MeV/c\nPhase: 280.3448275862069, 0.019262954524237094 MeV/c\nPhase: 281.0344827586207, 0.019298303098851017 MeV/c\nPhase: 281.7241379310345, 0.019218467810723994 MeV/c\nPhase: 282.41379310344826, 0.019245342079260108 MeV/c\nPhase: 283.1034482758621, 0.01972695288260386 MeV/c\nPhase: 283.7931034482759, 0.020250372672276848 MeV/c\nPhase: 284.48275862068965, 0.020963007815243562 MeV/c\nPhase: 285.17241379310343, 0.021767278489390928 MeV/c\nPhase: 285.86206896551727, 0.022628739089511896 MeV/c\nPhase: 286.55172413793105, 0.0237170283273593 MeV/c\nPhase: 287.2413793103448, 0.024863300594724573 MeV/c\nPhase: 287.9310344827586, 0.0260733977920168 MeV/c\nPhase: 288.62068965517244, 0.02728330261592406 MeV/c\nPhase: 289.3103448275862, 0.028498447635066645 MeV/c\nPhase: 290.0, 0.029719767211469093 MeV/c\n</pre> Out[32]: <pre>Text(0.5, 0, 'phase (deg)')</pre> In\u00a0[33]: Copied! <pre>phase_f(280.0)\n</pre> phase_f(280.0) <pre>Phase: 280.0, 0.01921625959692407 MeV/c\n</pre> Out[33]: <pre>19216.25959692407</pre> In\u00a0[34]: Copied! <pre>Itest.particles['final_particles'].plot('z', 'pz')\n</pre> Itest.particles['final_particles'].plot('z', 'pz')"},{"location":"examples/autophase_example/#autophase-and-autophase-and-scale-examples","title":"Autophase and Autophase and Scale examples\u00b6","text":"<p>This includes general (slow) autophasing and scaling, as well as fast autophasing.</p>"},{"location":"examples/autophase_example/#phase-and-scale-the-lcls-gun","title":"Phase and Scale the LCLS gun\u00b6","text":""},{"location":"examples/autophase_example/#phase-and-scale-lcls-linac-sections","title":"Phase and scale LCLS linac sections\u00b6","text":"<p>Linacs L0A and L0B are special, because they require 4 fieldmaps each to model the travelling wave structure. To tune these together, we need to add control groups.</p> <p>These will control overall phases:</p>"},{"location":"examples/autophase_example/#fast-autophase","title":"Fast autophase\u00b6","text":"<p>This is a faster method that can find and set all relative phases by tracking the fields externally.</p>"},{"location":"examples/autophase_example/#autophase-without-scaling","title":"Autophase without scaling\u00b6","text":"<p>Just phasing is simpler.</p>"},{"location":"examples/autophase_example/#autophase-with-alternative-metric-and-bunch-tracking-with-space-charge","title":"Autophase with alternative metric, and bunch tracking with space charge.\u00b6","text":"<p>The above uses <code>mean_energy</code> as the metric to maximize. Alternatively, one might want to minimize energy spread. This is accomplished by passing <code>maximize=False</code> and  <code>metric='sigma_pz'</code> or similar.</p>"},{"location":"examples/basic_impact_examples/","title":"LUME-Impact Basics","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n\n# Nicer plotting\nimport matplotlib.pyplot as plt\nimport matplotlib\nimport os\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nmatplotlib.rcParams['figure.figsize'] = (8,4)\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2  # Nicer plotting import matplotlib.pyplot as plt import matplotlib import os %matplotlib inline %config InlineBackend.figure_format = 'retina' matplotlib.rcParams['figure.figsize'] = (8,4) In\u00a0[2]: Copied! <pre>from impact import Impact\n</pre> from impact import Impact <p>Point to a valid input file</p> In\u00a0[3]: Copied! <pre>ifile = 'templates/lcls_injector/ImpactT.in'\n</pre> ifile = 'templates/lcls_injector/ImpactT.in' <p>Make Impact object</p> In\u00a0[4]: Copied! <pre>I = Impact(ifile, verbose=True)\n</pre> I = Impact(ifile, verbose=True) <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp8m1a68h4\n</pre> <p>Change some things</p> In\u00a0[5]: Copied! <pre>I.header['Np'] = 10000\nI.header['Nx'] = 16\nI.header['Ny'] = 16\nI.header['Nz'] = 16\nI.header['Dt'] = 5e-13\n\n# Turn Space Charge off. Both these syntaxes work\nI.header['Bcurr'] = 0 \nI['header:Bcurr'] = 0 \n\n# Other switches\nI.timeout = None\n\n# Switches for MPI\nI.numprocs = 4\n\n# This is equivalent to:\n#I.use_mpi=True\n#I.header['Nprow'] = 2\n#I.header['Npcol'] = 2\n</pre> I.header['Np'] = 10000 I.header['Nx'] = 16 I.header['Ny'] = 16 I.header['Nz'] = 16 I.header['Dt'] = 5e-13  # Turn Space Charge off. Both these syntaxes work I.header['Bcurr'] = 0  I['header:Bcurr'] = 0   # Other switches I.timeout = None  # Switches for MPI I.numprocs = 4  # This is equivalent to: #I.use_mpi=True #I.header['Nprow'] = 2 #I.header['Npcol'] = 2   <pre>Setting Npcol, Nprow = 2, 2\nEnabling MPI\n</pre> <p>Plot the layout.</p> In\u00a0[6]: Copied! <pre>I.plot()\n</pre> I.plot() <p>Change stop location. Here this is does the same as <code>I.ele['stop_1']['s'] = 1.5</code>.</p> In\u00a0[7]: Copied! <pre>I.stop = 1.5\n</pre> I.stop = 1.5 <pre>Removed element: stop_1\nSet stop to s = 1.5\n</pre> <p>Run Impact-T. This automatically finds the appropriate executable.</p> In\u00a0[8]: Copied! <pre>I.run()\n</pre> I.run() <pre>Running Impact-T in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp8m1a68h4\nmpirun -n 4 /Users/chrisonian/Code/Impact/IMPACT-T/build-mpi/ImpactTexe-mpi\n !-----------------------------------------------------------\n ! IMPACT-T Parallel Beam Dynamics Tracking Code: 2.1 beta version\n ! Copyright of The Regents of the University of California\n !-----------------------------------------------------------\n nblem:           28          28\n pass setting up lattice...\n check randomness:            0  0.30440529327431320     \n check randomness:            1  0.83543324059415791     \n check randomness:            2  0.66382677037082638     \n check randomness:            3  0.69219578710848950     \n avgpts, jlow, and jhigh:         2500           1        2500\n avgpts, jlow, and jhigh:         2500        2501        5000\n avgpts, jlow, and jhigh:         2500        5001        7500\n avgpts, jlow, and jhigh:         2500        7501       10000\n before  destruct4:, elapsed: 6.751051902770996Finished.3466027377550, elapsed: 6.7269790172576995223145\nLoaded fort 30 : Fourth root of the fourth moments of the beam distribution\nLoaded fort 25 : RMS Y information\nLoaded fort 24 : RMS X information\nLoaded fort 26 : RMS Z information\nLoaded fort 28 : Load balance and loss diagnostics\nLoaded fort 29 : Cube root of third moments of the beam distribution\nLoaded fort 18 : Time and energy\nLoaded fort 27 : Max amplitude information\nLoaded fort 70 : Slice information of the final distribution\nLoaded fort 60 : Slice information of the initial distribution\nLoading particles\nLoaded fort 40 : initial particle distribution at t = 0\nLoaded fort 50 : final particle distribution projected to the centroid location of the bunch\nLoaded write beam particles YAG02 fort.102\nConverting z to t according to cathode_kinetic_energy_ref = 1.0 eV\nConverted initial_particles to ParticleGroup\nConverted final_particles to ParticleGroup\nConverted YAG02 to ParticleGroup\n</pre> <p>Plot now shows the output statistics.</p> In\u00a0[9]: Copied! <pre>I.plot()\n#plt.savefig('../assets/plot.png', dpi=150)\n</pre> I.plot() #plt.savefig('../assets/plot.png', dpi=150) <p>These are used to create the input.</p> In\u00a0[10]: Copied! <pre>I.input.keys()\n</pre> I.input.keys() Out[10]: <pre>dict_keys(['original_input', 'input_particle_file', 'header', 'lattice', 'fieldmaps'])</pre> <p>This is the output parsed</p> In\u00a0[11]: Copied! <pre>I.output.keys()\n</pre> I.output.keys() Out[11]: <pre>dict_keys(['run_info', 'stats', 'slice_info', 'particles'])</pre> <p>stats from the various fort. files</p> In\u00a0[12]: Copied! <pre>I.output['stats'].keys()\n</pre> I.output['stats'].keys() Out[12]: <pre>dict_keys(['t', 'mean_z', 'moment4_x', 'moment4_y', 'moment4_z', 'mean_y', 'sigma_y', 'norm_emit_y', 'mean_x', 'sigma_x', 'norm_emit_x', 'sigma_z', 'norm_emit_z', 'loadbalance_min_n_particle', 'loadbalance_max_n_particle', 'n_particle', 'moment3_x', 'moment3_y', 'moment3_z', 'mean_gamma', 'mean_beta', 'max_r', 'sigma_gamma', 'max_amplitude_x', 'max_amplitude_y', 'max_amplitude_z', 'moment4_px', 'moment4_py', 'moment4_pz', 'mean_py', 'sigma_py', 'cov_y__py', 'mean_px', 'sigma_px', 'cov_x__px', 'mean_pz', 'sigma_pz', 'cov_z__pz', 'moment3_px', 'moment3_py', 'moment3_pz', 'mean_kinetic_energy', 'max_amplitude_px', 'max_amplitude_py', 'max_amplitude_pz'])</pre> <p>Slice info</p> In\u00a0[13]: Copied! <pre>I.output['slice_info'].keys()\n</pre> I.output['slice_info'].keys() Out[13]: <pre>dict_keys(['final_particle_slices', 'initial_particle_slices'])</pre> In\u00a0[14]: Copied! <pre>I.output['particles']\n</pre> I.output['particles'] Out[14]: <pre>{'initial_particles': &lt;ParticleGroup with 10000 particles at 0x12d743640&gt;,\n 'final_particles': &lt;ParticleGroup with 10000 particles at 0x12d743400&gt;,\n 'YAG02': &lt;ParticleGroup with 10000 particles at 0x12d7433d0&gt;}</pre> <p><code>I.particles</code> points to this. Get the final particles and calculate some statistics:</p> In\u00a0[15]: Copied! <pre>P = I.particles['final_particles']\nP['mean_energy']\n</pre> P = I.particles['final_particles'] P['mean_energy'] Out[15]: <pre>5996955.348819707</pre> <p>Show the units:</p> In\u00a0[16]: Copied! <pre>P.units('mean_energy')\n</pre> P.units('mean_energy') Out[16]: <pre>pmd_unit('eV', 1.602176634e-19, (2, 1, -2, 0, 0, 0, 0))</pre> <p><code>ParticleGroup</code> has built-in plotting</p> In\u00a0[17]: Copied! <pre>P.plot('delta_z', 'pz')\n#plt.savefig('../assets/zpz.png', dpi=150)\n</pre> P.plot('delta_z', 'pz') #plt.savefig('../assets/zpz.png', dpi=150) In\u00a0[18]: Copied! <pre>len(I.stat('norm_emit_x')), I.stat('norm_emit_x')[-1]\n</pre>  len(I.stat('norm_emit_x')), I.stat('norm_emit_x')[-1] Out[18]: <pre>(631, 3.5584349e-08)</pre> <p>Stats can also be computed from the particles. For example:</p> In\u00a0[19]: Copied! <pre>I.particles['final_particles']['norm_emit_x']\n</pre> I.particles['final_particles']['norm_emit_x'] Out[19]: <pre>3.5580305994129105e-08</pre> <p>Compare these:</p> In\u00a0[20]: Copied! <pre>key1 = 'mean_z'\nkey2 = 'sigma_x'\nunits1 = str(I.units(key1))\nunits2 = str(I.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(I.stat(key1), I.stat(key2))\nplt.scatter(\n    [I.particles[name][key1] for name in I.particles], \n    [I.particles[name][key2] for name in I.particles], color='red')\n</pre> key1 = 'mean_z' key2 = 'sigma_x' units1 = str(I.units(key1)) units2 = str(I.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(I.stat(key1), I.stat(key2)) plt.scatter(     [I.particles[name][key1] for name in I.particles],      [I.particles[name][key2] for name in I.particles], color='red') Out[20]: <pre>&lt;matplotlib.collections.PathCollection at 0x12d4efe20&gt;</pre> <p>This kind of plot is built-in for convenience, with a layout:</p> In\u00a0[21]: Copied! <pre>I.plot('sigma_x')\n</pre> I.plot('sigma_x') <p>Even fancier options, and sending some options to matplotlib:</p> In\u00a0[22]: Copied! <pre>I.plot(['sigma_x', 'sigma_y'], y2=['mean_kinetic_energy'], ylim2=(0, 8e6), figsize=(10,5), include_field=True)\n</pre> I.plot(['sigma_x', 'sigma_y'], y2=['mean_kinetic_energy'], ylim2=(0, 8e6), figsize=(10,5), include_field=True) In\u00a0[23]: Copied! <pre>Pmid = I.particles['YAG02']\n</pre> Pmid = I.particles['YAG02'] <p>Make a copy, so that the previous object is preserved.</p> In\u00a0[24]: Copied! <pre>I2 = I.copy()\nI.verbose=False\n</pre> I2 = I.copy() I.verbose=False <p>The copy needs to be configured before tracking</p> In\u00a0[25]: Copied! <pre>I2.configure()\n</pre> I2.configure() <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpu3dlnadu\n</pre> <p>Track to 2 m</p> In\u00a0[26]: Copied! <pre>Pfinal = I2.track(Pmid, 2.0)\n</pre> Pfinal = I2.track(Pmid, 2.0) <pre>Removed element: stop_1\nSet stop to s = 2.0\nRunning Impact-T in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpu3dlnadu\nmpirun -n 4 /Users/chrisonian/Code/Impact/IMPACT-T/build-mpi/ImpactTexe-mpi\nSome initial particles z !=0, disabling cathode_start\nwriting 10000 particles to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpu3dlnadu/partcl.data\nNormal start with at time 4.668266808111253e-09 s\nNormal start: Replaced Np with 10000 according to initial particles\nNormal start: Replaced Tini with 4.668266808111253e-09 according to initial particles\nNormal start: Replaced Flagimg with 0 according to initial particles\n !-----------------------------------------------------------\n ! IMPACT-T Parallel Beam Dynamics Tracking Code: 2.1 beta version\n ! Copyright of The Regents of the University of California\n !-----------------------------------------------------------\n nblem:           28          28\n pass setting up lattice...\n check randomness:            0  0.30440529327431320     \n check randomness:            1  0.83543324059415791     \n check randomness:            2  0.66382677037082638     \n check randomness:            3  0.69219578710848950     \n avgpts, jlow, and jhigh:         2500           1        2500\n avgpts, jlow, and jhigh:         2500        2501        5000\n avgpts, jlow, and jhigh:         2500        5001        7500\n avgpts, jlow, and jhigh:         2500        7501       10000\n time:    5.1137189999999464, elapsed: 5.174751043319702Finished.5347, elapsed: 5.15160202980041557\nLoaded fort 30 : Fourth root of the fourth moments of the beam distribution\nLoaded fort 25 : RMS Y information\nLoaded fort 24 : RMS X information\nLoaded fort 26 : RMS Z information\nLoaded fort 28 : Load balance and loss diagnostics\nLoaded fort 29 : Cube root of third moments of the beam distribution\nLoaded fort 18 : Time and energy\nLoaded fort 27 : Max amplitude information\nLoaded fort 70 : Slice information of the final distribution\nLoaded fort 60 : Slice information of the initial distribution\nLoading particles\nLoaded fort 40 : initial particle distribution at t = 0\nLoaded fort 50 : final particle distribution projected to the centroid location of the bunch\nConverted initial_particles to ParticleGroup\nConverted final_particles to ParticleGroup\n</pre> <p>Compare these:</p> In\u00a0[27]: Copied! <pre>key1 = 'mean_z'\nkey2 = 'sigma_x'\nunits1 = str(I.units(key1))\nunits2 = str(I.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(I.stat(key1), I.stat(key2))\nplt.plot(I2.stat(key1), I2.stat(key2))\nplt.scatter(\n    [I.particles[name][key1] for name in I.particles], \n    [I.particles[name][key2] for name in I.particles], color='red')\n\n# Blue X are retracked particles\nplt.scatter(\n    [P[key1] for P in [Pmid, Pfinal]], \n    [P[key2] for P in [Pmid, Pfinal]], color='blue', marker='x')\n</pre>  key1 = 'mean_z' key2 = 'sigma_x' units1 = str(I.units(key1)) units2 = str(I.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(I.stat(key1), I.stat(key2)) plt.plot(I2.stat(key1), I2.stat(key2)) plt.scatter(     [I.particles[name][key1] for name in I.particles],      [I.particles[name][key2] for name in I.particles], color='red')  # Blue X are retracked particles plt.scatter(     [P[key1] for P in [Pmid, Pfinal]],      [P[key2] for P in [Pmid, Pfinal]], color='blue', marker='x') Out[27]: <pre>&lt;matplotlib.collections.PathCollection at 0x14814e070&gt;</pre> In\u00a0[28]: Copied! <pre>%%time\nI3 = I.copy()\nI3.verbose=False\nI3.configure()\nP3 = I3.track1(s=2.2, z0 = 1.0, pz0=10e6)\nP3.z, P3.gamma\n</pre> %%time I3 = I.copy() I3.verbose=False I3.configure() P3 = I3.track1(s=2.2, z0 = 1.0, pz0=10e6) P3.z, P3.gamma <pre>CPU times: user 21.4 ms, sys: 13.8 ms, total: 35.2 ms\nWall time: 154 ms\n</pre> Out[28]: <pre>(array([2.20002469]), array([1.84584053]))</pre> In\u00a0[29]: Copied! <pre>from bokeh.plotting import output_notebook\nfrom bokeh.plotting import show\noutput_notebook(hide_banner=True)\n\nfrom impact.plotting import layout_plot\n</pre> from bokeh.plotting import output_notebook from bokeh.plotting import show output_notebook(hide_banner=True)  from impact.plotting import layout_plot <p>Change something and plot:</p> In\u00a0[30]: Copied! <pre>I.ele['QE01']['b1_gradient'] = 0\nlayout = layout_plot(I.input['lattice'], height=300)\nshow(layout)\n</pre> I.ele['QE01']['b1_gradient'] = 0 layout = layout_plot(I.input['lattice'], height=300) show(layout) In\u00a0[31]: Copied! <pre>for name in ['L0A_entrance', 'L0A_body_1', 'L0A_body_2', 'L0A_exit']:\n     print(name, I[name]['theta0_deg'])\n</pre> for name in ['L0A_entrance', 'L0A_body_1', 'L0A_body_2', 'L0A_exit']:      print(name, I[name]['theta0_deg']) <pre>L0A_entrance 264.5\nL0A_body_1 294.5\nL0A_body_2 354.5\nL0A_exit 264.5\n</pre> <p>Make a copy and add a group to control these.</p> In\u00a0[32]: Copied! <pre>I4 = I.copy()\nI4.add_group('L0A', ele_names=['L0A_entrance', 'L0A_body_1', 'L0A_body_2', 'L0A_exit'], var_name='theta0_deg', attributes='theta0_deg')\n</pre> I4 = I.copy() I4.add_group('L0A', ele_names=['L0A_entrance', 'L0A_body_1', 'L0A_body_2', 'L0A_exit'], var_name='theta0_deg', attributes='theta0_deg') Out[32]: <pre>ControlGroup(**{\"ele_names\": [\"L0A_entrance\", \"L0A_body_1\", \"L0A_body_2\", \"L0A_exit\"], \"var_name\": \"theta0_deg\", \"attributes\": [\"theta0_deg\", \"theta0_deg\", \"theta0_deg\", \"theta0_deg\"], \"factors\": [1.0, 1.0, 1.0, 1.0], \"reference_values\": [264.5, 294.5, 354.5, 264.5], \"absolute\": false, \"value\": 0.0, \"name\": \"L0A\"})</pre> <p>Make a change</p> In\u00a0[33]: Copied! <pre>I4['L0A']['theta0_deg'] =0.123456\n</pre> I4['L0A']['theta0_deg'] =0.123456 <p>These get propagated to the underlying elements</p> In\u00a0[34]: Copied! <pre>for name in I4['L0A'].ele_names:\n     print(name, I4[name]['theta0_deg'])\n</pre> for name in I4['L0A'].ele_names:      print(name, I4[name]['theta0_deg']) <pre>L0A_entrance 264.623456\nL0A_body_1 294.623456\nL0A_body_2 354.623456\nL0A_exit 264.623456\n</pre> <p>Set overall scaling, respecting the special factors.</p> In\u00a0[35]: Copied! <pre>I4.add_group('L0A_scale', ele_names=['L0A_entrance', 'L0A_body_1', 'L0A_body_2', 'L0A_exit'],\n                   var_name = 'rf_field_scale',\n                  factors = [0.86571945106805, 1, 1, 0.86571945106805],  # sin(k*d) with d = 3.5e-2 m \n                  absolute=True)\n\nI4['L0A_scale']['rf_field_scale'] = 10\n</pre> I4.add_group('L0A_scale', ele_names=['L0A_entrance', 'L0A_body_1', 'L0A_body_2', 'L0A_exit'],                    var_name = 'rf_field_scale',                   factors = [0.86571945106805, 1, 1, 0.86571945106805],  # sin(k*d) with d = 3.5e-2 m                    absolute=True)  I4['L0A_scale']['rf_field_scale'] = 10 <p>These get propagated to the underlying elements</p> In\u00a0[36]: Copied! <pre>for name in I4['L0A_scale'].ele_names:\n     print(name, I4[name]['rf_field_scale'])\n</pre> for name in I4['L0A_scale'].ele_names:      print(name, I4[name]['rf_field_scale']) <pre>L0A_entrance 8.657194510680501\nL0A_body_1 10.0\nL0A_body_2 10.0\nL0A_exit 8.657194510680501\n</pre> In\u00a0[37]: Copied! <pre>?Impact\n</pre> ?Impact <pre>Init signature: Impact(*args, group=None, always_autophase=False, **kwargs)\nDocstring:     \nFiles will be written into a temporary directory within workdir.\nIf workdir=None, a location will be determined by the system.\nFile:           ~/Code/GitHub/lume-impact/impact/impact.py\nType:           ABCMeta\nSubclasses:     \n</pre> In\u00a0[38]: Copied! <pre>YAML=\"\"\"\n\n# Any argument above. One exception is initial_particles: this should be a filename that is parsed into a ParticleGroup\n\ninput_file: templates/lcls_injector/ImpactT.in\n\nverbose: True\n\ngroup:\n  L0A:\n    ele_names: [ L0A_entrance, L0A_body_1, L0A_body_2, L0A_exit ]\n    var_name: dtheta0_deg\n    attributes: theta0_deg\n    value: 0\n  L0B:\n    ele_names: [ L0B_entrance, L0B_body_1, L0B_body_2, L0B_exit ]\n    var_name: dtheta0_deg\n    attributes: theta0_deg\n    value: 0    \n  L0A_scale:\n    ele_names:  [ L0A_entrance, L0A_body_1, L0A_body_2, L0A_exit ]\n    var_name: rf_field_scale\n    factors: [0.86571945106805, 1, 1, 0.86571945106805]  # sin(k*d) with d = 3.5e-2 m \n    absolute: True \n    value: 60e6\n  L0B_scale:\n    ele_names:  [ L0B_entrance, L0B_body_1, L0B_body_2, L0B_exit ]\n    var_name: rf_field_scale\n    factors: [0.86571945106805, 1, 1, 0.86571945106805]  # sin(k*d) with d = 3.5e-2 m \n    absolute: True\n    value: 60.0e6\n\"\"\"\nI5 = Impact.from_yaml(YAML)\nI5['L0A:dtheta0_deg'], I5['L0A_entrance:theta0_deg']\n</pre> YAML=\"\"\"  # Any argument above. One exception is initial_particles: this should be a filename that is parsed into a ParticleGroup  input_file: templates/lcls_injector/ImpactT.in  verbose: True  group:   L0A:     ele_names: [ L0A_entrance, L0A_body_1, L0A_body_2, L0A_exit ]     var_name: dtheta0_deg     attributes: theta0_deg     value: 0        L0B:     ele_names: [ L0B_entrance, L0B_body_1, L0B_body_2, L0B_exit ]     var_name: dtheta0_deg     attributes: theta0_deg     value: 0            L0A_scale:     ele_names:  [ L0A_entrance, L0A_body_1, L0A_body_2, L0A_exit ]     var_name: rf_field_scale     factors: [0.86571945106805, 1, 1, 0.86571945106805]  # sin(k*d) with d = 3.5e-2 m      absolute: True      value: 60e6        L0B_scale:     ele_names:  [ L0B_entrance, L0B_body_1, L0B_body_2, L0B_exit ]     var_name: rf_field_scale     factors: [0.86571945106805, 1, 1, 0.86571945106805]  # sin(k*d) with d = 3.5e-2 m      absolute: True     value: 60.0e6       \"\"\" I5 = Impact.from_yaml(YAML) I5['L0A:dtheta0_deg'], I5['L0A_entrance:theta0_deg'] <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmptalcoik7\n</pre> Out[38]: <pre>(0.0, 264.5)</pre> In\u00a0[39]: Copied! <pre>I5['L0A'].reference_values\n</pre> I5['L0A'].reference_values Out[39]: <pre>[264.5, 294.5, 354.5, 264.5]</pre> In\u00a0[40]: Copied! <pre>I5['L0A']\n</pre> I5['L0A'] Out[40]: <pre>ControlGroup(**{\"ele_names\": [\"L0A_entrance\", \"L0A_body_1\", \"L0A_body_2\", \"L0A_exit\"], \"var_name\": \"dtheta0_deg\", \"attributes\": [\"theta0_deg\", \"theta0_deg\", \"theta0_deg\", \"theta0_deg\"], \"factors\": [1.0, 1.0, 1.0, 1.0], \"reference_values\": [264.5, 294.5, 354.5, 264.5], \"absolute\": false, \"value\": 0.0, \"name\": \"L0A\"})</pre> In\u00a0[41]: Copied! <pre>I5.autophase()\n</pre> I5.autophase() <pre>Found GUN        relative phase = 0.06 deg\nFound L0A        relative phase = -4.25 deg\n</pre> Out[41]: <pre>{'GUN': 0.0558822874006637, 'L0A': -4.245356996834516}</pre> <p>You can also give it a dict of <code>ele_name:rel_phase_deg</code> with relative phases in degrees, and it will set these as it phases:</p> In\u00a0[42]: Copied! <pre>I5.autophase({'GUN': -9, 'L0A':2})\n</pre> I5.autophase({'GUN': -9, 'L0A':2}) <pre>Setting GUN relative phase = -9 deg\nFound GUN        relative phase = -9.00 deg\nSetting L0A relative phase = 2 deg\nFound L0A        relative phase = 2.00 deg\n</pre> Out[42]: <pre>{'GUN': -9.0, 'L0A': 2.0}</pre> In\u00a0[43]: Copied! <pre>afile = I.archive()\n</pre> afile = I.archive() <p>This can be loaded into an empty model</p> In\u00a0[44]: Copied! <pre>I2 = Impact()\nI2.load_archive(afile)\n</pre> I2 = Impact() I2.load_archive(afile) <p>This also works:</p> In\u00a0[45]: Copied! <pre>I2 = Impact.from_archive(afile)\n</pre> I2 = Impact.from_archive(afile) <p>Check that the fingerprints are the same</p> In\u00a0[46]: Copied! <pre>assert I.fingerprint() == I2.fingerprint()\n</pre> assert I.fingerprint() == I2.fingerprint() <p>Look at a stat, and compare with the original object</p> In\u00a0[47]: Copied! <pre>I.stat('norm_emit_x')[-1], I2.stat('norm_emit_x')[-1]\n</pre> I.stat('norm_emit_x')[-1], I2.stat('norm_emit_x')[-1] Out[47]: <pre>(3.5584349e-08, 3.5584349e-08)</pre> <p>The particles look the same:</p> In\u00a0[48]: Copied! <pre>I2.particles['final_particles'].plot('delta_z', 'pz')\n</pre> I2.particles['final_particles'].plot('delta_z', 'pz') In\u00a0[49]: Copied! <pre>os.remove(afile)\n</pre> os.remove(afile)"},{"location":"examples/basic_impact_examples/#lume-impact-basics","title":"LUME-Impact Basics\u00b6","text":""},{"location":"examples/basic_impact_examples/#particles","title":"Particles\u00b6","text":"<p>Particles are automatically parsed in to openpmd-beamphysics ParticleGroup objects</p>"},{"location":"examples/basic_impact_examples/#stats","title":"Stats\u00b6","text":"<p>Impact's own calculated statistics can be retieved</p>"},{"location":"examples/basic_impact_examples/#partial-tracking","title":"Partial tracking\u00b6","text":"<p>Particles can be started anywhere in the lattice. Here we will take some intermediate particles, and re-track.</p> <p>Get particles at the <code>YAG02</code> marker:</p>"},{"location":"examples/basic_impact_examples/#single-particle-tracking","title":"Single particle tracking\u00b6","text":"<p>Similar to above, but with initial conditions specified in the function for a single particle.</p> <p>This is useful for auto-phasing and scaling elements, and tracing reference orbits.</p> <p>Space charge is turned off for single particle tracking.</p>"},{"location":"examples/basic_impact_examples/#interactive-layout","title":"Interactive Layout\u00b6","text":"<p>Plots can be made interctive via bokeh</p>"},{"location":"examples/basic_impact_examples/#controlgroup-objects","title":"ControlGroup objects\u00b6","text":"<p>Some elements need to be changed together, either relatively or absolutely. A single traveling wave cavity, for example, is made from four fieldmaps, with defined relative phases</p>"},{"location":"examples/basic_impact_examples/#instantiate-from-yaml","title":"Instantiate from YAML\u00b6","text":"<p>All of the Impact object init arguments can be passed in a YAML file. Any of:</p>"},{"location":"examples/basic_impact_examples/#autophase","title":"Autophase\u00b6","text":"<p>Autophase will calculate the relative phases of each rf element by tracking a single particle through the fieldmaps. This is done externally to Impact, and is relatively fast.</p> <p>A call to <code>Impact.autophase()</code> returns the relative phases found as a dict:</p>"},{"location":"examples/basic_impact_examples/#archive-all-output","title":"Archive all output\u00b6","text":"<p>All of .input and .output can be archived and loaded from standard h5 files.</p> <p>Particles are stored in the openPMD-beamphysics format.</p> <p>Call the <code>archive</code> method. If no name is given, a name will be invented based on the fingerprint.</p>"},{"location":"examples/basic_impact_examples/#cleanup","title":"Cleanup\u00b6","text":""},{"location":"examples/bmad_interface/","title":"Bmad interface","text":"In\u00a0[1]: Copied! <pre>from pytao import Tao\nfrom impact import Impact\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n</pre> from pytao import Tao from impact import Impact import matplotlib.pyplot as plt %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>LAT = \"\"\"\nno_digested\nbeginning[beta_a] = 10\nbeginning[beta_b] = 10\nbeginning[e_tot] = 10e6\nparameter[particle] = electron\nparameter[geometry] = open\n\nd1: drift, L = 1\nd2: d1\nqf: quad, L = 0.1, k1 = 1\nqd: qf, k1 = -1\n\nfodo: line = (d1, qf, d2, qd)\n\nlat: line = (2*fodo)\n\nuse, lat\n\n\"\"\"\nLATFILE = 'lat.bmad'\nwith open(LATFILE, 'w') as f:\n    f.write(LAT)\n</pre> LAT = \"\"\" no_digested beginning[beta_a] = 10 beginning[beta_b] = 10 beginning[e_tot] = 10e6 parameter[particle] = electron parameter[geometry] = open  d1: drift, L = 1 d2: d1 qf: quad, L = 0.1, k1 = 1 qd: qf, k1 = -1  fodo: line = (d1, qf, d2, qd)  lat: line = (2*fodo)  use, lat  \"\"\" LATFILE = 'lat.bmad' with open(LATFILE, 'w') as f:     f.write(LAT) In\u00a0[3]: Copied! <pre>tao = Tao(f'-lat {LATFILE} -noplot')\ntao.cmd('set particle_start x = 1e-3')\n</pre> tao = Tao(f'-lat {LATFILE} -noplot') tao.cmd('set particle_start x = 1e-3') Out[3]: <pre>[]</pre> In\u00a0[4]: Copied! <pre>I = Impact.from_tao(tao)\n\nI.track1(x0=1e-3, pz0=10e6)\n</pre> I = Impact.from_tao(tao)  I.track1(x0=1e-3, pz0=10e6) Out[4]: <pre>&lt;ParticleGroup with 1 particles at 0x28036eb20&gt;</pre> In\u00a0[5]: Copied! <pre>I.plot('mean_x', include_labels=True)\n</pre> I.plot('mean_x', include_labels=True) In\u00a0[6]: Copied! <pre>s1 = tao.lat_list('*', 'ele.s')\nx1 = tao.lat_list('*', 'orbit.vec.1')\n\nz2 = I.stat('mean_z')\nx2 = I.stat('mean_x')\n\nfix, ax = plt.subplots()\nax.plot(s1, x1*1e3, marker='.', label='Bmad')\nax.plot(z2, x2*1e3,  label='Impact-T')\nplt.legend()\nax.set_xlabel(r'$z$ (m)')\nax.set_ylabel(r'$x$ (mm)')\n</pre> s1 = tao.lat_list('*', 'ele.s') x1 = tao.lat_list('*', 'orbit.vec.1')  z2 = I.stat('mean_z') x2 = I.stat('mean_x')  fix, ax = plt.subplots() ax.plot(s1, x1*1e3, marker='.', label='Bmad') ax.plot(z2, x2*1e3,  label='Impact-T') plt.legend() ax.set_xlabel(r'$z$ (m)') ax.set_ylabel(r'$x$ (mm)') Out[6]: <pre>Text(0, 0.5, '$x$ (mm)')</pre> In\u00a0[7]: Copied! <pre>import os\nos.remove('lat.bmad')\n</pre> import os os.remove('lat.bmad')"},{"location":"examples/bmad_interface/#bmad-interface","title":"Bmad interface\u00b6","text":"<p>PyTao, based on Bmad, can be used to create an Impact-T lattice. This is a simple example of a FODO lattice in Bmad, converted to Impact-T.</p>"},{"location":"examples/bmad_interface/#bmad-lattice","title":"Bmad lattice\u00b6","text":""},{"location":"examples/bmad_interface/#impact-t-from-bmad","title":"Impact-T from Bmad\u00b6","text":""},{"location":"examples/bmad_interface/#compare","title":"Compare\u00b6","text":""},{"location":"examples/bmad_interface/#cleanup","title":"Cleanup\u00b6","text":""},{"location":"examples/distgen_example/","title":"Distgen example","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre># Nicer plotting\nimport matplotlib\nimport matplotlib.pyplot as plt\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nmatplotlib.rcParams['figure.figsize'] = (8,4)\n</pre> # Nicer plotting import matplotlib import matplotlib.pyplot as plt %matplotlib inline %config InlineBackend.figure_format = 'retina' matplotlib.rcParams['figure.figsize'] = (8,4) In\u00a0[3]: Copied! <pre>from distgen import Generator\nYAML=\"\"\"\n\nn_particle: 10000\nrandom_type: hammersley\n\nstart:\n  type: cathode\n  MTE:\n    value: 414\n    units: meV    \n\ntotal_charge:\n  value: 250\n  units: pC\nr_dist:\n  n_sigma_cutoff: 1.5\n  sigma_xy:\n    value: 0.4\n    units: mm\n  type: radial_gaussian\n\nt_dist:\n  type: superposition\n  dists: \n    d1: \n      type: gaussian\n      avg_t:\n        units: ps\n        value: -1\n      sigma_t:\n        units: ps\n        value: 1\n    d2: \n      type: gaussian\n      avg_t:\n        units: ps\n        value: 1\n      sigma_t:\n        units: ps\n        value: 1\n\"\"\"\n\nG = Generator(YAML)\n</pre> from distgen import Generator YAML=\"\"\"  n_particle: 10000 random_type: hammersley  start:   type: cathode   MTE:     value: 414     units: meV      total_charge:   value: 250   units: pC      r_dist:   n_sigma_cutoff: 1.5   sigma_xy:     value: 0.4     units: mm   type: radial_gaussian  t_dist:   type: superposition   dists:      d1:        type: gaussian       avg_t:         units: ps         value: -1       sigma_t:         units: ps         value: 1     d2:        type: gaussian       avg_t:         units: ps         value: 1       sigma_t:         units: ps         value: 1    \"\"\"  G = Generator(YAML) In\u00a0[4]: Copied! <pre># Tune the two dist separation\nG['t_dist:dists:d1:avg_t:value'] = -1\nG['t_dist:dists:d2:avg_t:value'] = 1\nG.run()\nGP = G.particles\nGP.plot('t')\nGP.plot('pz')\n</pre> # Tune the two dist separation G['t_dist:dists:d1:avg_t:value'] = -1 G['t_dist:dists:d2:avg_t:value'] = 1 G.run() GP = G.particles GP.plot('t') GP.plot('pz') In\u00a0[5]: Copied! <pre>from impact import Impact\n\nimport matplotlib.pyplot as plt\nimport os\n</pre> from impact import Impact  import matplotlib.pyplot as plt import os In\u00a0[6]: Copied! <pre>ifile = 'templates/lcls_injector/ImpactT.in'\nos.path.exists(ifile)\n</pre> ifile = 'templates/lcls_injector/ImpactT.in' os.path.exists(ifile) Out[6]: <pre>True</pre> In\u00a0[7]: Copied! <pre># Make Impact object\nI = Impact(ifile, initial_particles = G.particles, verbose=True)\n</pre> # Make Impact object I = Impact(ifile, initial_particles = G.particles, verbose=True) <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpux_1zg92\n</pre> In\u00a0[8]: Copied! <pre># This will use the initial particles\nI.write_initial_particles(update_header=True)\n</pre> # This will use the initial particles I.write_initial_particles(update_header=True) <pre>writing 10000 particles to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpux_1zg92/partcl.data\nCathode start with cathode_kinetic_energy_ref = 1.0 eV\nCathode start: Replaced Np with 10000 according to initial particles\nCathode start: Replaced Bkenergy with 1.0 according to initial particles\nCathode start: Replaced Temission with 9.145639807439135e-12 according to initial particles\nCathode start: Replaced Tini with -4.714953504413114e-12 according to initial particles\nSetting total charge to 2.4999999999999996e-10 C\n</pre> In\u00a0[9]: Copied! <pre># Change some things\nI.header['Nx'] = 16\nI.header['Ny'] = 16\nI.header['Nz'] = 16\nI.header['Dt'] = 5e-13\n\n# Turn Space Charge off\nI.header['Bcurr'] = 0 \n\n# Other switches\nI.timeout = 1000\n# Switches for MPI\nI.use_mpi=True\nI.header['Nprow'] = 1\nI.header['Npcol'] = 4\n</pre> # Change some things I.header['Nx'] = 16 I.header['Ny'] = 16 I.header['Nz'] = 16 I.header['Dt'] = 5e-13  # Turn Space Charge off I.header['Bcurr'] = 0   # Other switches I.timeout = 1000 # Switches for MPI I.use_mpi=True I.header['Nprow'] = 1 I.header['Npcol'] = 4 In\u00a0[10]: Copied! <pre># Change stop location\nI.stop = 1.5\n#I.ele['stop_1']['s'] = I.ele['OTR2']['s']+.001\n</pre> # Change stop location I.stop = 1.5 #I.ele['stop_1']['s'] = I.ele['OTR2']['s']+.001 <pre>Removed element: stop_1\nSet stop to s = 1.5\n</pre> In\u00a0[11]: Copied! <pre>I.run()\n</pre> I.run() <pre>Running Impact-T in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpux_1zg92\nmpirun -n 4 /Users/chrisonian/Code/Impact/IMPACT-T/build-mpi/ImpactTexe-mpi\nwriting 10000 particles to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpux_1zg92/partcl.data\nCathode start with cathode_kinetic_energy_ref = 1.0 eV\nCathode start: Replaced Np with 10000 according to initial particles\nCathode start: Replaced Bkenergy with 1.0 according to initial particles\nCathode start: Replaced Temission with 9.145639807439135e-12 according to initial particles\nCathode start: Replaced Tini with -4.714953504413114e-12 according to initial particles\nLoaded fort 30 : Fourth root of the fourth moments of the beam distribution\nLoaded fort 25 : RMS Y information\nLoaded fort 24 : RMS X information\nLoaded fort 26 : RMS Z information\nLoaded fort 28 : Load balance and loss diagnostics\nLoaded fort 29 : Cube root of third moments of the beam distribution\nLoaded fort 18 : Time and energy\nLoaded fort 27 : Max amplitude information\nLoaded fort 70 : Slice information of the final distribution\nLoaded fort 60 : Slice information of the initial distribution\nLoading particles\nLoaded fort 40 : initial particle distribution at t = 0\nLoaded fort 50 : final particle distribution projected to the centroid location of the bunch\nLoaded write beam particles YAG02 fort.102\nConverting z to t according to cathode_kinetic_energy_ref = 1.0 eV\nConverted initial_particles to ParticleGroup\nConverted final_particles to ParticleGroup\nConverted YAG02 to ParticleGroup\n</pre> In\u00a0[12]: Copied! <pre>I.input.keys()\n</pre> I.input.keys() Out[12]: <pre>dict_keys(['original_input', 'input_particle_file', 'header', 'lattice', 'fieldmaps'])</pre> In\u00a0[13]: Copied! <pre>I.output.keys()\n</pre> I.output.keys() Out[13]: <pre>dict_keys(['run_info', 'stats', 'slice_info', 'particles'])</pre> In\u00a0[14]: Copied! <pre>I.output['stats'].keys()\n</pre> I.output['stats'].keys() Out[14]: <pre>dict_keys(['t', 'mean_z', 'moment4_x', 'moment4_y', 'moment4_z', 'mean_y', 'sigma_y', 'norm_emit_y', 'mean_x', 'sigma_x', 'norm_emit_x', 'sigma_z', 'norm_emit_z', 'loadbalance_min_n_particle', 'loadbalance_max_n_particle', 'n_particle', 'moment3_x', 'moment3_y', 'moment3_z', 'mean_gamma', 'mean_beta', 'max_r', 'sigma_gamma', 'max_amplitude_x', 'max_amplitude_y', 'max_amplitude_z', 'moment4_px', 'moment4_py', 'moment4_pz', 'mean_py', 'sigma_py', 'cov_y__py', 'mean_px', 'sigma_px', 'cov_x__px', 'mean_pz', 'sigma_pz', 'cov_z__pz', 'moment3_px', 'moment3_py', 'moment3_pz', 'mean_kinetic_energy', 'max_amplitude_px', 'max_amplitude_py', 'max_amplitude_pz'])</pre> In\u00a0[15]: Copied! <pre>I.output['slice_info'].keys()\n</pre> I.output['slice_info'].keys() Out[15]: <pre>dict_keys(['final_particle_slices', 'initial_particle_slices'])</pre> In\u00a0[16]: Copied! <pre># Particles are automatically parsed in to openpmd-beamphysics ParticleGroup objects\nI.output['particles']\n</pre> # Particles are automatically parsed in to openpmd-beamphysics ParticleGroup objects I.output['particles'] Out[16]: <pre>{'initial_particles': &lt;ParticleGroup with 10000 particles at 0x1799c1fd0&gt;,\n 'final_particles': &lt;ParticleGroup with 10000 particles at 0x1799c1fa0&gt;,\n 'YAG02': &lt;ParticleGroup with 10000 particles at 0x1799c1ca0&gt;}</pre> In\u00a0[17]: Copied! <pre>PI = I.output['particles']['initial_particles']\nPF = I.output['particles']['final_particles']\n</pre> PI = I.output['particles']['initial_particles'] PF = I.output['particles']['final_particles'] In\u00a0[18]: Copied! <pre># Original particles\nGP.plot('t', 'pz')\n</pre> # Original particles GP.plot('t', 'pz') In\u00a0[19]: Copied! <pre># Readback of initial particles from Impact-T. \nPI.plot('t', 'pz')\n</pre> # Readback of initial particles from Impact-T.  PI.plot('t', 'pz') In\u00a0[20]: Copied! <pre># The initial time was shifted to account for this\nI.header['Tini']\n</pre> # The initial time was shifted to account for this I.header['Tini'] Out[20]: <pre>-4.714953504413114e-12</pre> In\u00a0[21]: Copied! <pre># Get the final particles, calculate some statistic\nP = I.output['particles']['final_particles']\nP['mean_energy']\n</pre> # Get the final particles, calculate some statistic P = I.output['particles']['final_particles'] P['mean_energy'] Out[21]: <pre>5996724.8303187685</pre> In\u00a0[22]: Copied! <pre># Show the units\nP.units('mean_energy')\n</pre> # Show the units P.units('mean_energy') Out[22]: <pre>pmd_unit('eV', 1.602176634e-19, (2, 1, -2, 0, 0, 0, 0))</pre> In\u00a0[23]: Copied! <pre>P.plot('z', 'pz')\n</pre> P.plot('z', 'pz') In\u00a0[24]: Copied! <pre># Impact's own calculated statistics can be retieved\nlen(I.stat('norm_emit_x')), I.stat('norm_emit_x')[-1]\n</pre> # Impact's own calculated statistics can be retieved len(I.stat('norm_emit_x')), I.stat('norm_emit_x')[-1] Out[24]: <pre>(631, 2.5687794e-07)</pre> In\u00a0[25]: Copied! <pre># Compare these. \nkey1 = 'mean_z'\nkey2 = 'sigma_x'\nunits1 = str(I.units(key1))\nunits2 = str(I.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(I.stat(key1), I.stat(key2))\nplt.scatter(\n    [I.particles[name][key1] for name in I.particles], \n    [I.particles[name][key2] for name in I.particles], color='red')\n</pre> # Compare these.  key1 = 'mean_z' key2 = 'sigma_x' units1 = str(I.units(key1)) units2 = str(I.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(I.stat(key1), I.stat(key2)) plt.scatter(     [I.particles[name][key1] for name in I.particles],      [I.particles[name][key2] for name in I.particles], color='red') Out[25]: <pre>&lt;matplotlib.collections.PathCollection at 0x17b05adf0&gt;</pre> In\u00a0[26]: Copied! <pre>afile = I.archive()\nI2 = Impact(verbose=False)\nI2.load_archive(afile)\n\n# Patch in these particles\nI2.initial_particles = I2.particles['YAG02']\n\n# Turn off cathode start\nI2.header['Flagimg'] = 0\nI2.configure()\n</pre> afile = I.archive() I2 = Impact(verbose=False) I2.load_archive(afile)  # Patch in these particles I2.initial_particles = I2.particles['YAG02']  # Turn off cathode start I2.header['Flagimg'] = 0 I2.configure()  <pre>Archiving to file impact_22c1e20e0fa82a36d47d54bb9b2b1119.h5\n</pre> In\u00a0[27]: Copied! <pre># Run again\nI2.use_mpi=True\nI2.run()\n</pre> # Run again I2.use_mpi=True I2.run() In\u00a0[28]: Copied! <pre># Compare these. \nkey1 = 'mean_z'\nkey2 = 'sigma_x'\nunits1 = str(I.units(key1))\nunits2 = str(I.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(I.stat(key1), I.stat(key2), color='black', label='original run')\nplt.plot(I2.stat(key1), I2.stat(key2), color='red', label='restart run')\nplt.scatter(\n    [I.particles[name][key1] for name in I.particles], \n    [I.particles[name][key2] for name in I.particles], color='black')\n\nplt.scatter(\n    [I2.particles[name][key1] for name in I2.particles], \n    [I2.particles[name][key2] for name in I2.particles], color='red', marker='x')\nplt.legend()\n</pre> # Compare these.  key1 = 'mean_z' key2 = 'sigma_x' units1 = str(I.units(key1)) units2 = str(I.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(I.stat(key1), I.stat(key2), color='black', label='original run') plt.plot(I2.stat(key1), I2.stat(key2), color='red', label='restart run') plt.scatter(     [I.particles[name][key1] for name in I.particles],      [I.particles[name][key2] for name in I.particles], color='black')  plt.scatter(     [I2.particles[name][key1] for name in I2.particles],      [I2.particles[name][key2] for name in I2.particles], color='red', marker='x') plt.legend() Out[28]: <pre>&lt;matplotlib.legend.Legend at 0x17b158880&gt;</pre> In\u00a0[29]: Copied! <pre># Cleanup\nos.remove(afile)\n</pre> # Cleanup os.remove(afile)"},{"location":"examples/distgen_example/#distgen-example","title":"Distgen example\u00b6","text":"<p>Similar to the simple example, but generating particles with Distgen</p>"},{"location":"examples/distgen_example/#particles","title":"Particles\u00b6","text":""},{"location":"examples/distgen_example/#stats","title":"Stats\u00b6","text":""},{"location":"examples/distgen_example/#archive-and-restart-from-the-middle","title":"Archive, and restart from the middle\u00b6","text":""},{"location":"examples/fieldmap_reconstruction/","title":"Impact-T fieldmap reconstruction","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from impact import Impact, fieldmaps\nimport numpy as np\n</pre> from impact import Impact, fieldmaps import numpy as np In\u00a0[3]: Copied! <pre>ifile = 'templates/lcls_injector/ImpactT.in'\nI = Impact(input_file=ifile)\n</pre> ifile = 'templates/lcls_injector/ImpactT.in' I = Impact(input_file=ifile) In\u00a0[4]: Copied! <pre># Fieldmaps are stored here\nI.input['fieldmaps'].keys()\n</pre> # Fieldmaps are stored here I.input['fieldmaps'].keys() Out[4]: <pre>dict_keys(['rfdata201', 'rfdata102', 'rfdata4', 'rfdata5', 'rfdata6', 'rfdata7'])</pre> In\u00a0[5]: Copied! <pre># Look at a solrf element. \nI.ele['SOL1']\n</pre> # Look at a solrf element.  I.ele['SOL1'] Out[5]: <pre>{'description': 'name:SOL1',\n 'original': '0.49308 0 0 105 0.0 0.0 0.0 0.0 102 0.15 0.0 0.0 0.0 0.0 0.0 0.2457 /!name:SOL1',\n 'L': 0.49308,\n 'type': 'solrf',\n 'zedge': 0.0,\n 'rf_field_scale': 0.0,\n 'rf_frequency': 0.0,\n 'theta0_deg': 0.0,\n 'filename': 'rfdata102',\n 'radius': 0.15,\n 'x_offset': 0.0,\n 'y_offset': 0.0,\n 'x_rotation': 0.0,\n 'y_rotation': 0.0,\n 'z_rotation': 0.0,\n 'solenoid_field_scale': 0.2457,\n 's': 0.49308,\n 'name': 'SOL1'}</pre> In\u00a0[6]: Copied! <pre># This is its fieldmap filename\nI.ele['SOL1']['filename']\n</pre> # This is its fieldmap filename I.ele['SOL1']['filename'] Out[6]: <pre>'rfdata102'</pre> In\u00a0[7]: Copied! <pre># That data is here. \nfmap = I.input['fieldmaps']['rfdata102']\nfmap\n</pre> # That data is here.  fmap = I.input['fieldmaps']['rfdata102'] fmap Out[7]: <pre>{'info': {'format': 'solrf',\n  'filePath': '/Users/chrisonian/Code/GitHub/lume-impact/docs/examples/templates/lcls_injector/rfdata102'},\n 'field': {'Ez': {'z0': 0.0,\n   'z1': 0.0,\n   'L': 0.0,\n   'fourier_coefficients': array([0.])},\n  'Bz': {'z0': -0.53308,\n   'z1': 0.49308,\n   'L': 1.02616,\n   'fourier_coefficients': array([ 7.59104159e-01,  1.86860998e-01,  2.68209187e-09, -4.75732117e-01,\n           5.68488796e-09, -2.63303014e-01, -2.00685489e-10,  8.31385362e-02,\n          -1.07061180e-09,  3.32147505e-02,  3.34109023e-09, -4.03166145e-03,\n           2.36977653e-09,  7.55695585e-02,  7.03628508e-09,  4.05472421e-02,\n          -7.93679210e-09, -2.78630279e-02, -2.80674359e-08, -1.23309101e-02,\n          -1.21750197e-08, -1.11917490e-03,  2.72183881e-08, -1.76941899e-02,\n           2.07775590e-08, -6.82928971e-03, -4.64611502e-09,  9.04327137e-03,\n          -2.74644209e-08,  3.46208848e-03,  1.22819960e-08,  4.56318358e-04,\n           2.11520498e-08,  4.27450120e-03, -2.88644504e-08,  7.52482987e-04,\n          -3.59752217e-08, -2.87393685e-03,  1.26542743e-08, -8.38592686e-04,\n           3.01815044e-08, -1.30737597e-04, -9.86177028e-09, -1.04357300e-03,\n          -6.63856936e-09, -2.53914168e-06,  2.18126093e-08,  8.16316559e-04,\n          -9.00342349e-09,  1.78532652e-04, -3.75346464e-08, -1.85656369e-05,\n           1.66112357e-08,  2.70906299e-04,  4.30436466e-08, -6.91061736e-05,\n           1.79889178e-08, -3.21395974e-04, -3.28634884e-08, -6.26834704e-05,\n           4.78721227e-08,  4.53788783e-05, -2.40687516e-08, -7.00121686e-05,\n          -1.09529996e-08,  5.88552784e-06, -3.18410200e-08,  9.16404141e-05,\n           2.20705961e-08, -1.40213052e-05,  8.62505486e-08, -7.90063994e-05,\n           1.80561930e-08,  9.73707320e-06, -3.55099131e-08, -3.24265398e-05,\n           8.04201228e-09, -2.52641442e-05,  2.39895303e-08,  7.72642702e-07,\n          -1.86279094e-08,  3.37057351e-05, -5.60221048e-08,  8.99206468e-06,\n           3.60553118e-08, -1.69794491e-05,  4.76241852e-08, -8.20592718e-06,\n          -3.75317080e-08, -1.46785073e-05, -1.35667390e-08, -8.04441471e-06,\n           9.17261718e-08, -3.13719566e-05,  5.84058221e-08, -4.49735425e-06,\n          -1.30484352e-07, -1.47358475e-05, -1.10775372e-07,  1.89208186e-05,\n           5.67838231e-08, -3.75811096e-05,  6.90257455e-08, -2.31210131e-05,\n          -2.80681931e-08,  4.15569850e-07, -3.99391984e-08,  2.35273720e-05,\n           1.13469662e-07, -2.13950099e-05,  1.17155810e-08, -2.05874941e-05,\n          -6.31687124e-08,  2.11433614e-05, -9.36452667e-08, -3.11181571e-05,\n          -6.42682642e-08, -1.59322792e-05, -1.78752181e-08])}}}</pre> In\u00a0[8]: Copied! <pre># Reconstruction function\nfieldmaps.fieldmap_reconstruction_solrf(fmap['field']['Bz'], 0)\n</pre> # Reconstruction function fieldmaps.fieldmap_reconstruction_solrf(fmap['field']['Bz'], 0) Out[8]: <pre>0.006497827018877966</pre> In\u00a0[9]: Copied! <pre>import matplotlib.pyplot as plt\n%matplotlib inline\n%config InlineBackend.figure_format='retina'\n</pre> import matplotlib.pyplot as plt %matplotlib inline %config InlineBackend.figure_format='retina' In\u00a0[10]: Copied! <pre>zlist = np.linspace(0, 0.49308, 1000)\nfieldlist = [fieldmaps.fieldmap_reconstruction_solrf(fmap['field']['Bz'], z) for z in zlist]\n</pre> zlist = np.linspace(0, 0.49308, 1000) fieldlist = [fieldmaps.fieldmap_reconstruction_solrf(fmap['field']['Bz'], z) for z in zlist] In\u00a0[11]: Copied! <pre># z at max field\nzlist[np.argmax(np.array(fieldlist))]\n</pre> # z at max field zlist[np.argmax(np.array(fieldlist))] Out[11]: <pre>0.19496156156156158</pre> In\u00a0[12]: Copied! <pre>plt.plot(zlist, fieldlist);\n</pre> plt.plot(zlist, fieldlist); In\u00a0[13]: Copied! <pre># Integrated field (approximate)\nfield_scale = 0.243 # from imput file\nBL = np.sum(fieldlist)*0.49308/1000  # T*m\nBL * field_scale * 10 # T*m -&gt; kG*m\n</pre> # Integrated field (approximate) field_scale = 0.243 # from imput file BL = np.sum(fieldlist)*0.49308/1000  # T*m BL * field_scale * 10 # T*m -&gt; kG*m Out[13]: <pre>0.47251221486003464</pre> In\u00a0[14]: Copied! <pre>1/BL\n</pre> 1/BL Out[14]: <pre>5.142724195436521</pre> In\u00a0[15]: Copied! <pre>fmap2 = fmap.copy()\nfmap2['field']['Bz']['z0'] = min(zlist)\nfmap2['field']['Bz']['z1'] = max(zlist)\nfmap2['field']['Bz']['L'] = zlist.ptp()\nfmap2['field']['Bz']['fourier_coefficients'] = fieldmaps.create_fourier_coefficients(zlist, fieldlist, n=20)\n</pre> fmap2 = fmap.copy() fmap2['field']['Bz']['z0'] = min(zlist) fmap2['field']['Bz']['z1'] = max(zlist) fmap2['field']['Bz']['L'] = zlist.ptp() fmap2['field']['Bz']['fourier_coefficients'] = fieldmaps.create_fourier_coefficients(zlist, fieldlist, n=20) In\u00a0[16]: Copied! <pre>fieldlist2 = [fieldmaps.fieldmap_reconstruction_solrf(fmap2['field']['Bz'], z) for z in zlist]\nplt.plot(zlist, fieldlist, label='original')\nplt.plot(zlist, fieldlist2, '--', label='created')\nplt.legend()\n</pre> fieldlist2 = [fieldmaps.fieldmap_reconstruction_solrf(fmap2['field']['Bz'], z) for z in zlist] plt.plot(zlist, fieldlist, label='original') plt.plot(zlist, fieldlist2, '--', label='created') plt.legend() Out[16]: <pre>&lt;matplotlib.legend.Legend at 0x12f1783a0&gt;</pre> In\u00a0[17]: Copied! <pre>fmap2\n</pre> fmap2 Out[17]: <pre>{'info': {'format': 'solrf',\n  'filePath': '/Users/chrisonian/Code/GitHub/lume-impact/docs/examples/templates/lcls_injector/rfdata102'},\n 'field': {'Ez': {'z0': 0.0,\n   'z1': 0.0,\n   'L': 0.0,\n   'fourier_coefficients': array([0.])},\n  'Bz': {'z0': 0.0,\n   'z1': 0.49308,\n   'L': 0.49308,\n   'fourier_coefficients': array([ 7.89495139e-01,  4.33867017e-01, -3.57732944e-01,  2.94026907e-02,\n          -1.53404612e-01,  3.25260823e-02,  5.58082653e-02,  6.13403407e-02,\n           2.39379983e-02,  3.57981962e-03, -1.24552364e-03, -1.02459657e-02,\n           1.68094954e-02,  1.23265799e-03,  7.41061917e-03, -2.88377447e-03,\n          -2.34475616e-03, -3.69833230e-03, -3.94627426e-04, -5.82441696e-05,\n           1.26215240e-04,  3.02765112e-04, -1.36723089e-03, -2.26429980e-04,\n          -2.39596500e-04,  3.45355578e-04, -4.64071534e-05,  2.62624018e-04,\n           2.21612127e-05,  6.48490182e-05, -1.18646462e-04,  1.19955063e-05,\n           2.07495250e-04,  6.46051459e-05, -2.35246836e-05, -3.25265093e-05,\n           1.09808260e-04, -1.75593316e-05, -9.23404592e-05])}}}</pre> In\u00a0[18]: Copied! <pre>from numpy import sin, cos, pi, arange\n</pre> from numpy import sin, cos, pi, arange In\u00a0[19]: Copied! <pre># Raw data from \ncoefs = fmap2['field']['Bz']['fourier_coefficients']\ncoefs\n</pre> # Raw data from  coefs = fmap2['field']['Bz']['fourier_coefficients'] coefs Out[19]: <pre>array([ 7.89495139e-01,  4.33867017e-01, -3.57732944e-01,  2.94026907e-02,\n       -1.53404612e-01,  3.25260823e-02,  5.58082653e-02,  6.13403407e-02,\n        2.39379983e-02,  3.57981962e-03, -1.24552364e-03, -1.02459657e-02,\n        1.68094954e-02,  1.23265799e-03,  7.41061917e-03, -2.88377447e-03,\n       -2.34475616e-03, -3.69833230e-03, -3.94627426e-04, -5.82441696e-05,\n        1.26215240e-04,  3.02765112e-04, -1.36723089e-03, -2.26429980e-04,\n       -2.39596500e-04,  3.45355578e-04, -4.64071534e-05,  2.62624018e-04,\n        2.21612127e-05,  6.48490182e-05, -1.18646462e-04,  1.19955063e-05,\n        2.07495250e-04,  6.46051459e-05, -2.35246836e-05, -3.25265093e-05,\n        1.09808260e-04, -1.75593316e-05, -9.23404592e-05])</pre> In\u00a0[20]: Copied! <pre>A0 = coefs[0]    # constant factor\nA  = coefs[1::2] # cos parts\nB  = coefs[2::2] # sin parts\n</pre> A0 = coefs[0]    # constant factor A  = coefs[1::2] # cos parts B  = coefs[2::2] # sin parts  In\u00a0[21]: Copied! <pre>L = 0.6\n\n@np.vectorize\ndef f(z):\n    phase = 2*pi*(z/L-1/2)\n    return A0/2 + sum([ A[n-1] * cos(n*phase)  + B[n-1] * sin(n*phase) for n in arange(1, len(A)+1)])\n\n\nz0 = np.linspace(0, L, 100)\n\nplt.plot(z0, f(z0))\n</pre> L = 0.6  @np.vectorize def f(z):     phase = 2*pi*(z/L-1/2)     return A0/2 + sum([ A[n-1] * cos(n*phase)  + B[n-1] * sin(n*phase) for n in arange(1, len(A)+1)])   z0 = np.linspace(0, L, 100)  plt.plot(z0, f(z0)) Out[21]: <pre>[&lt;matplotlib.lines.Line2D at 0x12f201e50&gt;]</pre>"},{"location":"examples/fieldmap_reconstruction/#impact-t-fieldmap-reconstruction","title":"Impact-T fieldmap reconstruction\u00b6","text":""},{"location":"examples/fieldmap_reconstruction/#basic-plot","title":"Basic plot\u00b6","text":""},{"location":"examples/fieldmap_reconstruction/#create-fieldmap","title":"Create Fieldmap\u00b6","text":""},{"location":"examples/functional_impact_run/","title":"Functional example for LUME-Impact","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre># Nicer plotting\nimport matplotlib.pyplot as plt\nimport matplotlib\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nmatplotlib.rcParams['figure.figsize'] = (8,4)\n</pre> # Nicer plotting import matplotlib.pyplot as plt import matplotlib %matplotlib inline %config InlineBackend.figure_format = 'retina' matplotlib.rcParams['figure.figsize'] = (8,4) In\u00a0[3]: Copied! <pre>from impact import Impact, run_impact_with_distgen, evaluate_impact_with_distgen\n\nimport os\n</pre> from impact import Impact, run_impact_with_distgen, evaluate_impact_with_distgen  import os In\u00a0[4]: Copied! <pre>gfile = 'templates/lcls_injector/distgen.yaml'\nifile = 'templates/lcls_injector/ImpactT.yaml'\n</pre> gfile = 'templates/lcls_injector/distgen.yaml' ifile = 'templates/lcls_injector/ImpactT.yaml' In\u00a0[5]: Copied! <pre># Make some settings\nSETTINGS0 = {\n    'distgen:n_particle':100,\n    'total_charge':0,  # effectively turns spacecharge off\n    'stop':0.02, \n    'total_charge': 0,\n    'GUN_phase:autophase_deg':0}\n\n\n# This returns an Impact object that has run\nI = run_impact_with_distgen(\n    settings=SETTINGS0,\n    distgen_input_file=gfile,\n    impact_config=ifile,\n    verbose=True\n)\n\nI.plot('mean_kinetic_energy')\nI\n</pre> # Make some settings SETTINGS0 = {     'distgen:n_particle':100,     'total_charge':0,  # effectively turns spacecharge off     'stop':0.02,      'total_charge': 0,     'GUN_phase:autophase_deg':0}   # This returns an Impact object that has run I = run_impact_with_distgen(     settings=SETTINGS0,     distgen_input_file=gfile,     impact_config=ifile,     verbose=True )  I.plot('mean_kinetic_energy') I <pre>Setting distgen n_particle = 100\nSetting impact total_charge = 0\nSetting impact stop = 0.02\nRemoved element: stop_1\nSet stop to s = 0.02\nSetting impact GUN_phase:autophase_deg = 0\nDistribution format: None\n   Warning: no output file specified, defaulting to \"None\".\nOutput file: None\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 250 pC.\n   Number of macroparticles: 100.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: Tukey\n      length = 6.6 ps, ratio = 0.8\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 459.950 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 459.950 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 459.950 eV/c\n   Shifting avg_x = -0.0017829 mm -&gt; 0 mm\n   Scaling sigma_x = 0.250234 mm -&gt; 0.250725 mm\n   Shifting avg_y = -0.000295389 mm -&gt; 0 mm\n   Scaling sigma_y = 0.250364 mm -&gt; 0.250725 mm\n   Shifting avg_px = -9.55833 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 444.351 eV/c -&gt; 459.95 eV/c\n   Shifting avg_py = -11.492 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 456.462 eV/c -&gt; 459.95 eV/c\n   Shifting avg_pz = -9.32951 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 438.206 eV/c -&gt; 459.95 eV/c\n   Shifting avg_t = -0.0423517 ps -&gt; -5.55112E-17 ps\n   Scaling sigma_t = 1.27888 ps -&gt; 1.2794 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 375.633 eV/c, sigma_pz -&gt; 265.431 eV/c\n...done. Time Ellapsed: 35.542 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 100 particles with total charge 2.5e-10 CAutophase bookkeeper found settings, applying them\nSetting GUN_phase relative phase = 0 deg\nFound GUN_phase  relative phase = 0.00 deg\nRunning Impact-T in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpouuyon7b\n/Users/chrisonian/Code/Impact/IMPACT-T/build/ImpactTexe\nwriting 100 particles to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpouuyon7b/partcl.data\nCathode start with cathode_kinetic_energy_ref = 1.0 eV\nCathode start: Replaced Np with 100 according to initial particles\nCathode start: Replaced Bkenergy with 1.0 according to initial particles\nCathode start: Replaced Temission with 5.326350576132463e-12 according to initial particles\nCathode start: Replaced Tini with -2.738554468039765e-12 according to initial particles\n !-----------------------------------------------------------\n ! IMPACT-T Parallel Beam Dynamics Tracking Code: 2.1 beta version\n ! Copyright of The Regents of the University of California\n !-----------------------------------------------------------\n nblem:           28          28\n pass setting up lattice...\n check randomness:            0  0.30440529327431320     \n avgpts, jlow, and jhigh:          100           1         100\n sumx1,sumy1:    4.3368086899420178E-021   4.5807541787512561E-020\n pass generating initial distribution...\n tstop:    2.0000000000000000E-002\n i,t,&lt;z&gt;:            1  -2.7385544680397651E-012   0.0000000000000000     \n zmin,zmax:    0.0000000000000000       -9.9526371302380290E-021\n i,t,&lt;z&gt;:            2  -2.7252385915994338E-012  -1.6242259416903984E-006\n time:    0.0000000000000000, elapsed: 0.1053769588470459Finished.774E-002, elapsed: 0.104771137237548834\nLoaded fort 30 : Fourth root of the fourth moments of the beam distribution\nLoaded fort 25 : RMS Y information\nLoaded fort 24 : RMS X information\nLoaded fort 26 : RMS Z information\nLoaded fort 28 : Load balance and loss diagnostics\nLoaded fort 29 : Cube root of third moments of the beam distribution\nLoaded fort 18 : Time and energy\nLoaded fort 27 : Max amplitude information\nLoaded fort 70 : Slice information of the final distribution\nLoaded fort 60 : Slice information of the initial distribution\nLoading particles\nLoaded fort 40 : initial particle distribution at t = 0\nLoaded fort 50 : final particle distribution projected to the centroid location of the bunch\nConverting z to t according to cathode_kinetic_energy_ref = 1.0 eV\nConverted initial_particles to ParticleGroup\nConverted final_particles to ParticleGroup\n</pre> Out[5]: <pre>&lt;Impact with 100 particles, stopping at 0.02 m, at 0x108f50160&gt;</pre> In\u00a0[6]: Copied! <pre>h5 = I.archive()\n</pre> h5 = I.archive() <pre>Archiving to file impact_c8cf7ef9b0bbe125de0b5d63850eccdd.h5\n</pre> In\u00a0[7]: Copied! <pre>import h5py\nh5 = h5py.File('impact_c8cf7ef9b0bbe125de0b5d63850eccdd.h5', 'r')\nlist(h5)\n</pre> import h5py h5 = h5py.File('impact_c8cf7ef9b0bbe125de0b5d63850eccdd.h5', 'r') list(h5) Out[7]: <pre>['control_groups', 'initial_particles', 'input', 'output']</pre> In\u00a0[8]: Copied! <pre>I.from_archive('impact_c8cf7ef9b0bbe125de0b5d63850eccdd.h5')\nI.output.keys()\n</pre> I.from_archive('impact_c8cf7ef9b0bbe125de0b5d63850eccdd.h5') I.output.keys() Out[8]: <pre>dict_keys(['autophase_info', 'run_info', 'stats', 'slice_info', 'particles'])</pre> In\u00a0[9]: Copied! <pre>I['total_charge'] = 1\nI.write_input()\n!cat {I.path}/ImpactT.in\n</pre> I['total_charge'] = 1 I.write_input() !cat {I.path}/ImpactT.in <pre>writing 100 particles to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpouuyon7b/partcl.data\nCathode start with cathode_kinetic_energy_ref = 1.0 eV\nCathode start: Replaced Np with 100 according to initial particles\nCathode start: Replaced Bkenergy with 1.0 according to initial particles\nCathode start: Replaced Temission with 5.326350576132463e-12 according to initial particles\nCathode start: Replaced Tini with -2.738554468039765e-12 according to initial particles\nSetting total charge to 0.9999999999999999 C\n! Impact-T input file\n!Npcol Nprow\n1 1\n!Dt Ntstep Nbunch\n5e-13 1000000 1\n!Dim Np Flagmap Flagerr Flagdiag Flagimg Zimage\n6 100 1 0 2 1 0.02\n!Nx Ny Nz Flagbc Xrad Yrad Perdlen\n32 32 32 1 0.015 0.015 45.0\n!Flagdist Rstartflg Flagsbstp Nemission Temission\n16 0 0 400 5.326350576132463e-12\n!sigx(m) sigpx muxpx xscale pxscale xmu1(m) xmu2\n0.0006 0.0 0.0 1.0 1.0 0.0 0.0\n!sigy(m) sigpy muxpy yscale pyscale ymu1(m) ymu2\n0.0006 0.0 0.0 1.0 1.0 0.0 0.0\n!sigz(m) sigpz muxpz zscale pzscale zmu1(m) zmu2\n1.27e-06 0.0 0.0 1.0 1.0 0.0 0.0\n!Bcurr Bkenergy Bmass Bcharge Bfreq Tini\n2855999999.9999995 1.0 511005.0 -1.0 2856000000.0 -2.738554468039765e-12\n!=================== LATTICE ===================\n0 0 0 -4 0.0 0.0 0.25 4e-12 /!name:change_timestep_1\n0 0 0 -5 0.0 0.0 -1000.0 /!name:SC_2D_to_3D\n\n!__________________ 1.5 cell gun __________________\n! Single particle phased and scaled for 6 MeV energy\n0.15 0 0 105 0.0 47537665.059089914 2856000000.0 303.90096127537015 201 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:GUN\n\n!__________________Solenoid and correctors__________________\n0.49308 0 0 105 0.0 0.0 0.0 0.0 102 0.15 0.0 0.0 0.0 0.0 0.0 0.2457 /!name:SOL1\n! Corrector quads: skew and regular. \n! Overlap SOL1. Effective length, radius estimated from measurements. \n! Max field should be 0.00714 T/m\n0.36 0 0 1 0.01601 0.0 0.21 0.0254 0.0 0.0 0.0 0.0 0.7853981633974483 /!name:SQ01\n0.36 0 0 1 0.01601 0.0 0.21 0.0254 0.0 0.0 0.0 0.0 0.0 /!name:CQ01\n!________________________________________________________________________\n\n!!! Broken: 0 1 101 -2 0.0 0.0 0.61362 /!name:YAG01\n0 1 102 -2 0.0 0.0 1.38841 /!name:YAG02\n\n!__________________ L0A begin __________________\n0 -1 0 -6 1 1 1.485 4.527856 0.0116 0.0292 0.035 /!name:wakefield_L0A\n! Phased to get to 64 MeV\n0.052464 0 0 105 1.485 26013439.060000002 2856000000.0 264.5 4 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0A_entrance\n2.937928 0 0 105 1.537464 30048347.1 2856000000.0 294.5 5 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0A_body_1\n2.937928 0 0 105 1.537464 30048347.1 2856000000.0 354.5 6 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0A_body_2\n0.052464 0 0 105 4.475392 26013439.060000002 2856000000.0 264.5 7 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0A_exit\n!__________________ L0A exit __________________\n! Space charge switches\n!!!0 0 0 -8 0 1 4.527856 / name:SC_ON\n!!!0 0 0 -8 0 -1 4.527856 / name:SC_OFF\n!!!0 0 0 -5 0.0 0.0 4.527856 /!name:SC_2D_to_3D\n\n0 1 103 -2 0.0 0.0 4.614538605 /!name:YAG03\n0.204 0 0 1 4.752933605 1.8524000101358 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QA01\n0.204 0 0 1 5.081309605 -1.8524000101358 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QA02\n\n!__________________ L0B begin __________________\n0 -1 0 -6 1 1 5.328756 8.371612 0.0116 0.0292 0.035 /!name:wakefield_L0B\n! Phased to get to 135 MeV\n0.052464 0 0 105 5.328756 31395529.900000002 2856000000.0 42.27 4 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0B_entrance\n2.937928 0 0 105 5.38122 36265246.5 2856000000.0 72.27 5 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0B_body_1\n2.937928 0 0 105 5.38122 36265246.5 2856000000.0 132.27 6 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0B_body_2\n0.052464 0 0 105 8.319148 31395529.900000002 2856000000.0 42.27 7 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0B_exit\n!__________________ L0B exit __________________\n\n0.204 0 0 1 8.392048605 0.18720000156206 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QE01\n0.204 0 0 1 8.793561605 0.16609999999321 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QE02\n\n!!! Unmodeled: Laser Heater from 9.076892 m to 10.690580 m\n\n0.204 0 0 1 11.469244190867 -2.6409000012747 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QE03\n0.204 0 0 1 11.875644190867 2.9799999853198 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QE04\n\n!!! 0 1 104 -2 0.0 0.0 12.175332190867 /!name:WS01\n0 1 105 -2 0.0 0.0 12.327300190867 /!name:OTR1\n!!! 0 1 106 -2 0.0 0.0 14.089061190867 /!name:WS02\n0 1 107 -2 0.0 0.0 14.241029190867 /!name:OTR2\n!!! 0 1 108 -2 0.0 0.0 16.002790190867 /!name:WS03\n!!! 0 1 109 -2 0.0 0.0 16.154758190867 /!name:OTR3\n\n0 0 0 -8 0.0 -1 16.5 /!name:SC_OFF\n0 0 0 -99 0.02 0.0 0.02 /!name:stop_1\n</pre> In\u00a0[10]: Copied! <pre># This returns an Impact object that has run\nO1 = evaluate_impact_with_distgen(\n    SETTINGS0,\n    distgen_input_file=gfile,\n    impact_config=ifile,\n    archive_path = '.'\n)\n\n# This is the default output\nO1\n</pre>  # This returns an Impact object that has run O1 = evaluate_impact_with_distgen(     SETTINGS0,     distgen_input_file=gfile,     impact_config=ifile,     archive_path = '.' )  # This is the default output O1 <pre>Setting GUN_phase relative phase = 0 deg\n</pre> Out[10]: <pre>{'error': False,\n 'end_t': 8.2587796e-11,\n 'end_mean_z': 0.019394996,\n 'end_moment4_x': 0.00027210158,\n 'end_moment4_y': 0.00027072853,\n 'end_moment4_z': 0.00035338747,\n 'end_mean_y': -1.0694885e-08,\n 'end_sigma_y': 0.00022232416,\n 'end_norm_emit_y': 2.2707187e-07,\n 'end_mean_x': -7.3036542e-08,\n 'end_sigma_x': 0.00022254175,\n 'end_norm_emit_x': 2.2733475e-07,\n 'end_sigma_z': 0.00028894632,\n 'end_norm_emit_z': 2.5412705e-07,\n 'end_loadbalance_min_n_particle': 100.0,\n 'end_loadbalance_max_n_particle': 100.0,\n 'end_n_particle': 100.0,\n 'end_moment3_x': 3.4437469e-05,\n 'end_moment3_y': 4.4364276e-05,\n 'end_moment3_z': 0.00032441007,\n 'end_mean_gamma': 4.7245665,\n 'end_mean_beta': 0.97734344,\n 'end_max_r': 0.00048150187,\n 'end_sigma_gamma': 0.030050216,\n 'end_max_amplitude_x': 0.0004700399,\n 'end_max_amplitude_y': 0.00045379459,\n 'end_max_amplitude_z': 0.00070089752,\n 'end_moment4_px': 2098.43067854728,\n 'end_moment4_py': 2068.6236498947246,\n 'end_moment4_pz': 19286.59606692665,\n 'end_mean_py': -0.25666360214795303,\n 'end_sigma_py': 1681.02312803579,\n 'end_cov_y__py': 0.35526310816581197,\n 'end_mean_px': -2.091672002035,\n 'end_sigma_px': 1692.592093163895,\n 'end_cov_x__px': 0.35831151328195293,\n 'end_mean_pz': 2359546.3897070447,\n 'end_sigma_pz': 15712.023507953849,\n 'end_cov_z__pz': 4.538073751971759,\n 'end_moment3_px': 277.82314886934296,\n 'end_moment3_py': 283.2407341872955,\n 'end_moment3_pz': 8212.0443959015,\n 'end_mean_kinetic_energy': 1903272.0999999999,\n 'end_max_amplitude_px': 3952.8144416618547,\n 'end_max_amplitude_py': 3566.0464903921547,\n 'end_max_amplitude_pz': 2390819.2699475694,\n 'run_time': 0.07423567771911621,\n 'end_n_particle_loss': 0,\n 'end_total_charge': 0.9999999999999999,\n 'end_higher_order_energy_spread': 61.72667636166407,\n 'end_norm_emit_xy': 2.2720327198014227e-07,\n 'end_norm_emit_4d': 5.1942670991616014e-14,\n 'fingerprint': '6f259cc13a90b129c8c59e01665a8026',\n 'archive': '/Users/chrisonian/Code/GitHub/lume-impact/docs/examples/6f259cc13a90b129c8c59e01665a8026.h5'}</pre> In\u00a0[11]: Copied! <pre>I2 = Impact.from_archive(O1['archive'])\n</pre> I2 = Impact.from_archive(O1['archive']) In\u00a0[12]: Copied! <pre>I2.fingerprint() == I.fingerprint()\n</pre> I2.fingerprint() == I.fingerprint() Out[12]: <pre>False</pre> <p>A custom merit function can be provided to give different output. Note that the fingerprint is always returned.</p> In\u00a0[13]: Copied! <pre># Custom merit function\ndef my_merit(impact_object):\n\"\"\"\n    Custom merit function.\n    Returns the maximum sigma_x seen\n    \"\"\"\n    d = {'max_sigma_x': I.stat('sigma_x').max()}\n    \n    return d\n\n\nevaluate_impact_with_distgen(\n    SETTINGS0,\n    distgen_input_file=gfile,\n    impact_config=ifile,\n    merit_f = my_merit\n)\n</pre> # Custom merit function def my_merit(impact_object):     \"\"\"     Custom merit function.          Returns the maximum sigma_x seen          \"\"\"     d = {'max_sigma_x': I.stat('sigma_x').max()}          return d   evaluate_impact_with_distgen(     SETTINGS0,     distgen_input_file=gfile,     impact_config=ifile,     merit_f = my_merit ) <pre>Setting GUN_phase relative phase = 0 deg\n</pre> Out[13]: <pre>{'max_sigma_x': 0.00025965193,\n 'fingerprint': '6f259cc13a90b129c8c59e01665a8026'}</pre> In\u00a0[14]: Copied! <pre># Cleanup\nos.remove(O1['archive'])\n</pre> # Cleanup os.remove(O1['archive'])"},{"location":"examples/functional_impact_run/#functional-example-for-lume-impact","title":"Functional example for LUME-Impact\u00b6","text":""},{"location":"examples/functional_impact_run/#functional-run_impact_with_distgen","title":"Functional run_impact_with_distgen\u00b6","text":"<p>This is a functional way to apply some settings to and run distgen and impact together.</p> <p>Any key with a prefix <code>distgen:</code> will send its suffix to distgen's Generator.</p> <p>Otherwise, any key that can be set with Impact's attr syntax can be used.</p>"},{"location":"examples/functional_impact_run/#functional-evaluate_impact_with_distgen","title":"Functional evaluate_impact_with_distgen\u00b6","text":"<p>Similar to above, but reuruns a dict of common outputs, and an optinal archive file.</p> <p>This is useful in optimizations and creating datasets.</p>"},{"location":"examples/input_parsing_example/","title":"Parsing ImpactT.in","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from impact.parsers import *\n</pre> from impact.parsers import * In\u00a0[3]: Copied! <pre>from impact.lattice import *\n</pre> from impact.lattice import * In\u00a0[4]: Copied! <pre>with open('templates/lcls_injector/ImpactT.in', 'r') as f:    \n    data = f.read()\n    LINES = data.split('\\n')\n</pre> with open('templates/lcls_injector/ImpactT.in', 'r') as f:         data = f.read()     LINES = data.split('\\n') In\u00a0[5]: Copied! <pre>parse_header(LINES)\n</pre> parse_header(LINES) Out[5]: <pre>{'Npcol': 2,\n 'Nprow': 2,\n 'Dt': 5e-13,\n 'Ntstep': 1000000,\n 'Nbunch': 1,\n 'Dim': 6,\n 'Np': 10000,\n 'Flagmap': 1,\n 'Flagerr': 0,\n 'Flagdiag': 2,\n 'Flagimg': 1,\n 'Zimage': 0.02,\n 'Nx': 32,\n 'Ny': 32,\n 'Nz': 32,\n 'Flagbc': 1,\n 'Xrad': 0.015,\n 'Yrad': 0.015,\n 'Perdlen': 45.0,\n 'Flagdist': 16,\n 'Rstartflg': 0,\n 'Flagsbstp': 0,\n 'Nemission': 400,\n 'Temission': 6.515803466731775e-12,\n 'sigx(m)': 0.0006,\n 'sigpx': 0.0,\n 'muxpx': 0.0,\n 'xscale': 1.0,\n 'pxscale': 1.0,\n 'xmu1(m)': 0.0,\n 'xmu2': 0.0,\n 'sigy(m)': 0.0006,\n 'sigpy': 0.0,\n 'muxpy': 0.0,\n 'yscale': 1.0,\n 'pyscale': 1.0,\n 'ymu1(m)': 0.0,\n 'ymu2': 0.0,\n 'sigz(m)': 1.27e-06,\n 'sigpz': 0.0,\n 'muxpz': 0.0,\n 'zscale': 1.0,\n 'pzscale': 1.0,\n 'zmu1(m)': 0.0,\n 'zmu2': 0.0,\n 'Bcurr': 0.7140000000000003,\n 'Bkenergy': 1.0,\n 'Bmass': 511005.0,\n 'Bcharge': -1.0,\n 'Bfreq': 2856000000.0,\n 'Tini': -3.249141278122655e-12}</pre> In\u00a0[6]: Copied! <pre># Find index of the line where the lattice starts\nIX_LATTICE = ix_lattice(LINES)\n\n# Gather lattice lines\nLATLINES = LINES[IX_LATTICE:]\n</pre> # Find index of the line where the lattice starts IX_LATTICE = ix_lattice(LINES)  # Gather lattice lines LATLINES = LINES[IX_LATTICE:] In\u00a0[7]: Copied! <pre># Summary of elements in this lattice\ndef myf(t): return [l for l in LATLINES if parse_type(l) == t ] \nquads = myf('quadrupole')\n#drifts = myf('drift')\nsolrfs = myf('solrf')\nwakefields = myf('wakefield')\n\nalltypes = set([parse_type(l) for l in LATLINES])\nprint(alltypes)\n\nfor t in ele_type.values():\n    l = len(myf(t))\n    if l &gt; 0:\n        print(l, t)\n</pre> # Summary of elements in this lattice def myf(t): return [l for l in LATLINES if parse_type(l) == t ]  quads = myf('quadrupole') #drifts = myf('drift') solrfs = myf('solrf') wakefields = myf('wakefield')  alltypes = set([parse_type(l) for l in LATLINES]) print(alltypes)  for t in ele_type.values():     l = len(myf(t))     if l &gt; 0:         print(l, t) <pre>{'quadrupole', 'change_timestep', 'rotationally_symmetric_to_3d', 'wakefield', 'stop', 'write_beam', 'solrf', 'comment', 'spacecharge'}\n8 quadrupole\n10 solrf\n4 write_beam\n1 change_timestep\n1 rotationally_symmetric_to_3d\n2 wakefield\n1 spacecharge\n1 stop\n</pre> In\u00a0[8]: Copied! <pre>parse_quadrupole(quads[0])\n</pre> parse_quadrupole(quads[0]) Out[8]: <pre>{'zedge': 0.01601,\n 'b1_gradient': 0.0,\n 'L_effective': 0.21,\n 'radius': 0.0254,\n 'x_offset': 0.0,\n 'y_offset': 0.0,\n 'x_rotation': 0.0,\n 'y_rotation': 0.0,\n 'z_rotation': 0.7853981633974483}</pre> In\u00a0[9]: Copied! <pre>parse_solrf(solrfs[0])\n</pre> parse_solrf(solrfs[0]) Out[9]: <pre>{'zedge': 0.0,\n 'rf_field_scale': 47537665.059089914,\n 'rf_frequency': 2856000000.0,\n 'theta0_deg': 303.93723122804266,\n 'filename': 'rfdata201',\n 'radius': 0.15,\n 'x_offset': 0.0,\n 'y_offset': 0.0,\n 'x_rotation': 0.0,\n 'y_rotation': 0.0,\n 'z_rotation': 0.0,\n 'solenoid_field_scale': 0.0}</pre> In\u00a0[10]: Copied! <pre>parse_wakefield(wakefields[0])\n</pre> parse_wakefield(wakefields[0]) Out[10]: <pre>{'s_begin': 1.485,\n 's': 4.527856,\n 'method': 'analytical',\n 'iris_radius': 0.0116,\n 'gap': 0.0292,\n 'period': 0.035}</pre> In\u00a0[11]: Copied! <pre>from impact.lattice import ele_str\n</pre> from impact.lattice import ele_str In\u00a0[12]: Copied! <pre># This parses all lines. \neles = parse_lattice(LATLINES)\n</pre> # This parses all lines.  eles = parse_lattice(LATLINES) In\u00a0[13]: Copied! <pre># MAD-style printing\nfor e in eles:\n    s = ele_str(e)\n    print(s)\n</pre> # MAD-style printing for e in eles:     s = ele_str(e)     print(s) <pre>change_timestep_1: change_timestep, description=name:change_timestep_1, dt=4e-12,\n      s=0.25\nSC_2D_to_3D: rotationally_symmetric_to_3d, description=name:SC_2D_to_3D, s=-1000.0\n\n!__________________ 1.5 cell gun __________________\n! Single particle phased and scaled for 6 MeV energy\nGUN: solrf, description=name:GUN, L=0.15, zedge=0.0, rf_field_scale=47537665.059089914,\n      rf_frequency=2856000000.0, theta0_deg=303.93723122804266, filename=rfdata201,\n      radius=0.15, x_offset=0.0, y_offset=0.0, x_rotation=0.0, y_rotation=0.0,\n      z_rotation=0.0, solenoid_field_scale=0.0, s=0.15\n\n!__________________Solenoid and correctors__________________\nSOL1: solrf, description=name:SOL1, L=0.49308, zedge=0.0, rf_field_scale=0.0,\n      rf_frequency=0.0, theta0_deg=0.0, filename=rfdata102, radius=0.15, x_offset=0.0,\n      y_offset=0.0, x_rotation=0.0, y_rotation=0.0, z_rotation=0.0,\n      solenoid_field_scale=0.2457, s=0.49308\n! Corrector quads: skew and regular. \n! Overlap SOL1. Effective length, radius estimated from measurements. \n! Max field should be 0.00714 T/m\nSQ01: quadrupole, description=name:SQ01, L=0.36, zedge=0.01601, b1_gradient=0.0,\n      L_effective=0.21, radius=0.0254, x_offset=0.0, y_offset=0.0, x_rotation=0.0,\n      y_rotation=0.0, z_rotation=0.7853981633974483, s=0.37601\nCQ01: quadrupole, description=name:CQ01, L=0.36, zedge=0.01601, b1_gradient=0.0,\n      L_effective=0.21, radius=0.0254, x_offset=0.0, y_offset=0.0, x_rotation=0.0,\n      y_rotation=0.0, z_rotation=0.0, s=0.37601\n!________________________________________________________________________\n\n!!! Broken: 0 1 101 -2 0.0 0.0 0.61362 /!name:YAG01\nYAG02: write_beam, description=name:YAG02, filename=fort.102, sample_frequency=1,\n      s=1.38841\n\n!__________________ L0A begin __________________\nwakefield_L0A: wakefield, description=name:wakefield_L0A, s_begin=1.485, s=4.527856,\n      method=analytical, iris_radius=0.0116, gap=0.0292, period=0.035\n! Phased to get to 64 MeV\nL0A_entrance: solrf, description=name:L0A_entrance, L=0.052464, zedge=1.485,\n      rf_field_scale=26013439.060000002, rf_frequency=2856000000.0,\n      theta0_deg=264.5, filename=rfdata4, radius=0.15, x_offset=0.0, y_offset=0.0,\n      x_rotation=0.0, y_rotation=0.0, z_rotation=0.0, solenoid_field_scale=0.0,\n      s=1.5374640000000002\nL0A_body_1: solrf, description=name:L0A_body_1, L=2.937928, zedge=1.537464,\n      rf_field_scale=30048347.1, rf_frequency=2856000000.0, theta0_deg=294.5,\n      filename=rfdata5, radius=0.15, x_offset=0.0, y_offset=0.0, x_rotation=0.0,\n      y_rotation=0.0, z_rotation=0.0, solenoid_field_scale=0.0, s=4.475391999999999\nL0A_body_2: solrf, description=name:L0A_body_2, L=2.937928, zedge=1.537464,\n      rf_field_scale=30048347.1, rf_frequency=2856000000.0, theta0_deg=354.5,\n      filename=rfdata6, radius=0.15, x_offset=0.0, y_offset=0.0, x_rotation=0.0,\n      y_rotation=0.0, z_rotation=0.0, solenoid_field_scale=0.0, s=4.475391999999999\nL0A_exit: solrf, description=name:L0A_exit, L=0.052464, zedge=4.475392,\n      rf_field_scale=26013439.060000002, rf_frequency=2856000000.0,\n      theta0_deg=264.5, filename=rfdata7, radius=0.15, x_offset=0.0, y_offset=0.0,\n      x_rotation=0.0, y_rotation=0.0, z_rotation=0.0, solenoid_field_scale=0.0,\n      s=4.527856\n!__________________ L0A exit __________________\n! Space charge switches\n!!!0 0 0 -8 0 1 4.527856 / name:SC_ON\n!!!0 0 0 -8 0 -1 4.527856 / name:SC_OFF\n!!!0 0 0 -5 0.0 0.0 4.527856 /!name:SC_2D_to_3D\n\nYAG03: write_beam, description=name:YAG03, filename=fort.103, sample_frequency=1,\n      s=4.614538605\nQA01: quadrupole, description=name:QA01, L=0.204, zedge=4.752933605,\n      b1_gradient=1.8524000101358, L_effective=0.108, radius=0.016, x_offset=0.0,\n      y_offset=0.0, x_rotation=0.0, y_rotation=0.0, z_rotation=0.0, s=4.956933605\nQA02: quadrupole, description=name:QA02, L=0.204, zedge=5.081309605,\n      b1_gradient=-1.8524000101358, L_effective=0.108, radius=0.016, x_offset=0.0,\n      y_offset=0.0, x_rotation=0.0, y_rotation=0.0, z_rotation=0.0, s=5.285309605\n\n!__________________ L0B begin __________________\nwakefield_L0B: wakefield, description=name:wakefield_L0B, s_begin=5.328756, s=8.371612,\n      method=analytical, iris_radius=0.0116, gap=0.0292, period=0.035\n! Phased to get to 135 MeV\nL0B_entrance: solrf, description=name:L0B_entrance, L=0.052464, zedge=5.328756,\n      rf_field_scale=31395529.900000002, rf_frequency=2856000000.0,\n      theta0_deg=42.27, filename=rfdata4, radius=0.15, x_offset=0.0, y_offset=0.0,\n      x_rotation=0.0, y_rotation=0.0, z_rotation=0.0, solenoid_field_scale=0.0,\n      s=5.38122\nL0B_body_1: solrf, description=name:L0B_body_1, L=2.937928, zedge=5.38122,\n      rf_field_scale=36265246.5, rf_frequency=2856000000.0, theta0_deg=72.27,\n      filename=rfdata5, radius=0.15, x_offset=0.0, y_offset=0.0, x_rotation=0.0,\n      y_rotation=0.0, z_rotation=0.0, solenoid_field_scale=0.0, s=8.319148\nL0B_body_2: solrf, description=name:L0B_body_2, L=2.937928, zedge=5.38122,\n      rf_field_scale=36265246.5, rf_frequency=2856000000.0, theta0_deg=132.27,\n      filename=rfdata6, radius=0.15, x_offset=0.0, y_offset=0.0, x_rotation=0.0,\n      y_rotation=0.0, z_rotation=0.0, solenoid_field_scale=0.0, s=8.319148\nL0B_exit: solrf, description=name:L0B_exit, L=0.052464, zedge=8.319148,\n      rf_field_scale=31395529.900000002, rf_frequency=2856000000.0,\n      theta0_deg=42.27, filename=rfdata7, radius=0.15, x_offset=0.0, y_offset=0.0,\n      x_rotation=0.0, y_rotation=0.0, z_rotation=0.0, solenoid_field_scale=0.0,\n      s=8.371612\n!__________________ L0B exit __________________\n\nQE01: quadrupole, description=name:QE01, L=0.204, zedge=8.392048605,\n      b1_gradient=0.18720000156206, L_effective=0.108, radius=0.016, x_offset=0.0,\n      y_offset=0.0, x_rotation=0.0, y_rotation=0.0, z_rotation=0.0, s=8.596048605\nQE02: quadrupole, description=name:QE02, L=0.204, zedge=8.793561605,\n      b1_gradient=0.16609999999321, L_effective=0.108, radius=0.016, x_offset=0.0,\n      y_offset=0.0, x_rotation=0.0, y_rotation=0.0, z_rotation=0.0,\n      s=8.997561605000001\n\n!!! Unmodeled: Laser Heater from 9.076892 m to 10.690580 m\n\nQE03: quadrupole, description=name:QE03, L=0.204, zedge=11.469244190867,\n      b1_gradient=-2.6409000012747, L_effective=0.108, radius=0.016, x_offset=0.0,\n      y_offset=0.0, x_rotation=0.0, y_rotation=0.0, z_rotation=0.0, s=11.673244190867\nQE04: quadrupole, description=name:QE04, L=0.204, zedge=11.875644190867,\n      b1_gradient=2.9799999853198, L_effective=0.108, radius=0.016, x_offset=0.0,\n      y_offset=0.0, x_rotation=0.0, y_rotation=0.0, z_rotation=0.0, s=12.079644190867\n\n!!! 0 1 104 -2 0.0 0.0 12.175332190867 /!name:WS01\nOTR1: write_beam, description=name:OTR1, filename=fort.105, sample_frequency=1,\n      s=12.327300190867\n!!! 0 1 106 -2 0.0 0.0 14.089061190867 /!name:WS02\nOTR2: write_beam, description=name:OTR2, filename=fort.107, sample_frequency=1,\n      s=14.241029190867\n!!! 0 1 108 -2 0.0 0.0 16.002790190867 /!name:WS03\n!!! 0 1 109 -2 0.0 0.0 16.154758190867 /!name:OTR3\n\nSC_OFF: spacecharge, description=name:SC_OFF, s=16.5, is_on=False\n\nstop_1: stop, description=name:stop_1, s=3.0\n\n</pre> In\u00a0[14]: Copied! <pre># Output lines\nfor e in eles:\n    print(ele_line(e))\n</pre> # Output lines for e in eles:     print(ele_line(e)) <pre>0 0 0 -4 0.0 0.0 0.25 4e-12 /!name:change_timestep_1\n0 0 0 -5 0.0 0.0 -1000.0 /!name:SC_2D_to_3D\n\n!__________________ 1.5 cell gun __________________\n! Single particle phased and scaled for 6 MeV energy\n0.15 0 0 105 0.0 47537665.059089914 2856000000.0 303.93723122804266 201 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:GUN\n\n!__________________Solenoid and correctors__________________\n0.49308 0 0 105 0.0 0.0 0.0 0.0 102 0.15 0.0 0.0 0.0 0.0 0.0 0.2457 /!name:SOL1\n! Corrector quads: skew and regular. \n! Overlap SOL1. Effective length, radius estimated from measurements. \n! Max field should be 0.00714 T/m\n0.36 0 0 1 0.01601 0.0 0.21 0.0254 0.0 0.0 0.0 0.0 0.7853981633974483 /!name:SQ01\n0.36 0 0 1 0.01601 0.0 0.21 0.0254 0.0 0.0 0.0 0.0 0.0 /!name:CQ01\n!________________________________________________________________________\n\n!!! Broken: 0 1 101 -2 0.0 0.0 0.61362 /!name:YAG01\n0 1 102 -2 0.0 0.0 1.38841 /!name:YAG02\n\n!__________________ L0A begin __________________\n0 -1 0 -6 1 1 1.485 4.527856 0.0116 0.0292 0.035 /!name:wakefield_L0A\n! Phased to get to 64 MeV\n0.052464 0 0 105 1.485 26013439.060000002 2856000000.0 264.5 4 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0A_entrance\n2.937928 0 0 105 1.537464 30048347.1 2856000000.0 294.5 5 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0A_body_1\n2.937928 0 0 105 1.537464 30048347.1 2856000000.0 354.5 6 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0A_body_2\n0.052464 0 0 105 4.475392 26013439.060000002 2856000000.0 264.5 7 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0A_exit\n!__________________ L0A exit __________________\n! Space charge switches\n!!!0 0 0 -8 0 1 4.527856 / name:SC_ON\n!!!0 0 0 -8 0 -1 4.527856 / name:SC_OFF\n!!!0 0 0 -5 0.0 0.0 4.527856 /!name:SC_2D_to_3D\n\n0 1 103 -2 0.0 0.0 4.614538605 /!name:YAG03\n0.204 0 0 1 4.752933605 1.8524000101358 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QA01\n0.204 0 0 1 5.081309605 -1.8524000101358 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QA02\n\n!__________________ L0B begin __________________\n0 -1 0 -6 1 1 5.328756 8.371612 0.0116 0.0292 0.035 /!name:wakefield_L0B\n! Phased to get to 135 MeV\n0.052464 0 0 105 5.328756 31395529.900000002 2856000000.0 42.27 4 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0B_entrance\n2.937928 0 0 105 5.38122 36265246.5 2856000000.0 72.27 5 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0B_body_1\n2.937928 0 0 105 5.38122 36265246.5 2856000000.0 132.27 6 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0B_body_2\n0.052464 0 0 105 8.319148 31395529.900000002 2856000000.0 42.27 7 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0B_exit\n!__________________ L0B exit __________________\n\n0.204 0 0 1 8.392048605 0.18720000156206 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QE01\n0.204 0 0 1 8.793561605 0.16609999999321 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QE02\n\n!!! Unmodeled: Laser Heater from 9.076892 m to 10.690580 m\n\n0.204 0 0 1 11.469244190867 -2.6409000012747 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QE03\n0.204 0 0 1 11.875644190867 2.9799999853198 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QE04\n\n!!! 0 1 104 -2 0.0 0.0 12.175332190867 /!name:WS01\n0 1 105 -2 0.0 0.0 12.327300190867 /!name:OTR1\n!!! 0 1 106 -2 0.0 0.0 14.089061190867 /!name:WS02\n0 1 107 -2 0.0 0.0 14.241029190867 /!name:OTR2\n!!! 0 1 108 -2 0.0 0.0 16.002790190867 /!name:WS03\n!!! 0 1 109 -2 0.0 0.0 16.154758190867 /!name:OTR3\n\n0 0 0 -8 0.0 -1 16.5 /!name:SC_OFF\n\n0 0 0 -99 3.0 0.0 3.0 /!name:stop_1\n\n</pre>"},{"location":"examples/input_parsing_example/#parsing-impacttin","title":"Parsing ImpactT.in\u00b6","text":"<p>Here are some examples of the low level routines to parse the main input file.</p> <p>Note that the Impact class does this automatically</p>"},{"location":"examples/input_parsing_example/#individual-element-parsing","title":"Individual element parsing\u00b6","text":""},{"location":"examples/input_parsing_example/#full-lattice-parsing-into-element-dicts","title":"Full lattice parsing into element dicts\u00b6","text":""},{"location":"examples/movie_example/","title":"Movie example using write_beam","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre># Nicer plotting\nimport matplotlib\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nmatplotlib.rcParams['figure.figsize'] = (8,4)\n</pre> # Nicer plotting import matplotlib %matplotlib inline %config InlineBackend.figure_format = 'retina' matplotlib.rcParams['figure.figsize'] = (8,4) <p>Here we insert write_beam elements into an existing lattice, run, save the beams to an h5 file, and plot using openPMD-beamphysics tools</p> In\u00a0[3]: Copied! <pre>from impact import Impact\nfrom distgen import Generator\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\n</pre> from impact import Impact from distgen import Generator import numpy as np import matplotlib.pyplot as plt import os In\u00a0[4]: Copied! <pre>IMPACT_IN  = 'templates/apex_gun/ImpactT.in'\nDISTGEN_IN = 'templates/apex_gun/distgen.yaml'\nos.path.exists(IMPACT_IN)\n</pre> IMPACT_IN  = 'templates/apex_gun/ImpactT.in' DISTGEN_IN = 'templates/apex_gun/distgen.yaml' os.path.exists(IMPACT_IN) Out[4]: <pre>True</pre> In\u00a0[5]: Copied! <pre>G = Generator(DISTGEN_IN)\nG['n_particle'] = 10000\nG.run()\nP0 = G.particles\nP0.plot('x', 'y')\n</pre> G = Generator(DISTGEN_IN) G['n_particle'] = 10000 G.run() P0 = G.particles P0.plot('x', 'y') In\u00a0[6]: Copied! <pre># Make Impact object\nI = Impact(IMPACT_IN, initial_particles = P0, verbose=True)\n\n\n# Change some things\nI.header['Nx'] = 32\nI.header['Ny'] = 32\nI.header['Nz'] = 32\nI.header['Dt'] = 1e-13\n\nI.total_charge = P0['charge']\n# Change stop location\nI.stop = 0.1\n</pre> # Make Impact object I = Impact(IMPACT_IN, initial_particles = P0, verbose=True)   # Change some things I.header['Nx'] = 32 I.header['Ny'] = 32 I.header['Nz'] = 32 I.header['Dt'] = 1e-13  I.total_charge = P0['charge'] # Change stop location I.stop = 0.1  <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpcqrk3tuq\nRemoved element: stop_1\nSet stop to s = 0.1\n</pre> In\u00a0[7]: Copied! <pre># Make new write_beam elements and add them to the lattice.\nfrom impact.lattice import new_write_beam\n\n# Make a list of s\nfor s in np.linspace(0.001, 0.1, 98):\n    ele = new_write_beam(s=s, ref_eles=I.lattice) # ref_eles will ensure that there are no naming conflicts\n    I.add_ele(ele)\n</pre> # Make new write_beam elements and add them to the lattice. from impact.lattice import new_write_beam  # Make a list of s for s in np.linspace(0.001, 0.1, 98):     ele = new_write_beam(s=s, ref_eles=I.lattice) # ref_eles will ensure that there are no naming conflicts     I.add_ele(ele) <pre>Inserted ele 'write_beam_71' before ele 'APEX_GUN' at index 2 out of 8\nInserted ele 'write_beam_72' before ele 'APEX_GUN' at index 3 out of 9\nInserted ele 'write_beam_73' before ele 'APEX_GUN' at index 4 out of 10\nInserted ele 'write_beam_74' before ele 'APEX_GUN' at index 5 out of 11\nInserted ele 'write_beam_75' before ele 'APEX_GUN' at index 6 out of 12\nInserted ele 'write_beam_76' before ele 'APEX_GUN' at index 7 out of 13\nInserted ele 'write_beam_77' before ele 'APEX_GUN' at index 8 out of 14\nInserted ele 'write_beam_78' before ele 'APEX_GUN' at index 9 out of 15\nInserted ele 'write_beam_79' before ele 'APEX_GUN' at index 10 out of 16\nInserted ele 'write_beam_80' before ele 'APEX_GUN' at index 11 out of 17\nInserted ele 'write_beam_81' before ele 'APEX_GUN' at index 12 out of 18\nInserted ele 'write_beam_82' before ele 'APEX_GUN' at index 13 out of 19\nInserted ele 'write_beam_83' before ele 'APEX_GUN' at index 14 out of 20\nInserted ele 'write_beam_84' before ele 'APEX_GUN' at index 15 out of 21\nInserted ele 'write_beam_85' before ele 'APEX_GUN' at index 16 out of 22\nInserted ele 'write_beam_86' before ele 'APEX_GUN' at index 17 out of 23\nInserted ele 'write_beam_87' before ele 'APEX_GUN' at index 18 out of 24\nInserted ele 'write_beam_88' before ele 'APEX_GUN' at index 19 out of 25\nInserted ele 'write_beam_89' before ele 'APEX_GUN' at index 20 out of 26\nInserted ele 'write_beam_90' before ele 'APEX_GUN' at index 21 out of 27\nInserted ele 'write_beam_91' before ele 'APEX_GUN' at index 22 out of 28\nInserted ele 'write_beam_92' before ele 'APEX_GUN' at index 23 out of 29\nInserted ele 'write_beam_93' before ele 'APEX_GUN' at index 24 out of 30\nInserted ele 'write_beam_94' before ele 'APEX_GUN' at index 25 out of 31\nInserted ele 'write_beam_95' before ele 'APEX_GUN' at index 26 out of 32\nInserted ele 'write_beam_96' before ele 'APEX_GUN' at index 27 out of 33\nInserted ele 'write_beam_97' before ele 'APEX_GUN' at index 28 out of 34\nInserted ele 'write_beam_98' before ele 'APEX_GUN' at index 29 out of 35\nInserted ele 'write_beam_99' before ele 'APEX_GUN' at index 30 out of 36\nInserted ele 'write_beam_100' before ele 'APEX_GUN' at index 31 out of 37\nInserted ele 'write_beam_101' before ele 'APEX_GUN' at index 32 out of 38\nInserted ele 'write_beam_102' before ele 'APEX_GUN' at index 33 out of 39\nInserted ele 'write_beam_103' before ele 'APEX_GUN' at index 34 out of 40\nInserted ele 'write_beam_104' before ele 'APEX_GUN' at index 35 out of 41\nInserted ele 'write_beam_105' before ele 'APEX_GUN' at index 36 out of 42\nInserted ele 'write_beam_106' before ele 'APEX_GUN' at index 37 out of 43\nInserted ele 'write_beam_107' before ele 'APEX_GUN' at index 38 out of 44\nInserted ele 'write_beam_108' before ele 'APEX_GUN' at index 39 out of 45\nInserted ele 'write_beam_109' before ele 'APEX_GUN' at index 40 out of 46\nInserted ele 'write_beam_110' before ele 'APEX_GUN' at index 41 out of 47\nInserted ele 'write_beam_111' before ele 'APEX_GUN' at index 42 out of 48\nInserted ele 'write_beam_112' before ele 'APEX_GUN' at index 43 out of 49\nInserted ele 'write_beam_113' before ele 'APEX_GUN' at index 44 out of 50\nInserted ele 'write_beam_114' before ele 'APEX_GUN' at index 45 out of 51\nInserted ele 'write_beam_115' before ele 'APEX_GUN' at index 46 out of 52\nInserted ele 'write_beam_116' before ele 'APEX_GUN' at index 47 out of 53\nInserted ele 'write_beam_117' before ele 'APEX_GUN' at index 48 out of 54\nInserted ele 'write_beam_118' before ele 'APEX_GUN' at index 49 out of 55\nInserted ele 'write_beam_119' before ele 'APEX_GUN' at index 50 out of 56\nInserted ele 'write_beam_120' before ele 'APEX_GUN' at index 51 out of 57\nInserted ele 'write_beam_121' before ele 'APEX_GUN' at index 52 out of 58\nInserted ele 'write_beam_122' before ele 'APEX_GUN' at index 53 out of 59\nInserted ele 'write_beam_123' before ele 'APEX_GUN' at index 54 out of 60\nInserted ele 'write_beam_124' before ele 'APEX_GUN' at index 55 out of 61\nInserted ele 'write_beam_125' before ele 'APEX_GUN' at index 56 out of 62\nInserted ele 'write_beam_126' before ele 'APEX_GUN' at index 57 out of 63\nInserted ele 'write_beam_127' before ele 'APEX_GUN' at index 58 out of 64\nInserted ele 'write_beam_128' before ele 'APEX_GUN' at index 59 out of 65\nInserted ele 'write_beam_129' before ele 'APEX_GUN' at index 60 out of 66\nInserted ele 'write_beam_130' before ele 'APEX_GUN' at index 61 out of 67\nInserted ele 'write_beam_131' before ele 'APEX_GUN' at index 62 out of 68\nInserted ele 'write_beam_132' before ele 'APEX_GUN' at index 63 out of 69\nInserted ele 'write_beam_133' before ele 'APEX_GUN' at index 64 out of 70\nInserted ele 'write_beam_134' before ele 'APEX_GUN' at index 65 out of 71\nInserted ele 'write_beam_135' before ele 'APEX_GUN' at index 66 out of 72\nInserted ele 'write_beam_136' before ele 'APEX_GUN' at index 67 out of 73\nInserted ele 'write_beam_137' before ele 'APEX_GUN' at index 68 out of 74\nInserted ele 'write_beam_138' before ele 'APEX_GUN' at index 69 out of 75\nInserted ele 'write_beam_139' before ele 'APEX_GUN' at index 70 out of 76\nInserted ele 'write_beam_140' before ele 'APEX_GUN' at index 71 out of 77\nInserted ele 'write_beam_141' before ele 'APEX_GUN' at index 72 out of 78\nInserted ele 'write_beam_142' before ele 'APEX_GUN' at index 73 out of 79\nInserted ele 'write_beam_143' before ele 'APEX_GUN' at index 74 out of 80\nInserted ele 'write_beam_144' before ele 'APEX_GUN' at index 75 out of 81\nInserted ele 'write_beam_145' before ele 'APEX_GUN' at index 76 out of 82\nInserted ele 'write_beam_146' before ele 'APEX_GUN' at index 77 out of 83\nInserted ele 'write_beam_147' before ele 'APEX_GUN' at index 78 out of 84\nInserted ele 'write_beam_148' before ele 'APEX_GUN' at index 79 out of 85\nInserted ele 'write_beam_149' before ele 'APEX_GUN' at index 80 out of 86\nInserted ele 'write_beam_150' before ele 'APEX_GUN' at index 81 out of 87\nInserted ele 'write_beam_151' before ele 'APEX_GUN' at index 82 out of 88\nInserted ele 'write_beam_152' before ele 'APEX_GUN' at index 83 out of 89\nInserted ele 'write_beam_153' before ele 'APEX_GUN' at index 84 out of 90\nInserted ele 'write_beam_154' before ele 'APEX_GUN' at index 85 out of 91\nInserted ele 'write_beam_155' before ele 'APEX_GUN' at index 86 out of 92\nInserted ele 'write_beam_156' before ele 'APEX_GUN' at index 87 out of 93\nInserted ele 'write_beam_157' before ele 'APEX_GUN' at index 88 out of 94\nInserted ele 'write_beam_158' before ele 'APEX_GUN' at index 89 out of 95\nInserted ele 'write_beam_159' before ele 'APEX_GUN' at index 90 out of 96\nInserted ele 'write_beam_160' before ele 'APEX_GUN' at index 91 out of 97\nInserted ele 'write_beam_161' before ele 'APEX_GUN' at index 92 out of 98\nInserted ele 'write_beam_162' before ele 'APEX_GUN' at index 93 out of 99\nInserted ele 'write_beam_163' before ele 'APEX_GUN' at index 94 out of 100\nInserted ele 'write_beam_164' before ele 'APEX_GUN' at index 95 out of 101\nInserted ele 'write_beam_165' before ele 'APEX_GUN' at index 96 out of 102\nInserted ele 'write_beam_166' before ele 'APEX_GUN' at index 97 out of 103\nInserted ele 'write_beam_167' before ele 'APEX_GUN' at index 98 out of 104\nInserted ele 'write_beam_168' before ele 'APEX_GUN' at index 99 out of 105\n</pre> In\u00a0[8]: Copied! <pre>I.timeout = 1000\nI.run()\n</pre> I.timeout = 1000 I.run() <pre>Running Impact-T in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpcqrk3tuq\n/Users/chrisonian/Code/Impact/IMPACT-T/build/ImpactTexe\nwriting 10000 particles to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpcqrk3tuq/partcl.data\nCathode start with cathode_kinetic_energy_ref = 1.0 eV\nCathode start: Replaced Np with 10000 according to initial particles\nCathode start: Replaced Bkenergy with 1.0 according to initial particles\nCathode start: Replaced Temission with 5.064308571009823e-11 according to initial particles\nCathode start: Replaced Tini with -2.5403549006681165e-11 according to initial particles\nSetting total charge to 1.0000000000000004e-10 C\nLoaded fort 30 : Fourth root of the fourth moments of the beam distribution\nLoaded fort 25 : RMS Y information\nLoaded fort 24 : RMS X information\nLoaded fort 26 : RMS Z information\nLoaded fort 28 : Load balance and loss diagnostics\nLoaded fort 29 : Cube root of third moments of the beam distribution\nLoaded fort 18 : Time and energy\nLoaded fort 27 : Max amplitude information\nLoaded fort 70 : Slice information of the final distribution\nLoaded fort 60 : Slice information of the initial distribution\nLoading particles\nLoaded fort 40 : initial particle distribution at t = 0\nLoaded fort 50 : final particle distribution projected to the centroid location of the bunch\nLoaded write beam particles write_beam_71 fort.71\nLoaded write beam particles write_beam_72 fort.72\nLoaded write beam particles write_beam_73 fort.73\nLoaded write beam particles write_beam_74 fort.74\nLoaded write beam particles write_beam_75 fort.75\nLoaded write beam particles write_beam_76 fort.76\nLoaded write beam particles write_beam_77 fort.77\nLoaded write beam particles write_beam_78 fort.78\nLoaded write beam particles write_beam_79 fort.79\nLoaded write beam particles write_beam_80 fort.80\nLoaded write beam particles write_beam_81 fort.81\nLoaded write beam particles write_beam_82 fort.82\nLoaded write beam particles write_beam_83 fort.83\nLoaded write beam particles write_beam_84 fort.84\nLoaded write beam particles write_beam_85 fort.85\nLoaded write beam particles write_beam_86 fort.86\nLoaded write beam particles write_beam_87 fort.87\nLoaded write beam particles write_beam_88 fort.88\nLoaded write beam particles write_beam_89 fort.89\nLoaded write beam particles write_beam_90 fort.90\nLoaded write beam particles write_beam_91 fort.91\nLoaded write beam particles write_beam_92 fort.92\nLoaded write beam particles write_beam_93 fort.93\nLoaded write beam particles write_beam_94 fort.94\nLoaded write beam particles write_beam_95 fort.95\nLoaded write beam particles write_beam_96 fort.96\nLoaded write beam particles write_beam_97 fort.97\nLoaded write beam particles write_beam_98 fort.98\nLoaded write beam particles write_beam_99 fort.99\nLoaded write beam particles write_beam_100 fort.100\nLoaded write beam particles write_beam_101 fort.101\nLoaded write beam particles write_beam_102 fort.102\nLoaded write beam particles write_beam_103 fort.103\nLoaded write beam particles write_beam_104 fort.104\nLoaded write beam particles write_beam_105 fort.105\nLoaded write beam particles write_beam_106 fort.106\nLoaded write beam particles write_beam_107 fort.107\nLoaded write beam particles write_beam_108 fort.108\nLoaded write beam particles write_beam_109 fort.109\nLoaded write beam particles write_beam_110 fort.110\nLoaded write beam particles write_beam_111 fort.111\nLoaded write beam particles write_beam_112 fort.112\nLoaded write beam particles write_beam_113 fort.113\nLoaded write beam particles write_beam_114 fort.114\nLoaded write beam particles write_beam_115 fort.115\nLoaded write beam particles write_beam_116 fort.116\nLoaded write beam particles write_beam_117 fort.117\nLoaded write beam particles write_beam_118 fort.118\nLoaded write beam particles write_beam_119 fort.119\nLoaded write beam particles write_beam_120 fort.120\nLoaded write beam particles write_beam_121 fort.121\nLoaded write beam particles write_beam_122 fort.122\nLoaded write beam particles write_beam_123 fort.123\nLoaded write beam particles write_beam_124 fort.124\nLoaded write beam particles write_beam_125 fort.125\nLoaded write beam particles write_beam_126 fort.126\nLoaded write beam particles write_beam_127 fort.127\nLoaded write beam particles write_beam_128 fort.128\nLoaded write beam particles write_beam_129 fort.129\nLoaded write beam particles write_beam_130 fort.130\nLoaded write beam particles write_beam_131 fort.131\nLoaded write beam particles write_beam_132 fort.132\nLoaded write beam particles write_beam_133 fort.133\nLoaded write beam particles write_beam_134 fort.134\nLoaded write beam particles write_beam_135 fort.135\nLoaded write beam particles write_beam_136 fort.136\nLoaded write beam particles write_beam_137 fort.137\nLoaded write beam particles write_beam_138 fort.138\nLoaded write beam particles write_beam_139 fort.139\nLoaded write beam particles write_beam_140 fort.140\nLoaded write beam particles write_beam_141 fort.141\nLoaded write beam particles write_beam_142 fort.142\nLoaded write beam particles write_beam_143 fort.143\nLoaded write beam particles write_beam_144 fort.144\nLoaded write beam particles write_beam_145 fort.145\nLoaded write beam particles write_beam_146 fort.146\nLoaded write beam particles write_beam_147 fort.147\nLoaded write beam particles write_beam_148 fort.148\nLoaded write beam particles write_beam_149 fort.149\nLoaded write beam particles write_beam_150 fort.150\nLoaded write beam particles write_beam_151 fort.151\nLoaded write beam particles write_beam_152 fort.152\nLoaded write beam particles write_beam_153 fort.153\nLoaded write beam particles write_beam_154 fort.154\nLoaded write beam particles write_beam_155 fort.155\nLoaded write beam particles write_beam_156 fort.156\nLoaded write beam particles write_beam_157 fort.157\nLoaded write beam particles write_beam_158 fort.158\nLoaded write beam particles write_beam_159 fort.159\nLoaded write beam particles write_beam_160 fort.160\nLoaded write beam particles write_beam_161 fort.161\nLoaded write beam particles write_beam_162 fort.162\nLoaded write beam particles write_beam_163 fort.163\nLoaded write beam particles write_beam_164 fort.164\nLoaded write beam particles write_beam_165 fort.165\nLoaded write beam particles write_beam_166 fort.166\nLoaded write beam particles write_beam_167 fort.167\nLoaded write beam particles write_beam_168 fort.168\nConverting z to t according to cathode_kinetic_energy_ref = 1.0 eV\nConverted initial_particles to ParticleGroup\nConverted final_particles to ParticleGroup\nConverted write_beam_71 to ParticleGroup\nConverted write_beam_72 to ParticleGroup\nConverted write_beam_73 to ParticleGroup\nConverted write_beam_74 to ParticleGroup\nConverted write_beam_75 to ParticleGroup\nConverted write_beam_76 to ParticleGroup\nConverted write_beam_77 to ParticleGroup\nConverted write_beam_78 to ParticleGroup\nConverted write_beam_79 to ParticleGroup\nConverted write_beam_80 to ParticleGroup\nConverted write_beam_81 to ParticleGroup\nConverted write_beam_82 to ParticleGroup\nConverted write_beam_83 to ParticleGroup\nConverted write_beam_84 to ParticleGroup\nConverted write_beam_85 to ParticleGroup\nConverted write_beam_86 to ParticleGroup\nConverted write_beam_87 to ParticleGroup\nConverted write_beam_88 to ParticleGroup\nConverted write_beam_89 to ParticleGroup\nConverted write_beam_90 to ParticleGroup\nConverted write_beam_91 to ParticleGroup\nConverted write_beam_92 to ParticleGroup\nConverted write_beam_93 to ParticleGroup\nConverted write_beam_94 to ParticleGroup\nConverted write_beam_95 to ParticleGroup\nConverted write_beam_96 to ParticleGroup\nConverted write_beam_97 to ParticleGroup\nConverted write_beam_98 to ParticleGroup\nConverted write_beam_99 to ParticleGroup\nConverted write_beam_100 to ParticleGroup\nConverted write_beam_101 to ParticleGroup\nConverted write_beam_102 to ParticleGroup\nConverted write_beam_103 to ParticleGroup\nConverted write_beam_104 to ParticleGroup\nConverted write_beam_105 to ParticleGroup\nConverted write_beam_106 to ParticleGroup\nConverted write_beam_107 to ParticleGroup\nConverted write_beam_108 to ParticleGroup\nConverted write_beam_109 to ParticleGroup\nConverted write_beam_110 to ParticleGroup\nConverted write_beam_111 to ParticleGroup\nConverted write_beam_112 to ParticleGroup\nConverted write_beam_113 to ParticleGroup\nConverted write_beam_114 to ParticleGroup\nConverted write_beam_115 to ParticleGroup\nConverted write_beam_116 to ParticleGroup\nConverted write_beam_117 to ParticleGroup\nConverted write_beam_118 to ParticleGroup\nConverted write_beam_119 to ParticleGroup\nConverted write_beam_120 to ParticleGroup\nConverted write_beam_121 to ParticleGroup\nConverted write_beam_122 to ParticleGroup\nConverted write_beam_123 to ParticleGroup\nConverted write_beam_124 to ParticleGroup\nConverted write_beam_125 to ParticleGroup\nConverted write_beam_126 to ParticleGroup\nConverted write_beam_127 to ParticleGroup\nConverted write_beam_128 to ParticleGroup\nConverted write_beam_129 to ParticleGroup\nConverted write_beam_130 to ParticleGroup\nConverted write_beam_131 to ParticleGroup\nConverted write_beam_132 to ParticleGroup\nConverted write_beam_133 to ParticleGroup\nConverted write_beam_134 to ParticleGroup\nConverted write_beam_135 to ParticleGroup\nConverted write_beam_136 to ParticleGroup\nConverted write_beam_137 to ParticleGroup\nConverted write_beam_138 to ParticleGroup\nConverted write_beam_139 to ParticleGroup\nConverted write_beam_140 to ParticleGroup\nConverted write_beam_141 to ParticleGroup\nConverted write_beam_142 to ParticleGroup\nConverted write_beam_143 to ParticleGroup\nConverted write_beam_144 to ParticleGroup\nConverted write_beam_145 to ParticleGroup\nConverted write_beam_146 to ParticleGroup\nConverted write_beam_147 to ParticleGroup\nConverted write_beam_148 to ParticleGroup\nConverted write_beam_149 to ParticleGroup\nConverted write_beam_150 to ParticleGroup\nConverted write_beam_151 to ParticleGroup\nConverted write_beam_152 to ParticleGroup\nConverted write_beam_153 to ParticleGroup\nConverted write_beam_154 to ParticleGroup\nConverted write_beam_155 to ParticleGroup\nConverted write_beam_156 to ParticleGroup\nConverted write_beam_157 to ParticleGroup\nConverted write_beam_158 to ParticleGroup\nConverted write_beam_159 to ParticleGroup\nConverted write_beam_160 to ParticleGroup\nConverted write_beam_161 to ParticleGroup\nConverted write_beam_162 to ParticleGroup\nConverted write_beam_163 to ParticleGroup\nConverted write_beam_164 to ParticleGroup\nConverted write_beam_165 to ParticleGroup\nConverted write_beam_166 to ParticleGroup\nConverted write_beam_167 to ParticleGroup\nConverted write_beam_168 to ParticleGroup\n</pre> In\u00a0[9]: Copied! <pre>len(I.particles)\n</pre> len(I.particles) Out[9]: <pre>100</pre> In\u00a0[10]: Copied! <pre>from bokeh.plotting import  show, figure, output_notebook\nfrom bokeh.layouts import column, row\nfrom bokeh.models import ColumnDataSource\nfrom bokeh import palettes, colors\npal = palettes.Viridis[256]\nwhite=colors.named.white\npal = list(pal)\npal[0] = white # replace 0 with white\npal = tuple(pal)\noutput_notebook(verbose=False, hide_banner=True)\nimport os\n</pre> from bokeh.plotting import  show, figure, output_notebook from bokeh.layouts import column, row from bokeh.models import ColumnDataSource from bokeh import palettes, colors pal = palettes.Viridis[256] white=colors.named.white pal = list(pal) pal[0] = white # replace 0 with white pal = tuple(pal) output_notebook(verbose=False, hide_banner=True) import os In\u00a0[11]: Copied! <pre># Prepare histogram function\n\nPL = I.particles\n\nilist = []\nfor k in PL:\n    if k.startswith('write_beam_'):\n        ilist.append(int(k.strip('write_beam_')))\n\ndef bin_particles(i, key1='x', key2='y', bins=40):\n    \n    P = I.particles[f'write_beam_{i}']\n    \n    return np.histogram2d(P[key1], P[key2], weights=P.weight, bins=bins)\nbin_particles(100)\n</pre> # Prepare histogram function  PL = I.particles  ilist = [] for k in PL:     if k.startswith('write_beam_'):         ilist.append(int(k.strip('write_beam_')))  def bin_particles(i, key1='x', key2='y', bins=40):          P = I.particles[f'write_beam_{i}']          return np.histogram2d(P[key1], P[key2], weights=P.weight, bins=bins) bin_particles(100) Out[11]: <pre>(array([[0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.],\n        ...,\n        [0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.]]),\n array([-1.56268257e-03, -1.48386568e-03, -1.40504878e-03, -1.32623188e-03,\n        -1.24741498e-03, -1.16859808e-03, -1.08978118e-03, -1.01096428e-03,\n        -9.32147381e-04, -8.53330482e-04, -7.74513583e-04, -6.95696684e-04,\n        -6.16879785e-04, -5.38062886e-04, -4.59245986e-04, -3.80429087e-04,\n        -3.01612188e-04, -2.22795289e-04, -1.43978390e-04, -6.51614906e-05,\n         1.36554085e-05,  9.24723077e-05,  1.71289207e-04,  2.50106106e-04,\n         3.28923005e-04,  4.07739904e-04,  4.86556804e-04,  5.65373703e-04,\n         6.44190602e-04,  7.23007501e-04,  8.01824400e-04,  8.80641299e-04,\n         9.59458199e-04,  1.03827510e-03,  1.11709200e-03,  1.19590890e-03,\n         1.27472580e-03,  1.35354269e-03,  1.43235959e-03,  1.51117649e-03,\n         1.58999339e-03]),\n array([-1.55337299e-03, -1.47542032e-03, -1.39746764e-03, -1.31951497e-03,\n        -1.24156230e-03, -1.16360963e-03, -1.08565696e-03, -1.00770428e-03,\n        -9.29751613e-04, -8.51798941e-04, -7.73846269e-04, -6.95893597e-04,\n        -6.17940925e-04, -5.39988253e-04, -4.62035581e-04, -3.84082909e-04,\n        -3.06130237e-04, -2.28177565e-04, -1.50224893e-04, -7.22722213e-05,\n         5.68045063e-06,  8.36331226e-05,  1.61585794e-04,  2.39538466e-04,\n         3.17491138e-04,  3.95443810e-04,  4.73396482e-04,  5.51349154e-04,\n         6.29301826e-04,  7.07254498e-04,  7.85207170e-04,  8.63159842e-04,\n         9.41112514e-04,  1.01906519e-03,  1.09701786e-03,  1.17497053e-03,\n         1.25292320e-03,  1.33087587e-03,  1.40882855e-03,  1.48678122e-03,\n         1.56473389e-03]))</pre> In\u00a0[12]: Copied! <pre># Prepare a datasource for Bokeh\n\ndef bin_bunch_datasource_h5(i, key1, key2,  bins=20, nice=True, liveOnly=True, liveStatus=1):\n    H, xedges, yedges = bin_particles(i, key1, key2, bins=bins)\n    xmin = min(xedges)\n    xmax = max(xedges)\n    ymin = min(yedges)\n    ymax = max(yedges)\n    \n    \n    #if nice:\n    #    f1 = nice_phase_space_factor[component1]\n    #    f2 = nice_phase_space_factor[component2]\n    #    xlabel =  nice_phase_space_label[component1]\n    #    ylabel =  nice_phase_space_label[component2]\n    #    xmin *= f1\n    #    xmax *= f1\n    #    ymin *= f2\n    #    ymax *= f2\n    #else:\n    #    xlabel = component1\n    #    ylabel = component2\n    \n    # Form datasource\n    dat = {'image':[H.transpose()], 'xmin':[xmin], 'ymin':[ymin], 'dw':[xmax-xmin], 'dh':[ymax-ymin]}\n    dat['xmax'] = [xmax]\n    dat['ymax'] = [ymax]\n    \n    ds = ColumnDataSource(data=dat)\n    \n    return ds\nds = bin_bunch_datasource_h5(100, 'x', 'y')\n</pre> # Prepare a datasource for Bokeh  def bin_bunch_datasource_h5(i, key1, key2,  bins=20, nice=True, liveOnly=True, liveStatus=1):     H, xedges, yedges = bin_particles(i, key1, key2, bins=bins)     xmin = min(xedges)     xmax = max(xedges)     ymin = min(yedges)     ymax = max(yedges)               #if nice:     #    f1 = nice_phase_space_factor[component1]     #    f2 = nice_phase_space_factor[component2]     #    xlabel =  nice_phase_space_label[component1]     #    ylabel =  nice_phase_space_label[component2]     #    xmin *= f1     #    xmax *= f1     #    ymin *= f2     #    ymax *= f2     #else:     #    xlabel = component1     #    ylabel = component2          # Form datasource     dat = {'image':[H.transpose()], 'xmin':[xmin], 'ymin':[ymin], 'dw':[xmax-xmin], 'dh':[ymax-ymin]}     dat['xmax'] = [xmax]     dat['ymax'] = [ymax]          ds = ColumnDataSource(data=dat)          return ds ds = bin_bunch_datasource_h5(100, 'x', 'y') In\u00a0[13]: Copied! <pre>plot = figure(#x_range=[xmin,xmax], y_range=[ymin,ymax], \n              #    x_axis_label = xlabel,  y_axis_label = ylabel,\n               plot_width=500, plot_height=500)\nplot.image(image='image', x='xmin', y='ymin', dw='dw', dh='dh', source=ds,palette=pal)\nshow(plot)\n</pre>  plot = figure(#x_range=[xmin,xmax], y_range=[ymin,ymax],                #    x_axis_label = xlabel,  y_axis_label = ylabel,                plot_width=500, plot_height=500) plot.image(image='image', x='xmin', y='ymin', dw='dw', dh='dh', source=ds,palette=pal) show(plot) In\u00a0[14]: Copied! <pre>from bokeh.models.widgets import Slider\nfrom bokeh import palettes, colors\n</pre> from bokeh.models.widgets import Slider from bokeh import palettes, colors  In\u00a0[15]: Copied! <pre># interactive\ndef myapp2(doc):\n    \n    bunches = ilist\n    \n    doc.bunchi = bunches[0]\n    doc.component1 = 'z'\n    doc.component2 = 'x' \n    doc.xlabel = doc.component1\n    doc.ylabel = doc.component2\n\n    doc.bins = 100\n    \n    #doc.range = FULLRANGE\n    ds  = bin_bunch_datasource_h5(doc.bunchi, doc.component1, doc.component2,bins=doc.bins) \n\n    def refresh():\n        ds.data  = dict(bin_bunch_datasource_h5(doc.bunchi, doc.component1, doc.component2,bins=doc.bins).data )\n    \n    # Default plot\n  \n    plot = figure(title='',  \n                  x_axis_label = doc.xlabel, y_axis_label = doc.ylabel,\n           plot_width=500, plot_height=500)    \n    plot.image(image='image', x='xmin', y='ymin', dw='dw', dh='dh', source=ds, palette=pal)\n    \n    def slider_handler(attr, old, new):\n        doc.bunchi =  bunches[new]\n        refresh()\n\n    slider = Slider(start=0, end=len(bunches)-1, value=0, step=1, title='x')             \n    slider.on_change('value', slider_handler)\n\n    # Add plot to end\n    doc.add_root(column(slider, plot))\nshow(myapp2)# , notebook_url=remote_jupyter_proxy_url)\n</pre> # interactive def myapp2(doc):          bunches = ilist          doc.bunchi = bunches[0]     doc.component1 = 'z'     doc.component2 = 'x'      doc.xlabel = doc.component1     doc.ylabel = doc.component2      doc.bins = 100          #doc.range = FULLRANGE     ds  = bin_bunch_datasource_h5(doc.bunchi, doc.component1, doc.component2,bins=doc.bins)       def refresh():         ds.data  = dict(bin_bunch_datasource_h5(doc.bunchi, doc.component1, doc.component2,bins=doc.bins).data )          # Default plot        plot = figure(title='',                     x_axis_label = doc.xlabel, y_axis_label = doc.ylabel,            plot_width=500, plot_height=500)         plot.image(image='image', x='xmin', y='ymin', dw='dw', dh='dh', source=ds, palette=pal)          def slider_handler(attr, old, new):         doc.bunchi =  bunches[new]         refresh()      slider = Slider(start=0, end=len(bunches)-1, value=0, step=1, title='x')                  slider.on_change('value', slider_handler)      # Add plot to end     doc.add_root(column(slider, plot)) show(myapp2)# , notebook_url=remote_jupyter_proxy_url) In\u00a0[16]: Copied! <pre># If there are multiple \nimport os\nos.environ['BOKEH_ALLOW_WS_ORIGIN'] = 'localhost:8888'\n</pre> # If there are multiple  import os os.environ['BOKEH_ALLOW_WS_ORIGIN'] = 'localhost:8888'"},{"location":"examples/movie_example/#movie-example-using-write_beam","title":"Movie example using write_beam\u00b6","text":""},{"location":"examples/movie_example/#plot","title":"Plot\u00b6","text":""},{"location":"examples/movie_example/#interactive","title":"Interactive\u00b6","text":""},{"location":"examples/output_parsing_example/","title":"Low level parsing of Impact output files","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from impact.parsers import fort_files, load_fort, load_many_fort, parse_impact_input\n</pre> from impact.parsers import fort_files, load_fort, load_many_fort, parse_impact_input In\u00a0[3]: Copied! <pre>opath = 'templates/lcls_injector/output/'\n\n# Find fort.X output files in path\nfortfiles=fort_files(opath)\nfortfiles\n</pre> opath = 'templates/lcls_injector/output/'  # Find fort.X output files in path fortfiles=fort_files(opath) fortfiles Out[3]: <pre>['templates/lcls_injector/output/fort.30',\n 'templates/lcls_injector/output/fort.40',\n 'templates/lcls_injector/output/fort.25',\n 'templates/lcls_injector/output/fort.70',\n 'templates/lcls_injector/output/fort.102',\n 'templates/lcls_injector/output/fort.24',\n 'templates/lcls_injector/output/fort.60',\n 'templates/lcls_injector/output/fort.50',\n 'templates/lcls_injector/output/fort.26',\n 'templates/lcls_injector/output/fort.28',\n 'templates/lcls_injector/output/fort.29',\n 'templates/lcls_injector/output/fort.18',\n 'templates/lcls_injector/output/fort.27']</pre> In\u00a0[4]: Copied! <pre># Load one file\nload_fort(fortfiles[0]).keys()\n</pre> # Load one file load_fort(fortfiles[0]).keys() <pre>Loaded fort 30 : Fourth root of the fourth moments of the beam distribution\n</pre> Out[4]: <pre>dict_keys(['t', 'mean_z', 'moment4_x', 'moment4_gammabeta_x', 'moment4_y', 'moment4_gammabeta_y', 'moment4_z', 'moment4_gammabeta_z'])</pre> In\u00a0[5]: Copied! <pre># Load many\n</pre> # Load many In\u00a0[6]: Copied! <pre>data = load_many_fort(opath, verbose=True)\n</pre> data = load_many_fort(opath, verbose=True) <pre>Loaded fort 30 : Fourth root of the fourth moments of the beam distribution\nLoaded fort 25 : RMS Y information\nLoaded fort 24 : RMS X information\nLoaded fort 26 : RMS Z information\nLoaded fort 28 : Load balance and loss diagnostics\nLoaded fort 29 : Cube root of third moments of the beam distribution\nLoaded fort 18 : Time and energy\nLoaded fort 27 : Max amplitude information\n</pre> In\u00a0[7]: Copied! <pre>from bokeh.plotting import figure, output_notebook, show\nfrom bokeh.models import ColumnDataSource\nfrom bokeh.layouts import column\nfrom bokeh.models.widgets import Dropdown\nfrom impact.parsers import UNITS\noutput_notebook()\n</pre> from bokeh.plotting import figure, output_notebook, show from bokeh.models import ColumnDataSource from bokeh.layouts import column from bokeh.models.widgets import Dropdown from impact.parsers import UNITS output_notebook() Loading BokehJS ... In\u00a0[8]: Copied! <pre>ds = ColumnDataSource(data)\n</pre> ds = ColumnDataSource(data) In\u00a0[9]: Copied! <pre>def plot1(y_axis, x_axis='mean_z', source=ds):\n    yunit = UNITS[y_axis]\n    ylabel = y_axis+' ('+yunit+')'\n    \n    xunit = UNITS[x_axis]\n    xlabel = x_axis+' ('+xunit+')'\n    p = figure(plot_width=600, plot_height=200, x_axis_label=xlabel, y_axis_label=ylabel)\n    p.line( x_axis, y_axis, source=source, color='red')\n    return p\nshow(plot1('norm_emit_x') )\n</pre> def plot1(y_axis, x_axis='mean_z', source=ds):     yunit = UNITS[y_axis]     ylabel = y_axis+' ('+yunit+')'          xunit = UNITS[x_axis]     xlabel = x_axis+' ('+xunit+')'     p = figure(plot_width=600, plot_height=200, x_axis_label=xlabel, y_axis_label=ylabel)     p.line( x_axis, y_axis, source=source, color='red')     return p show(plot1('norm_emit_x') ) In\u00a0[10]: Copied! <pre>data.keys()\n</pre> data.keys() Out[10]: <pre>dict_keys(['t', 'mean_z', 'moment4_x', 'moment4_gammabeta_x', 'moment4_y', 'moment4_gammabeta_y', 'moment4_z', 'moment4_gammabeta_z', 'mean_y', 'sigma_y', 'mean_gammabeta_y', 'sigma_gammabeta_y', '-cov_y__gammabeta_y', 'norm_emit_y', 'mean_x', 'sigma_x', 'mean_gammabeta_x', 'sigma_gammabeta_x', '-cov_x__gammabeta_x', 'norm_emit_x', 'sigma_z', 'mean_gammabeta_z', 'sigma_gammabeta_z', '-cov_z__gammabeta_z', 'norm_emit_z', 'loadbalance_min_n_particle', 'loadbalance_max_n_particle', 'n_particle', 'moment3_x', 'moment3_gammabeta_x', 'moment3_y', 'moment3_gammabeta_y', 'moment3_z', 'moment3_gammabeta_z', 'mean_gamma', 'mean_kinetic_energy_MeV', 'mean_beta', 'max_r', 'sigma_gamma', 'max_amplitude_x', 'max_amplitude_gammabeta_x', 'max_amplitude_y', 'max_amplitude_gammabeta_y', 'max_amplitude_z', 'max_amplitude_gammabeta_z'])</pre> In\u00a0[11]: Copied! <pre>infile =  'templates/lcls_injector/ImpactT.in'\ndat= parse_impact_input(infile)   \nheader = dat['header']\nlattice = dat['lattice']\n</pre> infile =  'templates/lcls_injector/ImpactT.in' dat= parse_impact_input(infile)    header = dat['header'] lattice = dat['lattice']"},{"location":"examples/output_parsing_example/#low-level-parsing-of-impact-output-files","title":"Low level parsing of Impact output files\u00b6","text":"<p>Note that the Impact class does this automatically.</p>"},{"location":"examples/output_parsing_example/#plot","title":"Plot\u00b6","text":""},{"location":"examples/parallel_run_example/","title":"Parallel Impact-T run","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n\n# Nicer plotting\nimport matplotlib\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nmatplotlib.rcParams['figure.figsize'] = (8,4)\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2  # Nicer plotting import matplotlib %matplotlib inline %config InlineBackend.figure_format = 'retina' matplotlib.rcParams['figure.figsize'] = (8,4) In\u00a0[2]: Copied! <pre>from impact import Impact\nimport os\nfrom tempfile import TemporaryDirectory\n</pre> from impact import Impact import os from tempfile import TemporaryDirectory In\u00a0[3]: Copied! <pre>ifile = 'templates/lcls_injector/ImpactT.in'\nos.path.exists(ifile)\n</pre> ifile = 'templates/lcls_injector/ImpactT.in' os.path.exists(ifile) Out[3]: <pre>True</pre> In\u00a0[4]: Copied! <pre># Make Impact object\nI = Impact(ifile)\n\n# Change some things\nI.header['Np'] = 10000\nI.header['Nx'] = 32\nI.header['Ny'] = 32\nI.header['Nz'] = 32\nI.header['Dt'] = 5e-13\nI.stop = 3\n\n# Turn on MPI and set parallel domain\nI.numprocs = 4\n\nI.path\n</pre> # Make Impact object I = Impact(ifile)  # Change some things I.header['Np'] = 10000 I.header['Nx'] = 32 I.header['Ny'] = 32 I.header['Nz'] = 32 I.header['Dt'] = 5e-13 I.stop = 3  # Turn on MPI and set parallel domain I.numprocs = 4  I.path Out[4]: <pre>'/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp9guxtwlj'</pre> In\u00a0[5]: Copied! <pre># Write input to workdir\nI.write_input()\n\n# This will be the working path\nI.path\n</pre> # Write input to workdir I.write_input()  # This will be the working path I.path Out[5]: <pre>'/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp9guxtwlj'</pre> In\u00a0[6]: Copied! <pre>!cat {I.path}/ImpactT.in\n</pre> !cat {I.path}/ImpactT.in <pre>! Impact-T input file\n!Npcol Nprow\n2 2\n!Dt Ntstep Nbunch\n5e-13 1000000 1\n!Dim Np Flagmap Flagerr Flagdiag Flagimg Zimage\n6 10000 1 0 2 1 0.02\n!Nx Ny Nz Flagbc Xrad Yrad Perdlen\n32 32 32 1 0.015 0.015 45.0\n!Flagdist Rstartflg Flagsbstp Nemission Temission\n16 0 0 400 6.515803466731775e-12\n!sigx(m) sigpx muxpx xscale pxscale xmu1(m) xmu2\n0.0006 0.0 0.0 1.0 1.0 0.0 0.0\n!sigy(m) sigpy muxpy yscale pyscale ymu1(m) ymu2\n0.0006 0.0 0.0 1.0 1.0 0.0 0.0\n!sigz(m) sigpz muxpz zscale pzscale zmu1(m) zmu2\n1.27e-06 0.0 0.0 1.0 1.0 0.0 0.0\n!Bcurr Bkenergy Bmass Bcharge Bfreq Tini\n0.7140000000000003 1.0 511005.0 -1.0 2856000000.0 -3.249141278122655e-12\n!=================== LATTICE ===================\n0 0 0 -4 0.0 0.0 0.25 4e-12 /!name:change_timestep_1\n0 0 0 -5 0.0 0.0 -1000.0 /!name:SC_2D_to_3D\n\n!__________________ 1.5 cell gun __________________\n! Single particle phased and scaled for 6 MeV energy\n0.15 0 0 105 0.0 47537665.059089914 2856000000.0 303.93723122804266 201 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:GUN\n\n!__________________Solenoid and correctors__________________\n0.49308 0 0 105 0.0 0.0 0.0 0.0 102 0.15 0.0 0.0 0.0 0.0 0.0 0.2457 /!name:SOL1\n! Corrector quads: skew and regular. \n! Overlap SOL1. Effective length, radius estimated from measurements. \n! Max field should be 0.00714 T/m\n0.36 0 0 1 0.01601 0.0 0.21 0.0254 0.0 0.0 0.0 0.0 0.7853981633974483 /!name:SQ01\n0.36 0 0 1 0.01601 0.0 0.21 0.0254 0.0 0.0 0.0 0.0 0.0 /!name:CQ01\n!________________________________________________________________________\n\n!!! Broken: 0 1 101 -2 0.0 0.0 0.61362 /!name:YAG01\n0 1 102 -2 0.0 0.0 1.38841 /!name:YAG02\n\n!__________________ L0A begin __________________\n0 -1 0 -6 1 1 1.485 4.527856 0.0116 0.0292 0.035 /!name:wakefield_L0A\n! Phased to get to 64 MeV\n0.052464 0 0 105 1.485 26013439.060000002 2856000000.0 264.5 4 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0A_entrance\n2.937928 0 0 105 1.537464 30048347.1 2856000000.0 294.5 5 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0A_body_1\n2.937928 0 0 105 1.537464 30048347.1 2856000000.0 354.5 6 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0A_body_2\n0.052464 0 0 105 4.475392 26013439.060000002 2856000000.0 264.5 7 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0A_exit\n!__________________ L0A exit __________________\n! Space charge switches\n!!!0 0 0 -8 0 1 4.527856 / name:SC_ON\n!!!0 0 0 -8 0 -1 4.527856 / name:SC_OFF\n!!!0 0 0 -5 0.0 0.0 4.527856 /!name:SC_2D_to_3D\n\n0 1 103 -2 0.0 0.0 4.614538605 /!name:YAG03\n0.204 0 0 1 4.752933605 1.8524000101358 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QA01\n0.204 0 0 1 5.081309605 -1.8524000101358 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QA02\n\n!__________________ L0B begin __________________\n0 -1 0 -6 1 1 5.328756 8.371612 0.0116 0.0292 0.035 /!name:wakefield_L0B\n! Phased to get to 135 MeV\n0.052464 0 0 105 5.328756 31395529.900000002 2856000000.0 42.27 4 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0B_entrance\n2.937928 0 0 105 5.38122 36265246.5 2856000000.0 72.27 5 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0B_body_1\n2.937928 0 0 105 5.38122 36265246.5 2856000000.0 132.27 6 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0B_body_2\n0.052464 0 0 105 8.319148 31395529.900000002 2856000000.0 42.27 7 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:L0B_exit\n!__________________ L0B exit __________________\n\n0.204 0 0 1 8.392048605 0.18720000156206 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QE01\n0.204 0 0 1 8.793561605 0.16609999999321 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QE02\n\n!!! Unmodeled: Laser Heater from 9.076892 m to 10.690580 m\n\n0.204 0 0 1 11.469244190867 -2.6409000012747 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QE03\n0.204 0 0 1 11.875644190867 2.9799999853198 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QE04\n\n!!! 0 1 104 -2 0.0 0.0 12.175332190867 /!name:WS01\n0 1 105 -2 0.0 0.0 12.327300190867 /!name:OTR1\n!!! 0 1 106 -2 0.0 0.0 14.089061190867 /!name:WS02\n0 1 107 -2 0.0 0.0 14.241029190867 /!name:OTR2\n!!! 0 1 108 -2 0.0 0.0 16.002790190867 /!name:WS03\n!!! 0 1 109 -2 0.0 0.0 16.154758190867 /!name:OTR3\n\n0 0 0 -8 0.0 -1 16.5 /!name:SC_OFF\n\n\n0 0 0 -99 3 0.0 3 /!name:stop_1\n</pre> In\u00a0[7]: Copied! <pre>I.path\n</pre> I.path Out[7]: <pre>'/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp9guxtwlj'</pre> In\u00a0[8]: Copied! <pre>!cat {I.path}/run\n</pre> !cat {I.path}/run <pre>mpirun -n 4 /Users/chrisonian/Code/Impact/IMPACT-T/build-mpi/ImpactTexe-mpi</pre> <p>Here we will do a quick run</p> In\u00a0[9]: Copied! <pre>%%time\n!cd {I.path};./run &gt;log.txt\n</pre> %%time !cd {I.path};./run &gt;log.txt <pre>CPU times: user 167 ms, sys: 49.2 ms, total: 217 ms\nWall time: 27.9 s\n</pre> In\u00a0[10]: Copied! <pre># Save into template for the other examples to use\n#OUTPATH = os.path.join(os.path.split(ifile)[0], 'output/')\n#!cp {I.path}/fort* {OUTPATH}\n</pre> # Save into template for the other examples to use #OUTPATH = os.path.join(os.path.split(ifile)[0], 'output/') #!cp {I.path}/fort* {OUTPATH} In\u00a0[11]: Copied! <pre>I.verbose=True\n# Load output\nI.load_output()\n</pre> I.verbose=True # Load output I.load_output() <pre>Loaded fort 30 : Fourth root of the fourth moments of the beam distribution\nLoaded fort 25 : RMS Y information\nLoaded fort 24 : RMS X information\nLoaded fort 26 : RMS Z information\nLoaded fort 28 : Load balance and loss diagnostics\nLoaded fort 29 : Cube root of third moments of the beam distribution\nLoaded fort 18 : Time and energy\nLoaded fort 27 : Max amplitude information\nLoaded fort 70 : Slice information of the final distribution\nLoaded fort 60 : Slice information of the initial distribution\nLoading particles\nLoaded fort 40 : initial particle distribution at t = 0\nLoaded fort 50 : final particle distribution projected to the centroid location of the bunch\nLoaded write beam particles YAG02 fort.102\nConverting z to t according to cathode_kinetic_energy_ref = 1.0 eV\nConverted initial_particles to ParticleGroup\nConverted final_particles to ParticleGroup\nConverted YAG02 to ParticleGroup\n</pre> In\u00a0[12]: Copied! <pre>I.plot(ylim=(0, 0.002))\n</pre> I.plot(ylim=(0, 0.002)) In\u00a0[13]: Copied! <pre>I2 = Impact(f'{I.path}/ImpactT.in', use_temp_dir=False)\n</pre> I2 = Impact(f'{I.path}/ImpactT.in', use_temp_dir=False) In\u00a0[14]: Copied! <pre>I2.load_output()\n</pre> I2.load_output() In\u00a0[15]: Copied! <pre>I.plot(ylim=(0, 0.002))\n</pre> I.plot(ylim=(0, 0.002)) In\u00a0[16]: Copied! <pre>afile = os.path.expandvars('output.h5')\nI2.archive(afile)\n</pre> afile = os.path.expandvars('output.h5') I2.archive(afile) Out[16]: <pre>'output.h5'</pre> In\u00a0[17]: Copied! <pre># Cleanup\nos.remove(afile)\n</pre> # Cleanup os.remove(afile)"},{"location":"examples/parallel_run_example/#parallel-impact-t-run","title":"Parallel Impact-T run\u00b6","text":"<p>This example shows how to set up the Impact-T input files and run script, but to leave the running to the user.</p>"},{"location":"examples/parallel_run_example/#run-externally","title":"Run externally\u00b6","text":"<p>Parallel jobs often need to be run on special nodes and/or submitted to a queue, invoking the run script:</p>"},{"location":"examples/parallel_run_example/#collect-output","title":"Collect output\u00b6","text":""},{"location":"examples/parallel_run_example/#alternative-load-into-new-object","title":"Alternative: load into new object\u00b6","text":"<p>If this notebook went out of scope, or the run was done previously, we'd need to load the output into a new object.</p>"},{"location":"examples/parallel_run_example/#archiving","title":"Archiving\u00b6","text":"<p>Archiving is the same as in the simple example</p>"},{"location":"examples/plotting_example/","title":"Layout Plotting","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>import os\nimport numpy as np\n\nfrom impact import Impact\n\nfrom impact.parsers import parse_impact_input\nfrom impact.plotting import layout_plot\nfrom impact.fieldmaps import ele_field, lattice_field\n\nfrom bokeh.plotting import output_notebook\nfrom bokeh.plotting import show\noutput_notebook(hide_banner=True)\n\nimport matplotlib.pyplot as plt\nfrom ipywidgets import interact\n%config InlineBackend.figure_format = 'retina'\n</pre> import os import numpy as np  from impact import Impact  from impact.parsers import parse_impact_input from impact.plotting import layout_plot from impact.fieldmaps import ele_field, lattice_field  from bokeh.plotting import output_notebook from bokeh.plotting import show output_notebook(hide_banner=True)  import matplotlib.pyplot as plt from ipywidgets import interact %config InlineBackend.figure_format = 'retina' In\u00a0[3]: Copied! <pre>infile = 'templates/lcls_injector/ImpactT.in'\n</pre> infile = 'templates/lcls_injector/ImpactT.in' In\u00a0[4]: Copied! <pre>I = Impact(infile)\nI.plot(figsize=(12,4))\n</pre> I = Impact(infile) I.plot(figsize=(12,4)) In\u00a0[5]: Copied! <pre># Track 1 particle\nI.track1()\n\n# These are the fields seen by the bunch centroid\nI.plot('Ez', y2='Bz')\n</pre> # Track 1 particle I.track1()  # These are the fields seen by the bunch centroid I.plot('Ez', y2='Bz') In\u00a0[6]: Copied! <pre># Fieldmaps can be added to existing axes\n\nfrom impact.plot import add_fieldmaps_to_axes\n\nfig, ax = plt.subplots()        \nadd_fieldmaps_to_axes(I, t=1, ax=ax, bounds=(0, 10))\n</pre> # Fieldmaps can be added to existing axes  from impact.plot import add_fieldmaps_to_axes  fig, ax = plt.subplots()         add_fieldmaps_to_axes(I, t=1, ax=ax, bounds=(0, 10))    In\u00a0[7]: Copied! <pre># Get fieldmaps\nfmaps = I.fieldmaps\n\n# This shows the field from a single element\nele_field(I.ele['GUN'], z=.1, fmaps=fmaps)\n</pre> # Get fieldmaps fmaps = I.fieldmaps  # This shows the field from a single element ele_field(I.ele['GUN'], z=.1, fmaps=fmaps) Out[7]: <pre>1738690.5187003852</pre> In\u00a0[8]: Copied! <pre># this gets the total field from all elements in the lattice\nlattice_field(I.lattice, z=.3, fmaps=fmaps)\n</pre> # this gets the total field from all elements in the lattice lattice_field(I.lattice, z=.3, fmaps=fmaps) Out[8]: <pre>0.0</pre> In\u00a0[9]: Copied! <pre>I.input['fieldmaps'].keys()\n</pre> I.input['fieldmaps'].keys() Out[9]: <pre>dict_keys(['rfdata201', 'rfdata102', 'rfdata4', 'rfdata5', 'rfdata6', 'rfdata7'])</pre> In\u00a0[10]: Copied! <pre># Period in ps\nT = 1 / 2856000000.0\nT / 1e-12 # ps\n</pre> # Period in ps T = 1 / 2856000000.0 T / 1e-12 # ps Out[10]: <pre>350.140056022409</pre> In\u00a0[11]: Copied! <pre>I = Impact(infile)\nI.plot(figsize=(12,4), field_t=0)\n</pre> I = Impact(infile) I.plot(figsize=(12,4), field_t=0) In\u00a0[12]: Copied! <pre># Make a function to get a field array at a given phase/2pi\n\nzz = np.linspace(0, I.stop, 1000)\ndef field_at(phi0):\n    Ez_at = np.array([I.field(z=z, t=phi0/2856000000.0, \n                                 component='Ez') for z in zz])\n    plt.plot(zz, Ez_at/1e6)\n    plt.ylim(-100, 100)\n    #plt.xlim(2, 2.2)\n    \n#def field_at(phi0):\n#    t=phi0/2856000000.0\n#    fig = I.plot(figsize=(12,4), field_t=t, return_figure=True)\n#    fig.axes[0].set_ylim(-100,100)\n#    fig.axes[1].set_ylim(-0, 0.3)    \n\nfield_at(0)\n</pre> # Make a function to get a field array at a given phase/2pi  zz = np.linspace(0, I.stop, 1000) def field_at(phi0):     Ez_at = np.array([I.field(z=z, t=phi0/2856000000.0,                                   component='Ez') for z in zz])     plt.plot(zz, Ez_at/1e6)     plt.ylim(-100, 100)     #plt.xlim(2, 2.2)      #def field_at(phi0): #    t=phi0/2856000000.0 #    fig = I.plot(figsize=(12,4), field_t=t, return_figure=True) #    fig.axes[0].set_ylim(-100,100) #    fig.axes[1].set_ylim(-0, 0.3)      field_at(0) In\u00a0[13]: Copied! <pre># Visualize the oscillating fields\ninteract(field_at, phi0=(0, 2, .01))\n</pre> # Visualize the oscillating fields interact(field_at, phi0=(0, 2, .01)) <pre>interactive(children=(FloatSlider(value=1.0, description='phi0', max=2.0, step=0.01), Output()), _dom_classes=\u2026</pre> Out[13]: <pre>&lt;function __main__.field_at(phi0)&gt;</pre> In\u00a0[14]: Copied! <pre># These are the fields seen by the bunch\nI.track1()\nzz = I.stat('mean_z')\ntt = I.stat('t')\n\nEz_seen = np.array([lattice_field(I.lattice, z=z, t=t, fmaps=fmaps,\n                                 component='Ez') for z, t in zip(zz, tt)])\nzz = zz[:len(tt)]\nplt.plot(zz, Ez_seen)\n</pre> # These are the fields seen by the bunch I.track1() zz = I.stat('mean_z') tt = I.stat('t')  Ez_seen = np.array([lattice_field(I.lattice, z=z, t=t, fmaps=fmaps,                                  component='Ez') for z, t in zip(zz, tt)]) zz = zz[:len(tt)] plt.plot(zz, Ez_seen) Out[14]: <pre>[&lt;matplotlib.lines.Line2D at 0x127ada280&gt;]</pre> In\u00a0[15]: Copied! <pre># MeV energy gain\n-np.trapz(Ez_seen, zz) / 1e6\n</pre> # MeV energy gain -np.trapz(Ez_seen, zz) / 1e6 Out[15]: <pre>34.272824268974844</pre> In\u00a0[16]: Copied! <pre># This is pretty close to the tracked kinetic energy\nI.stat('mean_kinetic_energy')[-1]/1e6\n</pre> # This is pretty close to the tracked kinetic energy I.stat('mean_kinetic_energy')[-1]/1e6 Out[16]: <pre>34.269711</pre> In\u00a0[17]: Copied! <pre>infile = 'templates/lcls_injector/ImpactT.in'\nos.path.exists(infile)\n\ndat= parse_impact_input(infile)   \nheader = dat['header']\nlattice = dat['lattice']\n</pre> infile = 'templates/lcls_injector/ImpactT.in' os.path.exists(infile)  dat= parse_impact_input(infile)    header = dat['header'] lattice = dat['lattice'] In\u00a0[18]: Copied! <pre>layout = layout_plot(lattice)\nshow(layout)\n</pre> layout = layout_plot(lattice) show(layout) In\u00a0[19]: Copied! <pre>from bokeh.plotting import figure\nfrom bokeh.layouts import column, row\nfrom bokeh.models import ColumnDataSource, Range1d\nfrom impact.parsers import load_many_fort\nfrom impact.parsers import UNITS\n</pre> from bokeh.plotting import figure from bokeh.layouts import column, row from bokeh.models import ColumnDataSource, Range1d from impact.parsers import load_many_fort from impact.parsers import UNITS   In\u00a0[20]: Copied! <pre>opath = 'templates/lcls_injector/output/'\ndata = load_many_fort(opath, verbose=True)\nds = ColumnDataSource(data)\n</pre> opath = 'templates/lcls_injector/output/' data = load_many_fort(opath, verbose=True) ds = ColumnDataSource(data) <pre>Loaded fort 30 : Fourth root of the fourth moments of the beam distribution\nLoaded fort 25 : RMS Y information\nLoaded fort 24 : RMS X information\nLoaded fort 26 : RMS Z information\nLoaded fort 28 : Load balance and loss diagnostics\nLoaded fort 29 : Cube root of third moments of the beam distribution\nLoaded fort 18 : Time and energy\nLoaded fort 27 : Max amplitude information\n</pre> In\u00a0[21]: Copied! <pre>def plot1(y_axis, x_axis='mean_z', source=ds):\n    yunit = UNITS[y_axis]\n    ylabel = y_axis+' ('+yunit+')'\n    \n    xunit = UNITS[x_axis]\n    xlabel = x_axis+' ('+xunit+')'\n    p = figure(plot_width=600, plot_height=200, x_axis_label=xlabel, y_axis_label=ylabel)\n    p.line( x_axis, y_axis, source=source, color='red')\n    return p\nshow(plot1('norm_emit_x'))\n</pre> def plot1(y_axis, x_axis='mean_z', source=ds):     yunit = UNITS[y_axis]     ylabel = y_axis+' ('+yunit+')'          xunit = UNITS[x_axis]     xlabel = x_axis+' ('+xunit+')'     p = figure(plot_width=600, plot_height=200, x_axis_label=xlabel, y_axis_label=ylabel)     p.line( x_axis, y_axis, source=source, color='red')     return p show(plot1('norm_emit_x')) <p>This also links the panning, zooming</p> In\u00a0[22]: Copied! <pre>p1 = plot1('sigma_x')\np2 = plot1('norm_emit_x')\nzmax = 2\nlayout.x_range = Range1d(0,zmax)\np1.x_range = Range1d(0,zmax)\n\nlayout.plot_width = p1.plot_width\n\n# Link panning, zooming\nlayout.x_range = p1.x_range\np2.x_range = p1.x_range\n\nshow(\n    column(\n    p1,\n    p2,\n    layout))\n</pre> p1 = plot1('sigma_x') p2 = plot1('norm_emit_x') zmax = 2 layout.x_range = Range1d(0,zmax) p1.x_range = Range1d(0,zmax)  layout.plot_width = p1.plot_width  # Link panning, zooming layout.x_range = p1.x_range p2.x_range = p1.x_range  show(     column(     p1,     p2,     layout))"},{"location":"examples/plotting_example/#layout-plotting","title":"Layout Plotting\u00b6","text":""},{"location":"examples/plotting_example/#matplotlib-plotting-from-the-impact-object","title":"matplotlib plotting from the Impact object\u00b6","text":""},{"location":"examples/plotting_example/#low-level-get-field","title":"Low-level get field\u00b6","text":""},{"location":"examples/plotting_example/#bokeh-plotting-from-the-input-file","title":"Bokeh plotting from the input file\u00b6","text":""},{"location":"examples/plotting_example/#output-plotting","title":"Output Plotting\u00b6","text":""},{"location":"examples/plotting_example/#stacking-plots","title":"Stacking plots\u00b6","text":""},{"location":"examples/solrf_fieldmaps/","title":"solrf fieldmaps","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload    \n%autoreload 2\n</pre> %load_ext autoreload     %autoreload 2 In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n</pre> import matplotlib.pyplot as plt %config InlineBackend.figure_format = 'retina' In\u00a0[3]: Copied! <pre>import numpy as np\nfrom numpy import sin, cos, pi, arange\nimport os\n</pre> import numpy as np from numpy import sin, cos, pi, arange import os In\u00a0[4]: Copied! <pre># Here is some on-axis data\nBDAT = 'templates/solenoid/newSOL.dat'\n</pre> # Here is some on-axis data BDAT = 'templates/solenoid/newSOL.dat' In\u00a0[5]: Copied! <pre>DAT = np.loadtxt(BDAT).T\nZ, BZ = DAT[0], DAT[1]/DAT[1].max()\n\n# Test odd number of points\nZ  = Z[:-1]\nBZ = BZ[:-1]\n\nSKIP = 1 # Thin out data for visualization\n\nZ = Z[::SKIP]\nBZ = BZ[::SKIP]\n\n# Get spacing\nDZ = np.diff(Z)\nassert np.allclose(DZ, DZ[0])\nDZ = DZ[0]\nL = Z.ptp()\n\n\n#BZ *= sin(100*Z)\n\n# Test for odd number of points\n\nBZ[-1] = BZ[0] # assert periodicity\n\nplt.plot(Z, BZ, marker='.')\nplt.title(f'{len(Z)} points')\n</pre> DAT = np.loadtxt(BDAT).T Z, BZ = DAT[0], DAT[1]/DAT[1].max()  # Test odd number of points Z  = Z[:-1] BZ = BZ[:-1]  SKIP = 1 # Thin out data for visualization  Z = Z[::SKIP] BZ = BZ[::SKIP]  # Get spacing DZ = np.diff(Z) assert np.allclose(DZ, DZ[0]) DZ = DZ[0] L = Z.ptp()   #BZ *= sin(100*Z)  # Test for odd number of points  BZ[-1] = BZ[0] # assert periodicity  plt.plot(Z, BZ, marker='.') plt.title(f'{len(Z)} points') Out[5]: <pre>Text(0.5, 1.0, '9999 points')</pre> In\u00a0[6]: Copied! <pre>from pmd_beamphysics.interfaces.impact import create_fourier_coefficients\n\nN_COEF = 20\n\nfcoefs1 = create_fourier_coefficients(Z, BZ, n= N_COEF)\n</pre> from pmd_beamphysics.interfaces.impact import create_fourier_coefficients  N_COEF = 20  fcoefs1 = create_fourier_coefficients(Z, BZ, n= N_COEF) In\u00a0[7]: Copied! <pre>from impact.fieldmaps import run_RFcoef\n\nres = run_RFcoef(Z, BZ, n_coef=N_COEF, exe=\"$HOME/Code/GitHub/IMPACT-T/utilities/RFcoeflcls\")\n\nrfdatax = res['rfdatax'] \nrfdatax2 = res['rfdatax2']\nrfdataout = res['rfdata.out']\nrfdatax, len(rfdatax2)\n</pre> from impact.fieldmaps import run_RFcoef  res = run_RFcoef(Z, BZ, n_coef=N_COEF, exe=\"$HOME/Code/GitHub/IMPACT-T/utilities/RFcoeflcls\")  rfdatax = res['rfdatax']  rfdatax2 = res['rfdatax2'] rfdataout = res['rfdata.out'] rfdatax, len(rfdatax2) <pre> How many Fourier coeficients you want?\n zdata1:  -0.23999999999999999       0.23995199519999999     \n The RF data number is:         9999  0.47995199519999998       -2.4002400000000534E-005   4.8004800480096016E-005\n input # of data points:\n input shift length:\n</pre> Out[7]: <pre>(array([ 5.37408637e-01,  4.05535817e-01,  1.27428326e-04,  2.04368096e-01,\n         1.28433969e-04,  8.81722122e-02,  8.31170001e-05,  2.98891171e-02,\n         3.75673083e-05,  8.09723374e-03,  1.27216574e-05, -3.47962386e-04,\n        -6.56022492e-07, -1.50641866e-03, -3.31345941e-06, -1.68446446e-03,\n        -4.23437262e-06, -7.49162506e-04, -2.11864121e-06, -5.22801726e-04,\n        -1.64275880e-06, -3.05095652e-05, -1.05460771e-07, -8.13168638e-05,\n        -3.06613843e-07,  1.04233246e-04,  4.25776634e-07, -2.26873992e-05,\n        -9.97976567e-08,  7.35393832e-05,  3.46610208e-07, -3.22653974e-05,\n        -1.62208998e-07,  4.16143748e-05,  2.22287865e-07, -3.42199360e-05,\n        -1.93540515e-07,  2.86493967e-05,  1.71035273e-07]),\n 10000)</pre> In\u00a0[8]: Copied! <pre>from pmd_beamphysics.interfaces.impact import fourier_field_reconsruction\n</pre> from pmd_beamphysics.interfaces.impact import fourier_field_reconsruction In\u00a0[9]: Copied! <pre>@np.vectorize\ndef f0(z):\n    return fourier_field_reconsruction(z, rfdatax, z0=Z.min(), zlen=L)\n    \nrBZ0 = f0(Z)\nerrx = rfdataout[:,1] - BZ\nerr0 = (rBZ0 - BZ)\n    \nfig, ax = plt.subplots()    \n#ax.plot(rBZ0, label='reconstructed')\nax.plot(errx, label='rfdata.out')\nax.plot(err0, '--', label='Python on rfdatax')\nax.legend()\nax.set_ylabel('reconstruction error')\n</pre> @np.vectorize def f0(z):     return fourier_field_reconsruction(z, rfdatax, z0=Z.min(), zlen=L)      rBZ0 = f0(Z) errx = rfdataout[:,1] - BZ err0 = (rBZ0 - BZ)      fig, ax = plt.subplots()     #ax.plot(rBZ0, label='reconstructed') ax.plot(errx, label='rfdata.out') ax.plot(err0, '--', label='Python on rfdatax') ax.legend() ax.set_ylabel('reconstruction error') Out[9]: <pre>Text(0, 0.5, 'reconstruction error')</pre> In\u00a0[10]: Copied! <pre>from pmd_beamphysics.interfaces.impact import create_fourier_coefficients_via_fft\n</pre> from pmd_beamphysics.interfaces.impact import create_fourier_coefficients_via_fft In\u00a0[11]: Copied! <pre>fcoefs1 = create_fourier_coefficients_via_fft(BZ, n_coef=N_COEF)\n\n@np.vectorize\ndef f1(z):\n    return fourier_field_reconsruction(z, fcoefs1, z0=Z.min(), zlen=L)\n\nrBZ1 = f1(Z)\nerr1 = rBZ1 - BZ\n\nplt.plot(errx, label='rfdata.out')\nplt.plot(err0, '--', label='Python on rfdatax')\nplt.plot(err1, '--', label='Python on FFT-created coefs')\nplt.legend()\nplt.ylabel('reconstruction error')\n</pre> fcoefs1 = create_fourier_coefficients_via_fft(BZ, n_coef=N_COEF)  @np.vectorize def f1(z):     return fourier_field_reconsruction(z, fcoefs1, z0=Z.min(), zlen=L)  rBZ1 = f1(Z) err1 = rBZ1 - BZ  plt.plot(errx, label='rfdata.out') plt.plot(err0, '--', label='Python on rfdatax') plt.plot(err1, '--', label='Python on FFT-created coefs') plt.legend() plt.ylabel('reconstruction error') Out[11]: <pre>Text(0, 0.5, 'reconstruction error')</pre> In\u00a0[12]: Copied! <pre>from impact import fieldmaps\n?fieldmaps.create_fourier_coefficients\n</pre> from impact import fieldmaps ?fieldmaps.create_fourier_coefficients <pre>Signature: fieldmaps.create_fourier_coefficients(zdata, edata, n=None)\nDocstring:\nLiteral transcription of Ji's routine RFcoeflcls.f90\n\nhttps://github.com/impact-lbl/IMPACT-T/blob/master/utilities/RFcoeflcls.f90\n\nFixes bug with scaling the field by the max or min seen.\n\nVectorized two loops\n\nParameters\n----------\nzdata: ndarray\n    z-coordinates\n\nedata: ndarray\n    field-coordinates\n\nn: int\n    Number of Fourier coefficient to compute.\n    None =&gt; n = len(edata) //2 + 1\n    Default: None\n\nReturns\n-------    \nrfdata: ndarray of float\n    Impact-T style Fourier coefficients\nFile:      ~/Code/mambaforge/envs/lume-impact-dev/lib/python3.9/site-packages/pmd_beamphysics/interfaces/impact.py\nType:      function\n</pre> In\u00a0[13]: Copied! <pre># Get basic placement\nzmin, zmax = Z.min(), Z.max()\nLtot = zmax - zmin\nzmin, zmax, Ltot\n</pre> # Get basic placement zmin, zmax = Z.min(), Z.max() Ltot = zmax - zmin zmin, zmax, Ltot Out[13]: <pre>(-0.24, 0.2399519952, 0.4799519952)</pre> In\u00a0[14]: Copied! <pre># Create a lume-impact style fieldmap and process into flat 1D rfdata\nfmap =  {'info': {'format': 'solrf'},\n    'field': {'Ez': {'z0': 0.0, 'z1': 0.0, 'L': 0.0, 'fourier_coefficients': np.array([0.])},\n               'Bz': {'z0': 0, 'z1': Ltot, 'L': Ltot, 'fourier_coefficients': fcoefs1 }\n             } }\n    \n\nrfdata = fieldmaps.data_from_solrf_fieldmap(fmap)    \nrfdata\n</pre> # Create a lume-impact style fieldmap and process into flat 1D rfdata fmap =  {'info': {'format': 'solrf'},     'field': {'Ez': {'z0': 0.0, 'z1': 0.0, 'L': 0.0, 'fourier_coefficients': np.array([0.])},                'Bz': {'z0': 0, 'z1': Ltot, 'L': Ltot, 'fourier_coefficients': fcoefs1 }              } }       rfdata = fieldmaps.data_from_solrf_fieldmap(fmap)     rfdata Out[14]: <pre>array([ 1.00000000e+00,  0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n        0.00000000e+00,  3.90000000e+01,  0.00000000e+00,  4.79951995e-01,\n        4.79951995e-01,  5.37408637e-01,  4.05535823e-01,  1.27428326e-04,\n        2.04368105e-01,  1.28433972e-04,  8.81722191e-02,  8.31170052e-05,\n        2.98891211e-02,  3.75673126e-05,  8.09723557e-03,  1.27216601e-05,\n       -3.47961770e-04, -6.56021318e-07, -1.50641859e-03, -3.31345921e-06,\n       -1.68446459e-03, -4.23437286e-06, -7.49162657e-04, -2.11864160e-06,\n       -5.22801825e-04, -1.64275909e-06, -3.05096309e-05, -1.05460998e-07,\n       -8.13168795e-05, -3.06613895e-07,  1.04233233e-04,  4.25776572e-07,\n       -2.26873865e-05, -9.97975973e-08,  7.35393794e-05,  3.46610182e-07,\n       -3.22653834e-05, -1.62208922e-07,  4.16143681e-05,  2.22287823e-07,\n       -3.42199254e-05, -1.93540450e-07,  2.86493873e-05,  1.71035211e-07])</pre> In\u00a0[15]: Copied! <pre># This simply writes 'data' this to a file\nfieldmaps.write_fieldmap('templates/solenoid/rfdata666', fmap)\n</pre> # This simply writes 'data' this to a file fieldmaps.write_fieldmap('templates/solenoid/rfdata666', fmap) In\u00a0[16]: Copied! <pre>zcenter = 0.24653 # Intended center\n\nele = {'description': 'name:SOL1B',\n 'L': Ltot,\n 'type': 'solrf',\n 'zedge': zcenter + zmin,\n 'rf_field_scale': 0.0,\n 'rf_frequency': 0.0,\n 'theta0_deg': 0.0,\n 'filename': 'rfdata666',\n 'radius': 0.15,\n 'x_offset': 0.0,\n 'y_offset': 0.0,\n 'x_rotation': 0.0,\n 'y_rotation': 0.0,\n 'z_rotation': 0.0,\n 'solenoid_field_scale': 0.057,\n 'name': 'SOL1'}\nele\n</pre> zcenter = 0.24653 # Intended center  ele = {'description': 'name:SOL1B',  'L': Ltot,  'type': 'solrf',  'zedge': zcenter + zmin,  'rf_field_scale': 0.0,  'rf_frequency': 0.0,  'theta0_deg': 0.0,  'filename': 'rfdata666',  'radius': 0.15,  'x_offset': 0.0,  'y_offset': 0.0,  'x_rotation': 0.0,  'y_rotation': 0.0,  'z_rotation': 0.0,  'solenoid_field_scale': 0.057,  'name': 'SOL1'} ele Out[16]: <pre>{'description': 'name:SOL1B',\n 'L': 0.4799519952,\n 'type': 'solrf',\n 'zedge': 0.006530000000000008,\n 'rf_field_scale': 0.0,\n 'rf_frequency': 0.0,\n 'theta0_deg': 0.0,\n 'filename': 'rfdata666',\n 'radius': 0.15,\n 'x_offset': 0.0,\n 'y_offset': 0.0,\n 'x_rotation': 0.0,\n 'y_rotation': 0.0,\n 'z_rotation': 0.0,\n 'solenoid_field_scale': 0.057,\n 'name': 'SOL1'}</pre> In\u00a0[17]: Copied! <pre>import impact\n# This is the line to add to ImpactT.in\nimpact.lattice.ele_line(ele)\n</pre> import impact # This is the line to add to ImpactT.in impact.lattice.ele_line(ele) Out[17]: <pre>'0.4799519952 0 0 105 0.006530000000000008 0.0 0.0 0.0 666 0.15 0.0 0.0 0.0 0.0 0.0 0.057 /!name:SOL1'</pre> In\u00a0[18]: Copied! <pre>from pmd_beamphysics.fields.expansion import fft_derivative_array, spline_derivative_array\nfrom impact.fieldmaps import run_RFcoef\n\n\nfrom numpy import sqrt, pi, exp\ndef gaussian_derivatives(z):\n    f0 =  1/sqrt(2*pi) *exp(- z**2 / 2)    \n    return np.array([1* f0,\n                     (-z) * f0, \n                     (-1 + z**2) * f0, \n                     (3*z - z**3)* f0]).T\n\nZZ = np.linspace(-6, 6, 1000)\nDZ = np.diff(ZZ)[0]\n\nAFZ = gaussian_derivatives(ZZ)\nAFZ /= AFZ[:,0].max() # Normalize for comparisons\n\nFZ = AFZ[:,0]\n\nN_COEF = 30\nrfdatax2 = run_RFcoef(ZZ, FZ, n_coef=N_COEF, exe=\"$HOME/Code/GitHub/IMPACT-T/utilities/RFcoeflcls\")['rfdatax2'][1:]\nmyrfdatax2 = fft_derivative_array(FZ, ncoef = N_COEF, dz=DZ)\n\nmyrfdatax2_spline = spline_derivative_array(ZZ, FZ)\n\n\nORDER = 0\nplt.plot(abs(  rfdatax2[:,ORDER] - AFZ[:, ORDER]), label='Fortran error')#\nplt.plot(abs(myrfdatax2[:,ORDER] - AFZ[:, ORDER]), '--', label='Python error, FFT')#\nplt.plot(abs(myrfdatax2_spline[:,ORDER] - AFZ[:, ORDER]), '--', label='Python error, Spline')#\nplt.legend()\nplt.yscale('log')\n\n\nrfdatax2.shape, myrfdatax2.shape\n</pre> from pmd_beamphysics.fields.expansion import fft_derivative_array, spline_derivative_array from impact.fieldmaps import run_RFcoef   from numpy import sqrt, pi, exp def gaussian_derivatives(z):     f0 =  1/sqrt(2*pi) *exp(- z**2 / 2)         return np.array([1* f0,                      (-z) * f0,                       (-1 + z**2) * f0,                       (3*z - z**3)* f0]).T  ZZ = np.linspace(-6, 6, 1000) DZ = np.diff(ZZ)[0]  AFZ = gaussian_derivatives(ZZ) AFZ /= AFZ[:,0].max() # Normalize for comparisons  FZ = AFZ[:,0]  N_COEF = 30 rfdatax2 = run_RFcoef(ZZ, FZ, n_coef=N_COEF, exe=\"$HOME/Code/GitHub/IMPACT-T/utilities/RFcoeflcls\")['rfdatax2'][1:] myrfdatax2 = fft_derivative_array(FZ, ncoef = N_COEF, dz=DZ)  myrfdatax2_spline = spline_derivative_array(ZZ, FZ)   ORDER = 0 plt.plot(abs(  rfdatax2[:,ORDER] - AFZ[:, ORDER]), label='Fortran error')# plt.plot(abs(myrfdatax2[:,ORDER] - AFZ[:, ORDER]), '--', label='Python error, FFT')# plt.plot(abs(myrfdatax2_spline[:,ORDER] - AFZ[:, ORDER]), '--', label='Python error, Spline')# plt.legend() plt.yscale('log')   rfdatax2.shape, myrfdatax2.shape <pre> How many Fourier coeficients you want?\n zdata1:   -6.0000000000000000        6.0000000000000000     \n The RF data number is:         1000   12.000000000000000        0.0000000000000000        1.2012012012012012E-002\n input # of data points:\n input shift length:\n</pre> Out[18]: <pre>((1000, 4), (1000, 4))</pre> In\u00a0[19]: Copied! <pre>def compare(order):\n    fig, ax = plt.subplots()\n    ax2 = ax.twinx()\n    \n    f0 = AFZ[:,order]\n    f1 = rfdatax2[:,order]\n    f2 = myrfdatax2[:,order]\n    f3 = myrfdatax2_spline[:,order]\n    \n    err1 = abs((f1-f0)/f0)\n    err2 = abs((f2-f0)/f0)\n    err3 = abs((f3-f0)/f0)\n    ax2.plot( f0   , label='Reference', color='black')#\n    #ax2.plot( f1   , label='Fortran')#\n    #ax2.plot( f2, '--', label='Python, FFT')#\n    #ax2.plot( f3, '--', label='Python, Spline')#\n    #ax2.legend(loc='upper right')\n    \n    ax.set_title(f'Gaussian derivative, order {order}')\n    ax.set_ylabel('relative error')\n    ax2.set_ylabel('True function')\n    ax.plot( err1   , label='Fortran RFcoefs')#\n    ax.plot( err2, '--', label='Python, FFT')#\n    ax.plot( err3, '--', label='Python, Spline')#\n    ax.set_yscale('log')\n    ax.legend(loc='upper left')\n    \ncompare(0)\n</pre> def compare(order):     fig, ax = plt.subplots()     ax2 = ax.twinx()          f0 = AFZ[:,order]     f1 = rfdatax2[:,order]     f2 = myrfdatax2[:,order]     f3 = myrfdatax2_spline[:,order]          err1 = abs((f1-f0)/f0)     err2 = abs((f2-f0)/f0)     err3 = abs((f3-f0)/f0)     ax2.plot( f0   , label='Reference', color='black')#     #ax2.plot( f1   , label='Fortran')#     #ax2.plot( f2, '--', label='Python, FFT')#     #ax2.plot( f3, '--', label='Python, Spline')#     #ax2.legend(loc='upper right')          ax.set_title(f'Gaussian derivative, order {order}')     ax.set_ylabel('relative error')     ax2.set_ylabel('True function')     ax.plot( err1   , label='Fortran RFcoefs')#     ax.plot( err2, '--', label='Python, FFT')#     ax.plot( err3, '--', label='Python, Spline')#     ax.set_yscale('log')     ax.legend(loc='upper left')      compare(0)     In\u00a0[20]: Copied! <pre>compare(1)\n</pre> compare(1)  In\u00a0[21]: Copied! <pre>compare(2)\n</pre> compare(2)  In\u00a0[22]: Copied! <pre>compare(3)\n</pre> compare(3)"},{"location":"examples/solrf_fieldmaps/#solrf-fieldmaps","title":"solrf fieldmaps\u00b6","text":"<p>Create solrf fieldmaps from on-axis data</p>"},{"location":"examples/solrf_fieldmaps/#original-data","title":"Original data\u00b6","text":""},{"location":"examples/solrf_fieldmaps/#rfcoef-fortran-program","title":"RFcoef Fortran program\u00b6","text":""},{"location":"examples/solrf_fieldmaps/#reconstruction","title":"Reconstruction\u00b6","text":"<p>The coefficients in these files are defined so that a field $E$ can be reconstructed at position $z$ as</p> <p>$ E(z) = A_0 + \\sum_{n=1}^{N} A_n \\cos\\left(2\\pi n \\frac{z}{L} \\right) + B_n \\sin\\left(2\\pi n \\frac{z}{L} \\right)$</p> <p>where $z~\\epsilon~[-L/2, L/2]$</p> <p>This function will handle this efficiently.</p>"},{"location":"examples/solrf_fieldmaps/#create-coefficients-via-fft","title":"Create coefficients via FFT\u00b6","text":""},{"location":"examples/solrf_fieldmaps/#create-lume-impact-style-fieldmap","title":"Create LUME-Impact style fieldmap\u00b6","text":""},{"location":"examples/solrf_fieldmaps/#new-style-solrf-field","title":"New-style solRF field\u00b6","text":""},{"location":"examples/elements/3d_field/","title":"3d field","text":"In\u00a0[1]: Copied! <pre>%pylab --no-import-all inline\n%config InlineBackend.figure_format = 'retina'\n</pre> %pylab --no-import-all inline %config InlineBackend.figure_format = 'retina' <pre>%pylab is deprecated, use %matplotlib inline and import the required libraries.\nPopulating the interactive namespace from numpy and matplotlib\n</pre> In\u00a0[2]: Copied! <pre>from impact import Impact\nimport os\n\n# plotting modules\nfrom impact.plotting import layout_plot\nfrom bokeh.plotting import output_notebook\nfrom bokeh.plotting import show\noutput_notebook(hide_banner=True)\n</pre> from impact import Impact import os  # plotting modules from impact.plotting import layout_plot from bokeh.plotting import output_notebook from bokeh.plotting import show output_notebook(hide_banner=True) In\u00a0[3]: Copied! <pre># Make Impact object\nifile = '../templates/3dfield/ImpactT.in'\nI = Impact(ifile, verbose=True)\n</pre> # Make Impact object ifile = '../templates/3dfield/ImpactT.in' I = Impact(ifile, verbose=True) <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpgvf115pb\n</pre> In\u00a0[4]: Copied! <pre># Show a MAD-style printout of each element in the lattice\nI.print_lattice()\n</pre> # Show a MAD-style printout of each element in the lattice I.print_lattice() <pre>SC_2D_to_3D: rotationally_symmetric_to_3d, description=name:SC_2D_to_3D, s=-0.1\n!steering\n!0.0 1 1 -1 0.10 1.0 0.10 0.000 0.0 0.000 0.0 /\n!3D rf field\nrf_field: emfield_cartesian, description=name:rf_field, L=0.0866528, zedge=0.0,\n      rf_field_scale=-111.11, rf_frequency=11424000000.0, theta0_deg=292.0,\n      filename=1T1.T7, radius=0.002, s=0.0866528\n!solenoid field\nsol: solrf, description=name:sol, L=0.2, zedge=0.0, rf_field_scale=0.0, rf_frequency=0.0,\n      theta0_deg=0.0, filename=rfdata102, radius=0.01, x_offset=0.0, y_offset=0.0,\n      x_rotation=0.0, y_rotation=0.0, z_rotation=0.0, solenoid_field_scale=0.5658,\n      s=0.2\n!change time step size\nchange_dt: change_timestep, description=name:change_dt, dt=5e-13, s=0.2\ndrift_1: drift, description=, L=0.34, zedge=0.2, radius=0.15, s=0.54\n!terminate the simulation\n!0.0 1 1 -99 0.55 1.0 0.55 /\n\n</pre> In\u00a0[5]: Copied! <pre># Note that emfield_cartesian plotting is not yet implemented!\nI.plot(figsize=(9,6))\n</pre> # Note that emfield_cartesian plotting is not yet implemented! I.plot(figsize=(9,6)) In\u00a0[6]: Copied! <pre>layout = layout_plot(I.input['lattice'], plot_height=300, plot_width=600)\nshow(layout)\n</pre> layout = layout_plot(I.input['lattice'], plot_height=300, plot_width=600) show(layout) In\u00a0[7]: Copied! <pre>I.run()\n</pre> I.run() <pre>Running Impact-T in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpgvf115pb\n/Users/chrisonian/Code/Impact/IMPACT-T/build/ImpactTexe\n !-----------------------------------------------------------\n ! IMPACT-T Parallel Beam Dynamics Tracking Code: 2.1 beta version\n ! Copyright of The Regents of the University of California\n !-----------------------------------------------------------\n nblem:            5           5\n pass setting up lattice...\n check randomness:            0  0.30440529327431320     \n           0  0.35048827465642352     \n pass generating initial distribution...\n i,t,&lt;z&gt;:            1   0.0000000000000000        0.0000000000000000     \n zmin,zmax:    0.0000000000000000       -6.3011668443823237E-008\n i,t,&lt;z&gt;:            2   1.1999999999999999E-013  -3.5680300551640316E-006\n zmin,zmax:    0.0000000000000000        4.3737291836104336E-008\n name: rfdataxrfdataxxrfdata102\n time:    0.0000000000000000, elapsed: 109.04351091384888Finished.386, elapsed: 109.01872682571411098656\nLoaded fort 30 : Fourth root of the fourth moments of the beam distribution\nLoaded fort 25 : RMS Y information\nLoaded fort 24 : RMS X information\nLoaded fort 26 : RMS Z information\nLoaded fort 28 : Load balance and loss diagnostics\nLoaded fort 29 : Cube root of third moments of the beam distribution\nLoaded fort 18 : Time and energy\nLoaded fort 27 : Max amplitude information\nLoaded fort 70 : Slice information of the final distribution\nLoaded fort 60 : Slice information of the initial distribution\nLoading particles\nLoaded fort 40 : initial particle distribution at t = 0\nLoaded fort 50 : final particle distribution projected to the centroid location of the bunch\nConverting z to t according to cathode_kinetic_energy_ref = 1.0 eV\nConverted initial_particles to ParticleGroup\nConverted final_particles to ParticleGroup\n</pre> In\u00a0[8]: Copied! <pre>I.plot(figsize=(9,6))\n</pre> I.plot(figsize=(9,6)) In\u00a0[9]: Copied! <pre>I.plot('norm_emit_x', y2='mean_kinetic_energy', figsize=(9,6))\n</pre> I.plot('norm_emit_x', y2='mean_kinetic_energy', figsize=(9,6)) In\u00a0[10]: Copied! <pre>I.particles['final_particles'].plot('z', 'x')\n</pre> I.particles['final_particles'].plot('z', 'x') In\u00a0[11]: Copied! <pre>I.particles['final_particles'].plot('z', 'pz')\n</pre> I.particles['final_particles'].plot('z', 'pz')"},{"location":"examples/elements/3d_field/#cartesian-3d-field-example","title":"Cartesian 3D Field Example\u00b6","text":""},{"location":"examples/elements/apex_gun/","title":"APEX Gun, IMPACT-T","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre># Nicer plotting\nimport matplotlib\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nmatplotlib.rcParams['figure.figsize'] = (8,4)\n</pre> # Nicer plotting import matplotlib %matplotlib inline %config InlineBackend.figure_format = 'retina' matplotlib.rcParams['figure.figsize'] = (8,4) In\u00a0[3]: Copied! <pre>from impact import Impact\nfrom distgen import Generator\n\nimport matplotlib.pyplot as plt\nimport os\n</pre> from impact import Impact from distgen import Generator  import matplotlib.pyplot as plt import os In\u00a0[4]: Copied! <pre>IMPACT_IN = '../templates/apex_gun/ImpactT.in'\nDISTGEN_IN = '../templates/apex_gun/distgen.yaml'\nos.path.exists(IMPACT_IN)\n</pre> IMPACT_IN = '../templates/apex_gun/ImpactT.in' DISTGEN_IN = '../templates/apex_gun/distgen.yaml' os.path.exists(IMPACT_IN) Out[4]: <pre>True</pre> In\u00a0[5]: Copied! <pre>G = Generator(DISTGEN_IN)\nG['n_particle'] = 10000\n\nG.run()\nP0 = G.particles\nfactor = 2\nP0.x *= factor  \nP0.y *= 1/factor \nP0.plot('x', 'y')\n</pre> G = Generator(DISTGEN_IN) G['n_particle'] = 10000  G.run() P0 = G.particles factor = 2 P0.x *= factor   P0.y *= 1/factor  P0.plot('x', 'y') In\u00a0[6]: Copied! <pre>P0['charge']\n</pre> P0['charge'] Out[6]: <pre>1.0000000000000004e-10</pre> In\u00a0[7]: Copied! <pre># Make Impact object\nI = Impact(IMPACT_IN)\n</pre> # Make Impact object I = Impact(IMPACT_IN) In\u00a0[8]: Copied! <pre>I.track1()\nI.plot('mean_kinetic_energy')\n</pre> I.track1() I.plot('mean_kinetic_energy') In\u00a0[9]: Copied! <pre>I.initial_particles = P0\n\n# Change some things\nI.header['Nx'] = 32\nI.header['Ny'] = 32\nI.header['Nz'] = 32\nI.header['Dt'] = 1e-13\n\nI.total_charge = P0['charge']\n#I.total_charge = 0\n\n# Other switches\nI.timeout = 1000\n\n# Change stop location\nI.stop = 0.15\n\n# Switches for MPI\nI.numprocs=8\n</pre> I.initial_particles = P0  # Change some things I.header['Nx'] = 32 I.header['Ny'] = 32 I.header['Nz'] = 32 I.header['Dt'] = 1e-13  I.total_charge = P0['charge'] #I.total_charge = 0  # Other switches I.timeout = 1000  # Change stop location I.stop = 0.15  # Switches for MPI I.numprocs=8 In\u00a0[10]: Copied! <pre>%%time\nI.run()\nprint(I)\n</pre> %%time I.run() print(I) <pre>================ Impact-T Summary ================    \n10000 particles\n1 bunch of electrons\ntotal charge: 100.00000000000004 pC\nDistribution type: read\nCathode start at z = 0 m\n   emission time: 5.064308571009823e-11 s\n   image charges neglected after z = 0.02 m\nProcessor domain: 2 x 4 = 8 CPUs\nSpace charge grid: 32 x 32 x 32\nMaximum time steps: 1000000\nReference Frequency: 1300000000.0 Hz\nInitial reference time: -2.5403549006681165e-11 s\nSimulation starting from the beginning\n=================================================\nImpact-T finished in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpiqnskbed\nCPU times: user 312 ms, sys: 169 ms, total: 481 ms\nWall time: 35.2 s\n</pre> In\u00a0[11]: Copied! <pre># Particles are automatically parsed in to openpmd-beamphysics ParticleGroup objects\nI.output['particles']\n</pre> # Particles are automatically parsed in to openpmd-beamphysics ParticleGroup objects I.output['particles'] Out[11]: <pre>{'initial_particles': &lt;ParticleGroup with 10000 particles at 0x1617fbac0&gt;,\n 'final_particles': &lt;ParticleGroup with 10000 particles at 0x1617fb7c0&gt;}</pre> In\u00a0[12]: Copied! <pre># Get the final particles, calculate some statistic\nP = I.output['particles']['final_particles']\nP['mean_energy']\n</pre> # Get the final particles, calculate some statistic P = I.output['particles']['final_particles'] P['mean_energy'] Out[12]: <pre>1269378.474966081</pre> In\u00a0[13]: Copied! <pre># Show the units\nP.units('mean_energy')\n</pre> # Show the units P.units('mean_energy') Out[13]: <pre>pmd_unit('eV', 1.602176634e-19, (2, 1, -2, 0, 0, 0, 0))</pre> In\u00a0[14]: Copied! <pre>P.plot('z', 'pz')\n</pre> P.plot('z', 'pz') In\u00a0[15]: Copied! <pre># Impact's own calculated statistics can be retieved\nlen(I.stat('norm_emit_x')), I.stat('norm_emit_x')[-1]\n</pre> # Impact's own calculated statistics can be retieved len(I.stat('norm_emit_x')), I.stat('norm_emit_x')[-1] Out[15]: <pre>(1242, 1.479724e-05)</pre> In\u00a0[16]: Copied! <pre># Stats can also be computed from the particles. For example:\nI.particles['final_particles']['norm_emit_x']\n</pre> # Stats can also be computed from the particles. For example: I.particles['final_particles']['norm_emit_x'] Out[16]: <pre>1.4798894808846349e-05</pre> In\u00a0[17]: Copied! <pre># Compare these. \nkey1 = 'mean_z'\nkey2 = 'sigma_x'\nunits1 = str(I.units(key1))\nunits2 = str(I.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(I.stat(key1), I.stat(key2))\nplt.scatter(\n    [I.particles[name][key1] for name in I.particles], \n    [I.particles[name][key2] for name in I.particles], color='red')\n</pre> # Compare these.  key1 = 'mean_z' key2 = 'sigma_x' units1 = str(I.units(key1)) units2 = str(I.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(I.stat(key1), I.stat(key2)) plt.scatter(     [I.particles[name][key1] for name in I.particles],      [I.particles[name][key2] for name in I.particles], color='red') Out[17]: <pre>&lt;matplotlib.collections.PathCollection at 0x1622faa90&gt;</pre>"},{"location":"examples/elements/apex_gun/#apex-gun-impact-t","title":"APEX Gun, IMPACT-T\u00b6","text":""},{"location":"examples/elements/apex_gun/#particles","title":"Particles\u00b6","text":""},{"location":"examples/elements/apex_gun/#stats","title":"Stats\u00b6","text":""},{"location":"examples/elements/awa_flatbeam/","title":"AWA Flat Beams","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from impact import Impact\n\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n</pre> from impact import Impact  import matplotlib.pyplot as plt %config InlineBackend.figure_format = 'retina' In\u00a0[3]: Copied! <pre>I = Impact('../templates/awa_flatbeam/ImpactT.in')\nI.plot(figsize=(16,4), include_labels=True, include_field=True)\n</pre> I = Impact('../templates/awa_flatbeam/ImpactT.in') I.plot(figsize=(16,4), include_labels=True, include_field=True) In\u00a0[4]: Copied! <pre># Switches for MPI\nI.use_mpi=True\nI.numprocs = 4\nI.run()\n</pre> # Switches for MPI I.use_mpi=True I.numprocs = 4 I.run() In\u00a0[5]: Copied! <pre>I.plot(['norm_emit_x', 'norm_emit_y'], y2='mean_kinetic_energy', xlim=(0,16),figsize=(16,6))\n</pre> I.plot(['norm_emit_x', 'norm_emit_y'], y2='mean_kinetic_energy', xlim=(0,16),figsize=(16,6)) In\u00a0[6]: Copied! <pre>I.plot(['sigma_x', 'sigma_y', 'sigma_z'], y2='mean_kinetic_energy', xlim=(0,16), ylim=(0,.01), figsize=(16,6))\n</pre> I.plot(['sigma_x', 'sigma_y', 'sigma_z'], y2='mean_kinetic_energy', xlim=(0,16), ylim=(0,.01), figsize=(16,6)) In\u00a0[7]: Copied! <pre>I.plot('Ez', y2='Bz', figsize=(16,6))\nplt.title('Fields seen by the bunch centroid');\n</pre> I.plot('Ez', y2='Bz', figsize=(16,6)) plt.title('Fields seen by the bunch centroid'); In\u00a0[8]: Copied! <pre>Pi = I.particles['initial_particles']\nPi.plot('t', 'pz')\n</pre> Pi = I.particles['initial_particles'] Pi.plot('t', 'pz') In\u00a0[9]: Copied! <pre>Pf = I.particles['final_particles']\n</pre> Pf = I.particles['final_particles'] In\u00a0[10]: Copied! <pre>Pf.plot('x', 'y')\n</pre> Pf.plot('x', 'y') In\u00a0[11]: Copied! <pre>Pf.plot('delta_z', 'pz')\n</pre> Pf.plot('delta_z', 'pz') In\u00a0[12]: Copied! <pre>Pf.plot('x_bar', 'px_bar')\n</pre> Pf.plot('x_bar', 'px_bar')"},{"location":"examples/elements/awa_flatbeam/#awa-flat-beams","title":"AWA Flat Beams\u00b6","text":"<p>Example courtesy of T. Xu</p>"},{"location":"examples/elements/dipole/","title":"Dipole Example","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n\nimport numpy as np\nimport os\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n%config InlineBackend.figure_format='retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2  import numpy as np import os  import matplotlib.pyplot as plt %matplotlib inline %config InlineBackend.figure_format='retina' In\u00a0[18]: Copied! <pre># locate the drift template\nfrom impact import Impact\n\nifile = '../templates/dipole/ImpactT.in'\nos.path.exists(ifile)\n</pre> # locate the drift template from impact import Impact  ifile = '../templates/dipole/ImpactT.in' os.path.exists(ifile) Out[18]: <pre>True</pre> In\u00a0[26]: Copied! <pre>I = Impact(ifile)\nI.header['Bcurr'] = 0\n#I.total_charge=1e-12\n#I.stop = 2.5\nI.run()\n\nc_light = 299792458. # m/s\nI.particles['final_particles']['mean_t'] * c_light, I.particles['final_particles']['mean_z']\n</pre> I = Impact(ifile) I.header['Bcurr'] = 0 #I.total_charge=1e-12 #I.stop = 2.5 I.run()  c_light = 299792458. # m/s I.particles['final_particles']['mean_t'] * c_light, I.particles['final_particles']['mean_z'] Out[26]: <pre>(2.6999993236360877, 2.700000061274841)</pre> In\u00a0[27]: Copied! <pre>I.stat('mean_z')\n</pre> I.stat('mean_z') Out[27]: <pre>array([1.2288994e-06, 1.4990850e-02, 2.9980471e-02, 4.4970092e-02,\n       5.9959713e-02, 7.4949334e-02, 8.9938955e-02, 1.0492858e-01,\n       1.1991820e-01, 1.3490782e-01, 1.4989744e-01, 1.6488706e-01,\n       1.7987668e-01, 1.9486630e-01, 2.0985592e-01, 2.2484554e-01,\n       2.3983516e-01, 2.5482478e-01, 2.6981441e-01, 2.8480403e-01,\n       2.9979365e-01, 3.1478327e-01, 3.2977289e-01, 3.4476251e-01,\n       3.5975213e-01, 3.7474175e-01, 3.8973137e-01, 4.0472099e-01,\n       4.1971062e-01, 4.3470024e-01, 4.4968986e-01, 4.6467948e-01,\n       4.7966910e-01, 4.9465872e-01])</pre> In\u00a0[28]: Copied! <pre>I.plot('mean_x')\n</pre> I.plot('mean_x') In\u00a0[22]: Copied! <pre>!cat {I.path}/ImpactT.in\n</pre> !cat {I.path}/ImpactT.in <pre>! Impact-T input file\n!Npcol Nprow\n1 1\n!Dt Ntstep Nbunch\n1e-11 10000000 1\n!Dim Np Flagmap Flagerr Flagdiag Flagimg Zimage\n6 10000 1 0 2 0 0.02\n!Nx Ny Nz Flagbc Xrad Yrad Perdlen\n32 32 32 1 0.015 0.015 45.0\n!Flagdist Rstartflg Flagsbstp Nemission Temission\n2 0 0 0 0.0\n!sigx(m) sigpx muxpx xscale pxscale xmu1(m) xmu2\n1e-05 0.0005 0.0 1.0 1.0 0.0 0.0\n!sigy(m) sigpy muxpy yscale pyscale ymu1(m) ymu2\n1e-05 0.0 0.0 1.0 1.0 0.0 0.0\n!sigz(m) sigpz muxpz zscale pzscale zmu1(m) zmu2\n0.0003 0.0 0.0 1.0 1.0 0.0 1956.9511835591836\n!Bcurr Bkenergy Bmass Bcharge Bfreq Tini\n0 1.0 510998.95 -1.0 1000000000.0 0.0\n!=================== LATTICE ===================\n0 0 0 -8 0.0 -1 -1000.0 /!name:SC_off\n!0.2 0 0 1 0.5 2.98 0.108 0.016 0.0 0.0 0.0 0.0 0.0 /!name:QE04\n2.2 0 0 4 0.5 0.0 -0.33356405164803316 777 0.01 /!name:B1\n!0 1 42 -2 0.0 0.0 3.0 /!name:beam1\n!0 1 43 -2 0.0 0.0 3.1 /!name:beam2\n0 0 0 -99 2.5 0.0 2.5 /!name:stop_1\n</pre> In\u00a0[23]: Copied! <pre># calculate gamma*beta\nmec2 = 0.51099895000e6 # eV\nEtot = 1e9 #eV\ngamma = Etot/mec2\nGB = np.sqrt(gamma**2 -1)\nGB\n</pre> # calculate gamma*beta mec2 = 0.51099895000e6 # eV Etot = 1e9 #eV gamma = Etot/mec2 GB = np.sqrt(gamma**2 -1) GB  Out[23]: <pre>1956.9509280596917</pre> In\u00a0[24]: Copied! <pre>from impact.elements.dipole import new_dipole_fieldmap_data, dipole_fieldmap_lines\n#THETA = 30*np.pi/180\nMYL = 2.1\n#MYG = THETA/MYL\nGAMMA=1e9/mec2\nMYG = 1/10\n#GAMMA = 1e9/mec2\nTHETA = MYG*MYL\n\n\nGB = np.sqrt(GAMMA**2 -1)\n\nDMAP = new_dipole_fieldmap_data(L=MYL, g=MYG, gamma_ref=GAMMA, e1=0, e2=0,  half_gap=0.01, fint=0.5, csr_on=True)\n\n# make fieldmap\nprint(dipole_fieldmap_lines(DMAP, '../templates/dipole/rfdata777'))\n</pre> from impact.elements.dipole import new_dipole_fieldmap_data, dipole_fieldmap_lines #THETA = 30*np.pi/180 MYL = 2.1 #MYG = THETA/MYL GAMMA=1e9/mec2 MYG = 1/10 #GAMMA = 1e9/mec2 THETA = MYG*MYL   GB = np.sqrt(GAMMA**2 -1)  DMAP = new_dipole_fieldmap_data(L=MYL, g=MYG, gamma_ref=GAMMA, e1=0, e2=0,  half_gap=0.01, fint=0.5, csr_on=True)  # make fieldmap print(dipole_fieldmap_lines(DMAP, '../templates/dipole/rfdata777')) <pre>1\n1956.9511835591834\n0.0\n0.0\n0.0\n0.03\n0.2131424443826454\n2.131087505316458\n0.2131424443826454\n2.1617613823364508\n0.03\n0.03\n0\n2.0\n0\n0\n0\n0\n0\n0\n0.015\n2.145\n</pre> In\u00a0[25]: Copied! <pre>DMAP\n</pre> DMAP Out[25]: <pre>{'csr_on': 1,\n 'gamma_ref': 1956.9511835591834,\n 'entrance_s': 0.015,\n 'exit_s': 2.145,\n 'k1': 0.0,\n 'k2': 0.0,\n 'b1': 0.0,\n 'b2': 0.03,\n 'k3': 0.2131424443826454,\n 'k4': 0.2131424443826454,\n 'b3': 2.131087505316458,\n 'b4': 2.1617613823364508,\n 'c1': 0,\n 'c2': 2.0,\n 'c3': 0,\n 'c4': 0,\n 'c5': 0,\n 'c6': 0,\n 'c7': 0,\n 'c8': 0,\n 'w1': 0.03,\n 'w2': 0.03}</pre> In\u00a0[\u00a0]: Copied! <pre>I = Impact(ifile)\n\nc_light=299792458.\n\nI.header['Np'] = 1000000\nI.header['Nx'] = 32\nI.header['Ny'] = 32\nI.header['Nz'] = 256\nI.header['Dt'] = 0.01/c_light\n#I.header['Ntstep'] = 200\n#I.input['fieldmaps']['rfdata777']['data'][0] = 1 # Turn on/off CSR\n#I.input['fieldmaps']['rfdata777']['data'][-1] = 1 # exit_s\nI.ele['B1']['L'] = MYL\n\n#I.header['zmu2'] = GB\nI.stop = 3.1\nI.total_charge = 1e-12\nI.verbose=True\nI.write_input()\nprint(I)\n</pre> I = Impact(ifile)  c_light=299792458.  I.header['Np'] = 1000000 I.header['Nx'] = 32 I.header['Ny'] = 32 I.header['Nz'] = 256 I.header['Dt'] = 0.01/c_light #I.header['Ntstep'] = 200 #I.input['fieldmaps']['rfdata777']['data'][0] = 1 # Turn on/off CSR #I.input['fieldmaps']['rfdata777']['data'][-1] = 1 # exit_s I.ele['B1']['L'] = MYL  #I.header['zmu2'] = GB I.stop = 3.1 I.total_charge = 1e-12 I.verbose=True I.write_input() print(I)  In\u00a0[\u00a0]: Copied! <pre>!cat {I.path}/ImpactT.in\n</pre> !cat {I.path}/ImpactT.in In\u00a0[\u00a0]: Copied! <pre>%%time\nI.run()\n</pre> %%time I.run() In\u00a0[\u00a0]: Copied! <pre>afile1 = I.archive()\n</pre> afile1 = I.archive() In\u00a0[\u00a0]: Copied! <pre>PF = I.particles['final_particles']\nPF['mean_z']\n</pre> PF = I.particles['final_particles'] PF['mean_z'] In\u00a0[\u00a0]: Copied! <pre>P26 = PF.copy()\n</pre> P26 = PF.copy() In\u00a0[\u00a0]: Copied! <pre>PF.plot('delta_z', 'delta_p', bins=100, figsize=(12,8))\n</pre> PF.plot('delta_z', 'delta_p', bins=100, figsize=(12,8)) In\u00a0[\u00a0]: Copied! <pre>P2 = PF.copy()\n</pre> P2 = PF.copy() In\u00a0[\u00a0]: Copied! <pre>P1['mean_z'], P2['mean_z']\n</pre> P1['mean_z'], P2['mean_z'] In\u00a0[\u00a0]: Copied! <pre>k1 = 'min_p'\nP1[k1], P4[k1], P3[k1]\n</pre> k1 = 'min_p' P1[k1], P4[k1], P3[k1] In\u00a0[\u00a0]: Copied! <pre>k1='delta_z'\nk2='p'\nplt.scatter(P1[k1], P1[k2])\nplt.scatter(P2[k1], P2[k2])\n</pre> k1='delta_z' k2='p' plt.scatter(P1[k1], P1[k2]) plt.scatter(P2[k1], P2[k2]) In\u00a0[\u00a0]: Copied! <pre>I.particles['initial_particles'].plot('y', 'py')\n</pre> I.particles['initial_particles'].plot('y', 'py') In\u00a0[\u00a0]: Copied! <pre>from impact.elements import dipole\n</pre> from impact.elements import dipole In\u00a0[\u00a0]: Copied! <pre>dipole.parse_dipole_fieldmap_data\n</pre> dipole.parse_dipole_fieldmap_data In\u00a0[\u00a0]: Copied! <pre>I.ele['B1']\n</pre> I.ele['B1'] In\u00a0[\u00a0]: Copied! <pre>DATA = I.input['fieldmaps'][I.ele['B1']['filename']]['data']\nDMAP = dipole.parse_dipole_fieldmap_data(DATA)\nDMAP\n</pre> DATA = I.input['fieldmaps'][I.ele['B1']['filename']]['data'] DMAP = dipole.parse_dipole_fieldmap_data(DATA) DMAP In\u00a0[\u00a0]: Copied! <pre>I.track1(pz0=1e9)\nI.path\n</pre> I.track1(pz0=1e9) I.path In\u00a0[\u00a0]: Copied! <pre>I.header['Flagdist']\n</pre> I.header['Flagdist'] In\u00a0[\u00a0]: Copied! <pre>dipole.plot_dipole_fieldmap(DMAP, ref_data=I.output['dipole_stats'], g=1/10, L=3.0)\n</pre> dipole.plot_dipole_fieldmap(DMAP, ref_data=I.output['dipole_stats'], g=1/10, L=3.0) In\u00a0[\u00a0]: Copied! <pre>I.input['fieldmaps']['rfdata777']['data'][0] = 1\n</pre> I.input['fieldmaps']['rfdata777']['data'][0] = 1 In\u00a0[\u00a0]: Copied! <pre>I.run()\n</pre> I.run() In\u00a0[\u00a0]: Copied! <pre>%%time\nI1 = I.copy()\nI1.configure()\nI1.stop = 2.5\nI1.verbose=True\nI1.run()\n\nI1.particles['final_particles']['mean_t']*c_light\n</pre> %%time I1 = I.copy() I1.configure() I1.stop = 2.5 I1.verbose=True I1.run()  I1.particles['final_particles']['mean_t']*c_light In\u00a0[\u00a0]: Copied! <pre>!cat {I1.path}/ImpactT.in\n</pre> !cat {I1.path}/ImpactT.in In\u00a0[\u00a0]: Copied! <pre>I2 = I.copy()\nI2.configure()\nI2.stop = 2.6\nI2.verbose=False\nI2.run()\n</pre> I2 = I.copy() I2.configure() I2.stop = 2.6 I2.verbose=False I2.run() In\u00a0[\u00a0]: Copied! <pre>, I2.particles['final_particles']['mean_t']*c_light\n</pre> , I2.particles['final_particles']['mean_t']*c_light In\u00a0[\u00a0]: Copied! <pre>from scipy.constants import physical_constants\n\nmec2 = physical_constants['electron mass energy equivalent in MeV'][0]*1e6\n\nc_light = 299792458. # m/s\n\nr_electron = physical_constants['classical electron radius'][0]\n\ndef W0_calc(rho=10, sigma_z=0.0003, total_charge=1e-12):\n    \n    N = total_charge/1.6e-19\n    \n    return N*r_electron*mec2 / rho**(2/3.) / sigma_z**(4/3.)\n    \nW0 = W0_calc()  \n\nW0\n</pre> from scipy.constants import physical_constants  mec2 = physical_constants['electron mass energy equivalent in MeV'][0]*1e6  c_light = 299792458. # m/s  r_electron = physical_constants['classical electron radius'][0]  def W0_calc(rho=10, sigma_z=0.0003, total_charge=1e-12):          N = total_charge/1.6e-19          return N*r_electron*mec2 / rho**(2/3.) / sigma_z**(4/3.)      W0 = W0_calc()    W0 In\u00a0[\u00a0]: Copied! <pre>#I1 = Impact.from_archive('impact_6bcb411d0efbbf51d6df8096bdc4dd0d.h5') # 2.5 m\n\n#I2 = Impact.from_archive('impact_8abe9fea7069035129b86b72021a3957.h5') # 2.6 m\n\nP1 = I1.particles['final_particles']\nz1 = P1['mean_z']\nP1.z -= z1\n\nP2 = I2.particles['final_particles']\nz2 = P2['mean_z']\nP2.z -= z2\n\nz1, z2\n</pre> #I1 = Impact.from_archive('impact_6bcb411d0efbbf51d6df8096bdc4dd0d.h5') # 2.5 m  #I2 = Impact.from_archive('impact_8abe9fea7069035129b86b72021a3957.h5') # 2.6 m  P1 = I1.particles['final_particles'] z1 = P1['mean_z'] P1.z -= z1  P2 = I2.particles['final_particles'] z2 = P2['mean_z'] P2.z -= z2  z1, z2 In\u00a0[\u00a0]: Copied! <pre>from pmd_beamphysics.statistics import slice_statistics\n?slice_statistics\n</pre> from pmd_beamphysics.statistics import slice_statistics ?slice_statistics In\u00a0[\u00a0]: Copied! <pre>dat1 = slice_statistics(P1, keys=['mean_z', 'mean_energy'])\ndat2 = slice_statistics(P2, keys=['mean_z', 'mean_energy'])\n</pre> dat1 = slice_statistics(P1, keys=['mean_z', 'mean_energy']) dat2 = slice_statistics(P2, keys=['mean_z', 'mean_energy']) In\u00a0[\u00a0]: Copied! <pre>plt.plot(dat1['mean_z'], dat1['mean_energy'])\n</pre> plt.plot(dat1['mean_z'], dat1['mean_energy']) In\u00a0[\u00a0]: Copied! <pre>Z = np.linspace(-6e-4, 6e-4, 100)\nE1 = np.interp(Z, dat1['mean_z'], dat1['mean_energy'])\nE2 = np.interp(Z, dat2['mean_z'], dat2['mean_energy'])\n</pre> Z = np.linspace(-6e-4, 6e-4, 100) E1 = np.interp(Z, dat1['mean_z'], dat1['mean_energy']) E2 = np.interp(Z, dat2['mean_z'], dat2['mean_energy']) In\u00a0[\u00a0]: Copied! <pre>dz = z2-z1\ndz\n</pre>  dz = z2-z1 dz In\u00a0[\u00a0]: Copied! <pre>plt.plot(Z, E1)\nplt.plot(Z, E2)\n</pre> plt.plot(Z, E1) plt.plot(Z, E2) In\u00a0[\u00a0]: Copied! <pre>plt.xlabel('$z/\\sigma_z$')\nplt.ylabel('$dE/dz/W_0$')\nplt.plot(Z/0.0003, (E2-E1)/dz/W0)\n</pre> plt.xlabel('$z/\\sigma_z$') plt.ylabel('$dE/dz/W_0$') plt.plot(Z/0.0003, (E2-E1)/dz/W0) In\u00a0[\u00a0]: Copied! <pre># Mathematica computed\nSSdat = np.loadtxt('../../devel/steadystate_csr_wake.dat').T\nSSz = SSdat[0]\nSSw = SSdat[1]\nplt.plot(SSz, SSw)\n</pre> # Mathematica computed SSdat = np.loadtxt('../../devel/steadystate_csr_wake.dat').T SSz = SSdat[0] SSw = SSdat[1] plt.plot(SSz, SSw) In\u00a0[\u00a0]: Copied! <pre>plt.xlabel('$z/\\sigma_z$')\nplt.ylabel('$dE/dz/W_0$')\nplt.scatter(Z/0.0003, (E2-E1)/dz/W0, label='Impact-T', color='red')\nplt.plot(SSz, SSw, label='1-D model', color='black')\nplt.legend()\n</pre> plt.xlabel('$z/\\sigma_z$') plt.ylabel('$dE/dz/W_0$') plt.scatter(Z/0.0003, (E2-E1)/dz/W0, label='Impact-T', color='red') plt.plot(SSz, SSw, label='1-D model', color='black') plt.legend() In\u00a0[\u00a0]: Copied! <pre>0.02**(2/3)*2.5\n</pre> 0.02**(2/3)*2.5 In\u00a0[\u00a0]: Copied! <pre>(0.0006)**(-2/3)*(100.0)**(-1/3) * 0.0254/2\n</pre> (0.0006)**(-2/3)*(100.0)**(-1/3) * 0.0254/2 In\u00a0[\u00a0]: Copied! <pre>W0_calc(rho=10, sigma_z=0.05, total_charge=1e-9) / 2.5e6\n</pre> W0_calc(rho=10, sigma_z=0.05, total_charge=1e-9) / 2.5e6 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/elements/dipole/#dipole-example","title":"Dipole Example\u00b6","text":"<p>Simple dipole example</p>"},{"location":"examples/elements/dipole/#use-impacts-built-in-gaussian-particle-generator","title":"Use Impact's built-in Gaussian particle generator\u00b6","text":""},{"location":"examples/elements/dipole/#single-particle-tracking","title":"Single particle tracking\u00b6","text":""},{"location":"examples/elements/dipole/#csr-analysis","title":"CSR analysis\u00b6","text":""},{"location":"examples/elements/drift/","title":"Drift Example","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n\nimport numpy as np\nimport os\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n%config InlineBackend.figure_format='retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2  import numpy as np import os  import matplotlib.pyplot as plt %matplotlib inline %config InlineBackend.figure_format='retina' In\u00a0[2]: Copied! <pre># locate the drift template\nfrom impact import Impact\n\nifile = '../templates/drift/ImpactT.in'\nos.path.exists(ifile)\n</pre> # locate the drift template from impact import Impact  ifile = '../templates/drift/ImpactT.in' os.path.exists(ifile) Out[2]: <pre>True</pre> In\u00a0[3]: Copied! <pre># calculate gamma*beta\nmec2 = 0.51099895000e6 # eV\nEtot = 10e6 #eV\ngamma = Etot/mec2\nGB = np.sqrt(gamma**2 -1)\nGB\n</pre> # calculate gamma*beta mec2 = 0.51099895000e6 # eV Etot = 10e6 #eV gamma = Etot/mec2 GB = np.sqrt(gamma**2 -1) GB  Out[3]: <pre>19.54394518727907</pre> In\u00a0[4]: Copied! <pre>I = Impact(ifile)\nI.header['Np'] = 100000\nI.header['Nx'] = 32\nI.header['Ny'] = 32\nI.header['Nz'] = 32\nI.header['Dt'] = 10e-12\n</pre> I = Impact(ifile) I.header['Np'] = 100000 I.header['Nx'] = 32 I.header['Ny'] = 32 I.header['Nz'] = 32 I.header['Dt'] = 10e-12 In\u00a0[5]: Copied! <pre>I.lattice\n</pre> I.lattice Out[5]: <pre>[{'description': 'name:2d_to_3d_spacecharge',\n  'original': '0 0 0 -5 0 0 -1000.0 /!name:2d_to_3d_spacecharge',\n  'type': 'rotationally_symmetric_to_3d',\n  's': -1000.0,\n  'name': '2d_to_3d_spacecharge'},\n {'description': 'name:drift_1',\n  'original': '1.0 0 0 0 1.0 0.15 /!name:drift_1',\n  'L': 1.0,\n  'type': 'drift',\n  'zedge': 1.0,\n  'radius': 0.15,\n  's': 2.0,\n  'name': 'drift_1'},\n {'description': 'name:stop_1',\n  'original': '0 0 0 -99 0 0.0 1 /!name:stop_1',\n  'type': 'stop',\n  's': 1.0,\n  'name': 'stop_1'}]</pre> In\u00a0[6]: Copied! <pre>I.run()\n</pre> I.run() In\u00a0[7]: Copied! <pre>I.output['stats'].keys()\n</pre> I.output['stats'].keys() Out[7]: <pre>dict_keys(['t', 'mean_z', 'moment4_x', 'moment4_y', 'moment4_z', 'mean_y', 'sigma_y', 'norm_emit_y', 'mean_x', 'sigma_x', 'norm_emit_x', 'sigma_z', 'norm_emit_z', 'loadbalance_min_n_particle', 'loadbalance_max_n_particle', 'n_particle', 'moment3_x', 'moment3_y', 'moment3_z', 'mean_gamma', 'mean_beta', 'max_r', 'sigma_gamma', 'max_amplitude_x', 'max_amplitude_y', 'max_amplitude_z', 'moment4_px', 'moment4_py', 'moment4_pz', 'mean_py', 'sigma_py', 'cov_y__py', 'mean_px', 'sigma_px', 'cov_x__px', 'mean_pz', 'sigma_pz', 'cov_z__pz', 'moment3_px', 'moment3_py', 'moment3_pz', 'mean_kinetic_energy', 'max_amplitude_px', 'max_amplitude_py', 'max_amplitude_pz'])</pre> In\u00a0[8]: Copied! <pre>PI = I.particles['initial_particles']\nPF = I.particles['final_particles']\n</pre> PI = I.particles['initial_particles'] PF = I.particles['final_particles'] In\u00a0[9]: Copied! <pre>PF.plot('x', 'px')\nPF.plot('delta_z', 'delta_pz')\n</pre> PF.plot('x', 'px') PF.plot('delta_z', 'delta_pz') In\u00a0[10]: Copied! <pre>from distgen import Generator\n\nYAML=\"\"\"\nn_particle: 20000\nrandom_type: hammersley\nstart:\n  tstart:\n    units: sec\n    value: 0\n  type: time\ntotal_charge:\n  units: nC\n  value: 1\nr_dist:\n  sigma_xy:\n    units: mm\n    value: 1.0\n  type: radial_gaussian\nz_dist:\n  avg_z:\n    units: mm\n    value: 0\n  sigma_z:\n    units: mm\n    value: 0.1\n  type: gaussian\ntransforms:\n  setPz:\n    type: set_avg pz\n    avg_pz: \n      value: 10\n      units: MeV/c\n\"\"\"\nG = Generator(YAML)\nG.run()\nP = G.particles\n</pre> from distgen import Generator  YAML=\"\"\" n_particle: 20000 random_type: hammersley start:   tstart:     units: sec     value: 0   type: time total_charge:   units: nC   value: 1 r_dist:   sigma_xy:     units: mm     value: 1.0   type: radial_gaussian z_dist:   avg_z:     units: mm     value: 0   sigma_z:     units: mm     value: 0.1   type: gaussian     transforms:   setPz:     type: set_avg pz     avg_pz:        value: 10       units: MeV/c    \"\"\" G = Generator(YAML) G.run() P = G.particles  In\u00a0[11]: Copied! <pre>I = Impact(ifile, initial_particles=P, verbose=False)\nprint(I)\n</pre> I = Impact(ifile, initial_particles=P, verbose=False) print(I) <pre>================ Impact-T Summary ================    \n10000 particles\n1 bunch of electrons\ntotal charge: 1000.0000000000001 pC\nDistribution type: gauss3\nFree space start\nProcessor domain: 1 x 1 = 1 CPUs\nSpace charge grid: 32 x 32 x 32\nMaximum time steps: 1000000\nReference Frequency: 1000000000.0 Hz\nInitial reference time: 0.0 s\nSimulation starting from the beginning\n=================================================\nImpact-T configured in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpr246283u\n</pre> In\u00a0[12]: Copied! <pre>I.header['Nemission']\n</pre> I.header['Nemission'] Out[12]: <pre>0</pre> In\u00a0[13]: Copied! <pre>I = Impact(ifile, initial_particles=P, verbose=False)\nI.run()\nPF2 = I.particles['final_particles']\n</pre> I = Impact(ifile, initial_particles=P, verbose=False) I.run() PF2 = I.particles['final_particles'] In\u00a0[14]: Copied! <pre>PF2.plot('x', 'px')\nPF2.plot('delta_z', 'delta_pz')\n</pre> PF2.plot('x', 'px') PF2.plot('delta_z', 'delta_pz') In\u00a0[15]: Copied! <pre>for k in ['x', 'px', 'z', 'pz']:\n    plt.hist(PF[k], density=True, bins=100, label='Impact-T generator', alpha=0.5)\n    plt.hist(PF2[k], density=True, bins=100, label='Distgen generator', alpha=0.5)\n    plt.xlabel(k)\n    plt.legend()\n    plt.show()\n</pre> for k in ['x', 'px', 'z', 'pz']:     plt.hist(PF[k], density=True, bins=100, label='Impact-T generator', alpha=0.5)     plt.hist(PF2[k], density=True, bins=100, label='Distgen generator', alpha=0.5)     plt.xlabel(k)     plt.legend()     plt.show()"},{"location":"examples/elements/drift/#drift-example","title":"Drift Example\u00b6","text":"<p>Simple 1 m drift based on the benchmark in:</p> <p>3D Space Charge in Bmad C. E. Mayes, R. D. Ryne,  D. C. Sagan,</p> <p>https://accelconf.web.cern.ch/ipac2018/papers/thpak085.pdf</p>"},{"location":"examples/elements/drift/#use-impacts-built-in-gaussian-particle-generator","title":"Use Impact's built-in Gaussian particle generator\u00b6","text":""},{"location":"examples/elements/drift/#make-particles-in-distgen","title":"Make particles in distgen\u00b6","text":""},{"location":"examples/elements/drift/#compare","title":"Compare\u00b6","text":""},{"location":"examples/elements/quadrupole/","title":"Quadrupole Example","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n\nimport numpy as np\nimport os\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n%config InlineBackend.figure_format='retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2  import numpy as np import os  import matplotlib.pyplot as plt %matplotlib inline %config InlineBackend.figure_format='retina' In\u00a0[2]: Copied! <pre># locate the drift template\nfrom impact import Impact\n\nifile = '../templates/quadrupole/ImpactT.in'\nos.path.exists(ifile)\n</pre> # locate the drift template from impact import Impact  ifile = '../templates/quadrupole/ImpactT.in' os.path.exists(ifile) Out[2]: <pre>True</pre> In\u00a0[3]: Copied! <pre># calculate gamma*beta\nmec2 = 0.51099895000e6 # eV\nEtot = 6e6 #eV\ngamma = Etot/mec2\nGB = np.sqrt(gamma**2 -1)\nGB\n</pre> # calculate gamma*beta mec2 = 0.51099895000e6 # eV Etot = 6e6 #eV gamma = Etot/mec2 GB = np.sqrt(gamma**2 -1) GB  Out[3]: <pre>11.699046356605859</pre> In\u00a0[4]: Copied! <pre>I = Impact(ifile)\nI.header['Np'] = 100000\nI.header['Nx'] = 32\nI.header['Ny'] = 32\nI.header['Nz'] = 32\nI.header['Dt'] = 10e-12\nI.header['Bcurr'] = 0\n\nI.header['zmu2'] = GB\n\n# set normal and skew quads\nI.ele['CQ01']['b1_gradient'] = 0.00714 # T/m\nI.ele['SQ01']['b1_gradient'] = 0\n</pre> I = Impact(ifile) I.header['Np'] = 100000 I.header['Nx'] = 32 I.header['Ny'] = 32 I.header['Nz'] = 32 I.header['Dt'] = 10e-12 I.header['Bcurr'] = 0  I.header['zmu2'] = GB  # set normal and skew quads I.ele['CQ01']['b1_gradient'] = 0.00714 # T/m I.ele['SQ01']['b1_gradient'] = 0   In\u00a0[5]: Copied! <pre># Track\nI2 = I.copy()\nI2.configure()\n</pre> # Track I2 = I.copy() I2.configure() In\u00a0[6]: Copied! <pre>ele = I2.ele['CQ01']\nele\n</pre> ele = I2.ele['CQ01'] ele Out[6]: <pre>{'description': 'name:CQ01',\n 'original': '0.36 0 0 1 0.01601  0.00714 0.210 0.0254 0.0 0.0 0.0 0.0 0 /!name:CQ01',\n 'L': 0.36,\n 'type': 'quadrupole',\n 'zedge': 0.01601,\n 'b1_gradient': 0.00714,\n 'L_effective': 0.21,\n 'radius': 0.0254,\n 'x_offset': 0.0,\n 'y_offset': 0.0,\n 'x_rotation': 0.0,\n 'y_rotation': 0.0,\n 'z_rotation': 0.0,\n 's': 0.37601,\n 'name': 'CQ01'}</pre> In\u00a0[7]: Copied! <pre># Estimate for angle change for a 6 MeV/c momentum particle, offset by 1 mm.  \nele['b1_gradient']*ele['L_effective']*299792458 / 6e6 * .001\n</pre> # Estimate for angle change for a 6 MeV/c momentum particle, offset by 1 mm.   ele['b1_gradient']*ele['L_effective']*299792458 / 6e6 * .001 Out[7]: <pre>7.491813525419999e-05</pre> In\u00a0[8]: Copied! <pre>P2 = I2.track1(s=2.2, z0 = 0, x0=0.001, pz0=6e6)\nP2.xp\n</pre> P2 = I2.track1(s=2.2, z0 = 0, x0=0.001, pz0=6e6) P2.xp Out[8]: <pre>array([7.51244699e-05])</pre> In\u00a0[9]: Copied! <pre>I2.plot('mean_x')\n</pre> I2.plot('mean_x') In\u00a0[10]: Copied! <pre># Regular and Skew quads\nI.run()\n</pre> # Regular and Skew quads I.run() In\u00a0[11]: Copied! <pre>I.output['stats'].keys()\n</pre> I.output['stats'].keys() Out[11]: <pre>dict_keys(['t', 'mean_z', 'moment4_x', 'moment4_y', 'moment4_z', 'mean_y', 'sigma_y', 'norm_emit_y', 'mean_x', 'sigma_x', 'norm_emit_x', 'sigma_z', 'norm_emit_z', 'loadbalance_min_n_particle', 'loadbalance_max_n_particle', 'n_particle', 'moment3_x', 'moment3_y', 'moment3_z', 'mean_gamma', 'mean_beta', 'max_r', 'sigma_gamma', 'max_amplitude_x', 'max_amplitude_y', 'max_amplitude_z', 'moment4_px', 'moment4_py', 'moment4_pz', 'mean_py', 'sigma_py', 'cov_y__py', 'mean_px', 'sigma_px', 'cov_x__px', 'mean_pz', 'sigma_pz', 'cov_z__pz', 'moment3_px', 'moment3_py', 'moment3_pz', 'mean_kinetic_energy', 'max_amplitude_px', 'max_amplitude_py', 'max_amplitude_pz'])</pre> In\u00a0[12]: Copied! <pre>PI = I.particles['initial_particles']\nPF = I.particles['final_particles']\nPI['sigma_y']\n</pre> PI = I.particles['initial_particles'] PF = I.particles['final_particles'] PI['sigma_y'] Out[12]: <pre>0.001000777236945671</pre> In\u00a0[13]: Copied! <pre># Compare these. \nkey1 = 'mean_z'\nkey2 = 'sigma_x'\nunits1 = str(I.units(key1))\nunits2 = str(I.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(I.stat(key1), I.stat(key2))\nplt.scatter(\n    [I.particles[name][key1] for name in I.particles], \n    [I.particles[name][key2] for name in I.particles], color='red')\n</pre> # Compare these.  key1 = 'mean_z' key2 = 'sigma_x' units1 = str(I.units(key1)) units2 = str(I.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(I.stat(key1), I.stat(key2)) plt.scatter(     [I.particles[name][key1] for name in I.particles],      [I.particles[name][key2] for name in I.particles], color='red')  Out[13]: <pre>&lt;matplotlib.collections.PathCollection at 0x13af7c580&gt;</pre> In\u00a0[14]: Copied! <pre># Compare these. \nkey1 = 'mean_z'\nkey2 = 'sigma_x'\nunits1 = str(I.units(key1))\nunits2 = str(I.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(I.stat(key1), I.stat(key2))\nplt.scatter(\n    [I.particles[name][key1] for name in I.particles], \n    [I.particles[name][key2] for name in I.particles], color='red')\nkey2 = 'sigma_y'\nplt.plot(I.stat(key1), I.stat(key2))\nplt.scatter(\n    [I.particles[name][key1] for name in I.particles], \n    [I.particles[name][key2] for name in I.particles], color='green')\n</pre> # Compare these.  key1 = 'mean_z' key2 = 'sigma_x' units1 = str(I.units(key1)) units2 = str(I.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(I.stat(key1), I.stat(key2)) plt.scatter(     [I.particles[name][key1] for name in I.particles],      [I.particles[name][key2] for name in I.particles], color='red') key2 = 'sigma_y' plt.plot(I.stat(key1), I.stat(key2)) plt.scatter(     [I.particles[name][key1] for name in I.particles],      [I.particles[name][key2] for name in I.particles], color='green') Out[14]: <pre>&lt;matplotlib.collections.PathCollection at 0x13b435a00&gt;</pre> In\u00a0[15]: Copied! <pre>PF.plot('x', 'y')\nPF.plot('delta_z', 'delta_pz')\n</pre> PF.plot('x', 'y') PF.plot('delta_z', 'delta_pz')"},{"location":"examples/elements/quadrupole/#quadrupole-example","title":"Quadrupole Example\u00b6","text":"<p>Simple quadrupole example</p>"},{"location":"examples/elements/quadrupole/#use-impacts-built-in-gaussian-particle-generator","title":"Use Impact's built-in Gaussian particle generator\u00b6","text":""},{"location":"examples/elements/quadrupole/#single-particle-tracking","title":"Single particle tracking\u00b6","text":""},{"location":"examples/elements/quadrupole/#track-beam","title":"Track beam\u00b6","text":""},{"location":"examples/elements/solenoid/","title":"Solenoid Example","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n\nimport numpy as np\nimport os\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n%config InlineBackend.figure_format='retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2  import numpy as np import os  import matplotlib.pyplot as plt %matplotlib inline %config InlineBackend.figure_format='retina' In\u00a0[2]: Copied! <pre># locate the solenoid templates\nfrom impact import Impact\n\nifile1d = '../templates/solenoid/ImpactT_solenoid_1d.in'\nifile2d = '../templates/solenoid/ImpactT_solenoid_2d.in'\n\nos.path.exists(ifile1d), os.path.exists(ifile2d)\n</pre> # locate the solenoid templates from impact import Impact  ifile1d = '../templates/solenoid/ImpactT_solenoid_1d.in' ifile2d = '../templates/solenoid/ImpactT_solenoid_2d.in'  os.path.exists(ifile1d), os.path.exists(ifile2d) Out[2]: <pre>(True, True)</pre> In\u00a0[3]: Copied! <pre>I1 = Impact(ifile1d)\nI2 = Impact(ifile2d)\n\n# Turn off SC\nI1['total_charge'] = 0\nI2['total_charge'] = 0\nprint(I1)\n</pre> I1 = Impact(ifile1d) I2 = Impact(ifile2d)  # Turn off SC I1['total_charge'] = 0 I2['total_charge'] = 0 print(I1) <pre>================ Impact-T Summary ================    \n10000 particles\n1 bunch of electrons\ntotal charge: 0.0 pC\nDistribution type: gauss3\nFree space start\nProcessor domain: 1 x 1 = 1 CPUs\nSpace charge grid: 32 x 32 x 32\nMaximum time steps: 1000000\nReference Frequency: 1000000000.0 Hz\nInitial reference time: 0.0 s\nSimulation starting from the beginning\n=================================================\nImpact-T configured in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp17pak_yi\n</pre> In\u00a0[4]: Copied! <pre>%%time\nI1['total_charge'] = 0\nI1.run()\nI1.plot()\n</pre> %%time I1['total_charge'] = 0 I1.run() I1.plot() <pre>CPU times: user 52.3 ms, sys: 15.3 ms, total: 67.5 ms\nWall time: 6.22 s\n</pre> In\u00a0[5]: Copied! <pre>%%time\nI2['total_charge'] = 0\nI2.run()\nI2.plot()\n</pre> %%time I2['total_charge'] = 0 I2.run() I2.plot() <pre>CPU times: user 222 ms, sys: 35.1 ms, total: 257 ms\nWall time: 850 ms\n</pre> In\u00a0[6]: Copied! <pre># The 2D version keeps the field internally as a FieldMesh\nI2.fieldmaps['1T912.T7']['field'].plot_onaxis()\n</pre> # The 2D version keeps the field internally as a FieldMesh I2.fieldmaps['1T912.T7']['field'].plot_onaxis() In\u00a0[7]: Copied! <pre>%%time\nP1 = I1.track1(s=0.5, z0 = 0, x0=0.019, pz0=3e6)\n</pre> %%time P1 = I1.track1(s=0.5, z0 = 0, x0=0.019, pz0=3e6)  <pre>CPU times: user 40.1 ms, sys: 36 ms, total: 76.1 ms\nWall time: 33.5 ms\n</pre> In\u00a0[8]: Copied! <pre>X0 = 0.003\n\nI1.track1(s=0.4, x0=X0, pz0=3e6)\nI2.track1(s=0.4, x0=X0, pz0=3e6)\n\nk1 = 'mean_z'\nk2 = 'mean_x'\n\nx1 = I1.stat(k1)\ny1 = I1.stat(k2)\n\nx2 = I2.stat(k1)\ny2 = I2.stat(k2)\n\nfig, ax = plt.subplots(figsize=(16,9))\n\nax.plot(x1, y1, color='black', label='1D fieldmap')\nax.plot(x2, y2, color='red', linestyle='--', label='2D fieldmap')\nax.legend()\n</pre> X0 = 0.003  I1.track1(s=0.4, x0=X0, pz0=3e6) I2.track1(s=0.4, x0=X0, pz0=3e6)  k1 = 'mean_z' k2 = 'mean_x'  x1 = I1.stat(k1) y1 = I1.stat(k2)  x2 = I2.stat(k1) y2 = I2.stat(k2)  fig, ax = plt.subplots(figsize=(16,9))  ax.plot(x1, y1, color='black', label='1D fieldmap') ax.plot(x2, y2, color='red', linestyle='--', label='2D fieldmap') ax.legend() Out[8]: <pre>&lt;matplotlib.legend.Legend at 0x155743160&gt;</pre> In\u00a0[9]: Copied! <pre>I2.ele['SOL1']\n</pre> I2.ele['SOL1'] Out[9]: <pre>{'description': 'name:SOL1',\n 'original': ' 0.4 0 0 3 -0.02678 .2 912 0 0 0 0 0 0 /!name:SOL1',\n 'L': 0.4,\n 'type': 'solenoid',\n 'zedge': -0.02678,\n 'b_field': 0.2,\n 'filename': '1T912.T7',\n 'radius': 0.0,\n 's': 0.37322,\n 'name': 'SOL1'}</pre> In\u00a0[10]: Copied! <pre>fig, ax = plt.subplots(figsize=(12,8))\n\nk1 = 'mean_z'\nk2 = 'mean_x'\n\nf1 = 1e3\nf2 = 1e3\nu1 = 'mm'\nu2 = 'mm'\n\nfor X0 in np.linspace(0, 0.018, 10):\n    I1.track1(s=0.4, x0=X0, pz0=3e6)\n    I2.track1(s=0.4, x0=X0, pz0=3e6)\n    \n\n    \n    x1 = I1.stat(k1)\n    y1 = I1.stat(k2)\n    \n    x2 = I2.stat(k1)\n    y2 = I2.stat(k2)\n    \n\n    if X0 ==0:\n        label1='1D fieldmap'\n        label2='2D fieldmap'\n    else:\n        label1=None\n        label2=None\n    \n    ax.plot(x1*f1, y1*f2, color='black', label=label1)\n    ax.plot(x2*f1, y2*f2, color='red', linestyle='--', label=label2)\n\nax.set_ylim(0, 18)    \nax.set_xlabel(f'{k1} ({u1})')\nax.set_ylabel(f'{k2} ({u2})')\nax.legend()\n</pre>  fig, ax = plt.subplots(figsize=(12,8))  k1 = 'mean_z' k2 = 'mean_x'  f1 = 1e3 f2 = 1e3 u1 = 'mm' u2 = 'mm'  for X0 in np.linspace(0, 0.018, 10):     I1.track1(s=0.4, x0=X0, pz0=3e6)     I2.track1(s=0.4, x0=X0, pz0=3e6)                x1 = I1.stat(k1)     y1 = I1.stat(k2)          x2 = I2.stat(k1)     y2 = I2.stat(k2)           if X0 ==0:         label1='1D fieldmap'         label2='2D fieldmap'     else:         label1=None         label2=None          ax.plot(x1*f1, y1*f2, color='black', label=label1)     ax.plot(x2*f1, y2*f2, color='red', linestyle='--', label=label2)  ax.set_ylim(0, 18)     ax.set_xlabel(f'{k1} ({u1})') ax.set_ylabel(f'{k2} ({u2})') ax.legend() Out[10]: <pre>&lt;matplotlib.legend.Legend at 0x1562d3970&gt;</pre> In\u00a0[11]: Copied! <pre>I1 = Impact(ifile1d)\nI2 = Impact(ifile2d)\n\n# Turn off SC\nI1['total_charge'] = 0\nI2['total_charge'] = 0\nI1.run()\nI2.run()\n</pre> I1 = Impact(ifile1d) I2 = Impact(ifile2d)  # Turn off SC I1['total_charge'] = 0 I2['total_charge'] = 0 I1.run() I2.run() In\u00a0[12]: Copied! <pre>I1.output['stats'].keys()\n</pre> I1.output['stats'].keys() Out[12]: <pre>dict_keys(['t', 'mean_z', 'moment4_x', 'moment4_y', 'moment4_z', 'mean_y', 'sigma_y', 'norm_emit_y', 'mean_x', 'sigma_x', 'norm_emit_x', 'sigma_z', 'norm_emit_z', 'loadbalance_min_n_particle', 'loadbalance_max_n_particle', 'n_particle', 'moment3_x', 'moment3_y', 'moment3_z', 'mean_gamma', 'mean_beta', 'max_r', 'sigma_gamma', 'max_amplitude_x', 'max_amplitude_y', 'max_amplitude_z', 'moment4_px', 'moment4_py', 'moment4_pz', 'mean_py', 'sigma_py', 'cov_y__py', 'mean_px', 'sigma_px', 'cov_x__px', 'mean_pz', 'sigma_pz', 'cov_z__pz', 'moment3_px', 'moment3_py', 'moment3_pz', 'mean_kinetic_energy', 'max_amplitude_px', 'max_amplitude_py', 'max_amplitude_pz'])</pre> In\u00a0[13]: Copied! <pre>PI = I1.particles['initial_particles']\nPF = I1.particles['final_particles']\nPI['sigma_y']\n</pre> PI = I1.particles['initial_particles'] PF = I1.particles['final_particles'] PI['sigma_y'] Out[13]: <pre>0.0010106410879665382</pre> In\u00a0[14]: Copied! <pre># Compare these. \nkey1 = 'mean_z'\nkey2 = 'sigma_x'\nunits1 = str(I1.units(key1))\nunits2 = str(I1.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(I1.stat(key1), I1.stat(key2))\nplt.scatter(\n    [I1.particles[name][key1] for name in I1.particles], \n    [I2.particles[name][key2] for name in I2.particles], color='red')\n</pre> # Compare these.  key1 = 'mean_z' key2 = 'sigma_x' units1 = str(I1.units(key1)) units2 = str(I1.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(I1.stat(key1), I1.stat(key2)) plt.scatter(     [I1.particles[name][key1] for name in I1.particles],      [I2.particles[name][key2] for name in I2.particles], color='red')  Out[14]: <pre>&lt;matplotlib.collections.PathCollection at 0x157ee3f70&gt;</pre> In\u00a0[15]: Copied! <pre># Compare these. \nkey1 = 'mean_z'\nkey2 = 'sigma_x'\nunits1 = str(I1.units(key1))\nunits2 = str(I1.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(I1.stat(key1), I1.stat(key2), label='1D solenoid')\nplt.scatter(\n    [I1.particles[name][key1] for name in I1.particles], \n    [I1.particles[name][key2] for name in I1.particles], color='red')\nkey2 = 'sigma_y'\nplt.plot(I2.stat(key1), I2.stat(key2), label='2D solenoid')\nplt.scatter(\n    [I2.particles[name][key1] for name in I2.particles], \n    [I2.particles[name][key2] for name in I2.particles], color='green')\nplt.legend()\n</pre> # Compare these.  key1 = 'mean_z' key2 = 'sigma_x' units1 = str(I1.units(key1)) units2 = str(I1.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(I1.stat(key1), I1.stat(key2), label='1D solenoid') plt.scatter(     [I1.particles[name][key1] for name in I1.particles],      [I1.particles[name][key2] for name in I1.particles], color='red') key2 = 'sigma_y' plt.plot(I2.stat(key1), I2.stat(key2), label='2D solenoid') plt.scatter(     [I2.particles[name][key1] for name in I2.particles],      [I2.particles[name][key2] for name in I2.particles], color='green') plt.legend() Out[15]: <pre>&lt;matplotlib.legend.Legend at 0x1567b11f0&gt;</pre> In\u00a0[16]: Copied! <pre>PF.plot('x', 'y')\nPF.plot('delta_z', 'delta_pz')\n</pre> PF.plot('x', 'y') PF.plot('delta_z', 'delta_pz')"},{"location":"examples/elements/solenoid/#solenoid-example","title":"Solenoid Example\u00b6","text":"<p>Simple solenoid example</p>"},{"location":"examples/elements/solenoid/#use-impacts-built-in-gaussian-particle-generator","title":"Use Impact's built-in Gaussian particle generator\u00b6","text":""},{"location":"examples/elements/solenoid/#single-particle-tracking","title":"Single particle tracking\u00b6","text":""},{"location":"examples/elements/solenoid/#compare-1d-and-2d-maps","title":"Compare 1D and 2D maps\u00b6","text":""},{"location":"examples/elements/solenoid/#track-beam","title":"Track beam\u00b6","text":""},{"location":"examples/elements/tesla_9cell_cavity/","title":"TESLA 9-cell Cavity","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n\nimport numpy as np\nimport os\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n%config InlineBackend.figure_format='retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2  import numpy as np import os  import matplotlib.pyplot as plt %matplotlib inline %config InlineBackend.figure_format='retina' In\u00a0[2]: Copied! <pre>from impact import Impact\n\nifile1 =  '../templates/tesla_9cell_cavity/ImpactT-1d.in'\nifile2 = '../templates/tesla_9cell_cavity/ImpactT-2d.in'\nos.path.exists(ifile1), os.path.exists(ifile2)\n</pre> from impact import Impact  ifile1 =  '../templates/tesla_9cell_cavity/ImpactT-1d.in' ifile2 = '../templates/tesla_9cell_cavity/ImpactT-2d.in' os.path.exists(ifile1), os.path.exists(ifile2) Out[2]: <pre>(True, True)</pre> In\u00a0[3]: Copied! <pre># calculate gamma*beta\nmec2 = 0.51099895000e6 # eV\nEtot = 10e6 #eV\ngamma = Etot/mec2\nGB = np.sqrt(gamma**2 -1)\nGB\n\nGB, np.sqrt(Etot**2 - mec2**2)\n</pre> # calculate gamma*beta mec2 = 0.51099895000e6 # eV Etot = 10e6 #eV gamma = Etot/mec2 GB = np.sqrt(gamma**2 -1) GB  GB, np.sqrt(Etot**2 - mec2**2) Out[3]: <pre>(19.54394518727907, 9986935.46955716)</pre> In\u00a0[4]: Copied! <pre>%%time\nI1 = Impact(ifile1)\nI1.run()\nI1.plot(y2='mean_kinetic_energy')\n</pre> %%time I1 = Impact(ifile1) I1.run() I1.plot(y2='mean_kinetic_energy') <pre>CPU times: user 85.8 ms, sys: 30.2 ms, total: 116 ms\nWall time: 17.1 s\n</pre> In\u00a0[5]: Copied! <pre>%%time\nI2 = Impact(ifile2)\nI2.run()\nI2.plot(y2='mean_kinetic_energy')\n</pre> %%time I2 = Impact(ifile2) I2.run() I2.plot(y2='mean_kinetic_energy') <pre>CPU times: user 304 ms, sys: 43.2 ms, total: 347 ms\nWall time: 3.15 s\n</pre> In\u00a0[6]: Copied! <pre>I1.particles['final_particles'].plot('z', 'pz', bins=100)\n</pre> I1.particles['final_particles'].plot('z', 'pz', bins=100) In\u00a0[7]: Copied! <pre>I2.particles['final_particles'].plot('z', 'pz', bins=100)\n</pre> I2.particles['final_particles'].plot('z', 'pz', bins=100) In\u00a0[8]: Copied! <pre>#ky = 'mean_kinetic_energy'\ndef compare(ky = 'sigma_x', kx = 'mean_z'):\n\n    fig, ax = plt.subplots(figsize=(12,6))\n    ax.plot(I1.stat(kx), I1.stat(ky), label='Impact-T 1D')\n    ax.plot(I2.stat(kx), I2.stat(ky), label='Impact-T 2D', linestyle='--')\n    ax.legend()\n    #ax.set_xlim(0,2)\n    \n    ax.set_xlabel(kx)\n    ax.set_ylabel(ky)\ncompare()\n</pre> #ky = 'mean_kinetic_energy' def compare(ky = 'sigma_x', kx = 'mean_z'):      fig, ax = plt.subplots(figsize=(12,6))     ax.plot(I1.stat(kx), I1.stat(ky), label='Impact-T 1D')     ax.plot(I2.stat(kx), I2.stat(ky), label='Impact-T 2D', linestyle='--')     ax.legend()     #ax.set_xlim(0,2)          ax.set_xlabel(kx)     ax.set_ylabel(ky) compare()     In\u00a0[9]: Copied! <pre>I = Impact(ifile1, verbose=False)\n#I.header['Np'] = 100000\n#I.header['Nx'] = 32\n#I.header['Ny'] = 32\n#I.header['Nz'] = 32\nI.header['Dt'] = 1e-12\n\n#I.ele['cavity9']['rf_field_scale']= 32e6\n#I.ele['cavity9']['theta0_deg'] =  29.37652048194741\n\nI.total_charge = 0 # Turn SC off\nI.verbose=False\nprint(I)\nI.run()\nI.particles['final_particles']['sigma_x']/1e-6\n</pre> I = Impact(ifile1, verbose=False) #I.header['Np'] = 100000 #I.header['Nx'] = 32 #I.header['Ny'] = 32 #I.header['Nz'] = 32 I.header['Dt'] = 1e-12  #I.ele['cavity9']['rf_field_scale']= 32e6 #I.ele['cavity9']['theta0_deg'] =  29.37652048194741  I.total_charge = 0 # Turn SC off I.verbose=False print(I) I.run() I.particles['final_particles']['sigma_x']/1e-6  <pre>================ Impact-T Summary ================    \n10000 particles\n1 bunch of electrons\ntotal charge: 0.0 pC\nDistribution type: gauss3\nFree space start\nProcessor domain: 1 x 1 = 1 CPUs\nSpace charge grid: 32 x 32 x 32\nMaximum time steps: 1000000\nReference Frequency: 1300000000.0 Hz\nInitial reference time: 0.0 s\nSimulation starting from the beginning\n=================================================\nImpact-T configured in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpowl2jc1x\n</pre> Out[9]: <pre>3.731960809671403</pre> In\u00a0[10]: Copied! <pre>I.particles['final_particles'].plot('z', 'pz')\n</pre> I.particles['final_particles'].plot('z', 'pz') In\u00a0[11]: Copied! <pre>I.lattice\n</pre> I.lattice Out[11]: <pre>[{'description': 'name:cavity9',\n  'original': '1.347 0 0  105 0 32e6 1.3e9 229.8241496412331 9 0 0.0 0.0 0.0 0.0 0.0 0.0 /!name:cavity9',\n  'L': 1.347,\n  'type': 'solrf',\n  'zedge': 0.0,\n  'rf_field_scale': 32000000.0,\n  'rf_frequency': 1300000000.0,\n  'theta0_deg': 229.8241496412331,\n  'filename': 'rfdata9',\n  'radius': 0.0,\n  'x_offset': 0.0,\n  'y_offset': 0.0,\n  'x_rotation': 0.0,\n  'y_rotation': 0.0,\n  'z_rotation': 0.0,\n  'solenoid_field_scale': 0.0,\n  's': 1.347,\n  'name': 'cavity9'},\n {'description': 'name:stop_1',\n  'original': '0 0 0 -99 0 0.0 1.5 /!name:stop_1',\n  'type': 'stop',\n  's': 1.5,\n  'name': 'stop_1'}]</pre> In\u00a0[12]: Copied! <pre>from impact.autophase import autophase\n\nfrom pmd_beamphysics import single_particle\n\nP0 = single_particle(pz=10e6, z=1e-15)\n\nautophase(I2, ele_name='cavity9', initial_particles=P0, metric='mean_kinetic_energy', verbose=True)\n</pre> from impact.autophase import autophase  from pmd_beamphysics import single_particle  P0 = single_particle(pz=10e6, z=1e-15)  autophase(I2, ele_name='cavity9', initial_particles=P0, metric='mean_kinetic_energy', verbose=True) <pre>Copied initial Impact object. \nPhasing cavity9 by changing theta0_deg\nBounds: 0.0, 1.347 m\nDefault brent2 algorithm\nPhase: 180, 16.998227975214004 MeV\nPhase: 180, 16.998227975214004 MeV\nPhase: 42.49224000000004, 0.0 M\nPhase: 180, 16.998227975214004 MeV\nPhase: 42.49223094384001, 0.0 M\nPhase: 42.49223999999998, 0.0 M\nPhase: 222.49223547192, 25.442029397369534 MeV\nPhase: 291.2461137423474, 21.238389337448673 MeV\nPhase: 243.7817825076153, 26.67725309641637 MeV\nPhase: 244.6923794470155, 26.678029806579133 MeV\nPhase: 244.40270047418736, 26.678252484702742 MeV\nPhase: 244.40037613191828, 26.678252498701642 MeV\nPhase: 244.4006205323044, 26.67825249854837 MeV\nPhase: 244.40013173153216, 26.67825249854837 MeV\nSet Phase: 244.40037613191828\n</pre> Out[12]: <pre>244.40037613191828</pre> In\u00a0[13]: Copied! <pre>I.run()\n</pre> I.run() In\u00a0[14]: Copied! <pre>I.particles['final_particles']['mean_energy']/1e6, I.particles['final_particles']['sigma_x']/1e-6\n</pre> I.particles['final_particles']['mean_energy']/1e6, I.particles['final_particles']['sigma_x']/1e-6 Out[14]: <pre>(27.4115271576144, 3.731960809671403)</pre> In\u00a0[15]: Copied! <pre># Compare these. \nkey1 = 'mean_z'\nkey2 = 'sigma_x'\nunits1 = str(I.units(key1))\nunits2 = str(I.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(I.stat(key1), I.stat(key2))\nplt.scatter(\n    [I.particles[name][key1] for name in I.particles], \n    [I.particles[name][key2] for name in I.particles], color='red')\n</pre> # Compare these.  key1 = 'mean_z' key2 = 'sigma_x' units1 = str(I.units(key1)) units2 = str(I.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(I.stat(key1), I.stat(key2)) plt.scatter(     [I.particles[name][key1] for name in I.particles],      [I.particles[name][key2] for name in I.particles], color='red') Out[15]: <pre>&lt;matplotlib.collections.PathCollection at 0x14d680e80&gt;</pre> In\u00a0[16]: Copied! <pre>I.output['stats'].keys()\n</pre> I.output['stats'].keys() Out[16]: <pre>dict_keys(['t', 'mean_z', 'moment4_x', 'moment4_y', 'moment4_z', 'mean_y', 'sigma_y', 'norm_emit_y', 'mean_x', 'sigma_x', 'norm_emit_x', 'sigma_z', 'norm_emit_z', 'loadbalance_min_n_particle', 'loadbalance_max_n_particle', 'n_particle', 'moment3_x', 'moment3_y', 'moment3_z', 'mean_gamma', 'mean_beta', 'max_r', 'sigma_gamma', 'max_amplitude_x', 'max_amplitude_y', 'max_amplitude_z', 'moment4_px', 'moment4_py', 'moment4_pz', 'mean_py', 'sigma_py', 'cov_y__py', 'mean_px', 'sigma_px', 'cov_x__px', 'mean_pz', 'sigma_pz', 'cov_z__pz', 'moment3_px', 'moment3_py', 'moment3_pz', 'mean_kinetic_energy', 'max_amplitude_px', 'max_amplitude_py', 'max_amplitude_pz'])</pre> In\u00a0[17]: Copied! <pre>PI = I.particles['initial_particles']\nPF = I.particles['final_particles']\n</pre> PI = I.particles['initial_particles'] PF = I.particles['final_particles'] In\u00a0[18]: Copied! <pre>PI['mean_pz']\n</pre> PI['mean_pz'] Out[18]: <pre>9986935.46956785</pre> In\u00a0[19]: Copied! <pre>PF.plot('delta_z', 'delta_pz')\n</pre> PF.plot('delta_z', 'delta_pz') In\u00a0[20]: Copied! <pre>from distgen import Generator\n\nYAML=\"\"\"\nn_particle: 10000\nrandom_type: hammersley\nstart:\n  tstart:\n    units: sec\n    value: 0\n  type: time\ntotal_charge:\n  units: nC\n  value: 1\nr_dist:\n  sigma_xy:\n    units: mm\n    value: .01\n  type: radial_gaussian\nz_dist:\n  avg_z:\n    units: mm\n    value: 0\n  sigma_z:\n    units: mm\n    value: 0.1\n  type: gaussian\ntransforms:\n  setPz:\n    type: set_avg pz\n    avg_pz: \n      value: 99.99869439159244\n      units: MeV/c\n\"\"\"\nG = Generator(YAML)\nG.run()\nP = G.particles\n</pre> from distgen import Generator  YAML=\"\"\" n_particle: 10000 random_type: hammersley start:   tstart:     units: sec     value: 0   type: time total_charge:   units: nC   value: 1 r_dist:   sigma_xy:     units: mm     value: .01   type: radial_gaussian z_dist:   avg_z:     units: mm     value: 0   sigma_z:     units: mm     value: 0.1   type: gaussian     transforms:   setPz:     type: set_avg pz     avg_pz:        value: 99.99869439159244       units: MeV/c    \"\"\" G = Generator(YAML) G.run() P = G.particles  In\u00a0[21]: Copied! <pre>I2 = I.copy()\nI2.initial_particles = P\nI2.configure()\nI2.total_charge = 0 # or: P['charge']\nI2.verbose = True\nI2.run()\nPF2 = I2.particles['final_particles']\n</pre> I2 = I.copy() I2.initial_particles = P I2.configure() I2.total_charge = 0 # or: P['charge'] I2.verbose = True I2.run() PF2 = I2.particles['final_particles'] <pre>Running Impact-T in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp9jdu56xv\n/Users/chrisonian/Code/Impact/IMPACT-T/build/ImpactTexe\nwriting 10000 particles to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp9jdu56xv/partcl.data\nNormal start with at time 0.0 s\nNormal start: Replaced Np with 10000 according to initial particles\nNormal start: Replaced Tini with 0.0 according to initial particles\nNormal start: Replaced Flagimg with 0 according to initial particles\nChanging particle offset factor zmu2 to 0\n !-----------------------------------------------------------\n ! IMPACT-T Parallel Beam Dynamics Tracking Code: 2.1 beta version\n ! Copyright of The Regents of the University of California\n !-----------------------------------------------------------\n nblem:            2           2\n pass setting up lattice...\n check randomness:            0  0.30440529327431320     \n avgpts, jlow, and jhigh:        10000           1       10000\n sumx1,sumy1:    9.5636796008588550E-021  -1.1092608150494104E-020\n pass generating initial distribution...\n tstop:    1.5000000000000000     \n i,t,&lt;z&gt;:            1   0.0000000000000000        0.0000000000000000     \n zmin,zmax:    0.0000000000000000        5.1140374029691601E-004\n name: rfdata9rfdataxxrfdataxxx\n time:    0.0000000000000000, elapsed: 17.075734615325928Finished.326, elapsed: 17.051050901412964998056\nLoaded fort 30 : Fourth root of the fourth moments of the beam distribution\nLoaded fort 25 : RMS Y information\nLoaded fort 24 : RMS X information\nLoaded fort 26 : RMS Z information\nLoaded fort 28 : Load balance and loss diagnostics\nLoaded fort 29 : Cube root of third moments of the beam distribution\nLoaded fort 18 : Time and energy\nLoaded fort 27 : Max amplitude information\nLoaded fort 70 : Slice information of the final distribution\nLoaded fort 60 : Slice information of the initial distribution\nLoading particles\nLoaded fort 40 : initial particle distribution at t = 0\nLoaded fort 50 : final particle distribution projected to the centroid location of the bunch\nConverted initial_particles to ParticleGroup\nConverted final_particles to ParticleGroup\n</pre> In\u00a0[22]: Copied! <pre>PF2.plot('x', 'px')\nPF2.plot('delta_z', 'delta_pz')\n</pre> PF2.plot('x', 'px') PF2.plot('delta_z', 'delta_pz') In\u00a0[23]: Copied! <pre># for k in ['x', 'px', 'z', 'pz']:\n#     plt.hist(PF[k], density=True, bins=100, label='Impact-T generator', alpha=0.5)\n#     plt.hist(PF2[k], density=True, bins=100, label='Distgen generator', alpha=0.5)\n#     plt.xlabel(k)\n#     plt.legend()\n#     plt.show()\n</pre> # for k in ['x', 'px', 'z', 'pz']: #     plt.hist(PF[k], density=True, bins=100, label='Impact-T generator', alpha=0.5) #     plt.hist(PF2[k], density=True, bins=100, label='Distgen generator', alpha=0.5) #     plt.xlabel(k) #     plt.legend() #     plt.show()"},{"location":"examples/elements/tesla_9cell_cavity/#tesla-9-cell-cavity","title":"TESLA 9-cell Cavity\u00b6","text":""},{"location":"examples/elements/tesla_9cell_cavity/#use-impacts-built-in-gaussian-particle-generator","title":"Use Impact's built-in Gaussian particle generator\u00b6","text":""},{"location":"examples/elements/tesla_9cell_cavity/#autophase","title":"Autophase\u00b6","text":""},{"location":"examples/elements/tesla_9cell_cavity/#make-particles-in-distgen","title":"Make particles in distgen\u00b6","text":""},{"location":"examples/elements/tesla_9cell_cavity/#compare","title":"Compare\u00b6","text":""},{"location":"examples/elements/traveling_wave_cavity/","title":"Traveling Wave Cavity","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n\nimport numpy as np\nimport os\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2  import numpy as np import os  import matplotlib.pyplot as plt %matplotlib inline In\u00a0[2]: Copied! <pre>frf = 2856000000.0\nc = 299792458.\npi = np.pi\nk = 2*pi*frf/c\nd = 3.5e-2 # periodic length\nnp.sin(k*d),  25905612.0/29913224.7 #= 0.86571945106805 #roughly equals 25905612.0/29913224.7 as above\n</pre> frf = 2856000000.0 c = 299792458. pi = np.pi k = 2*pi*frf/c d = 3.5e-2 # periodic length np.sin(k*d),  25905612.0/29913224.7 #= 0.86571945106805 #roughly equals 25905612.0/29913224.7 as above Out[2]: <pre>(0.86571945106805, 0.8660253870924187)</pre> In\u00a0[3]: Copied! <pre>frf/c\n</pre> frf/c Out[3]: <pre>9.526590558859223</pre> In\u00a0[4]: Copied! <pre>from impact import Impact, fieldmaps\n</pre> from impact import Impact, fieldmaps In\u00a0[5]: Copied! <pre>ifile = '../templates/traveling_wave_cavity/ImpactT.in'\nos.path.exists(ifile)\n</pre> ifile = '../templates/traveling_wave_cavity/ImpactT.in' os.path.exists(ifile) Out[5]: <pre>True</pre> In\u00a0[6]: Copied! <pre>I = Impact(ifile)\n</pre> I = Impact(ifile) In\u00a0[7]: Copied! <pre>#I.run()\n</pre> #I.run() In\u00a0[8]: Copied! <pre>I.input['fieldmaps']\nfmap4 = I.input['fieldmaps']['rfdata4']['field']['Ez']\nfmap5 = I.input['fieldmaps']['rfdata5']['field']['Ez']\nfmap6 = I.input['fieldmaps']['rfdata6']['field']['Ez']\nfmap7 = I.input['fieldmaps']['rfdata7']['field']['Ez']\n# fmap4 = fieldmaps.process_fieldmap_solrf(rdfa['field']['Ez']ta4['data'])['Ez']\n# fmap5 = fieldmaps.process_fieldmap_solrf(rdfata5['data'])['Ez']\n# fmap6 = fieldmaps.process_fieldmap_solrf(rdfata6['data'])['Ez']\n# fmap7 = fieldmaps.process_fieldmap_solrf(rdfata7['data'])['Ez']\n</pre> I.input['fieldmaps'] fmap4 = I.input['fieldmaps']['rfdata4']['field']['Ez'] fmap5 = I.input['fieldmaps']['rfdata5']['field']['Ez'] fmap6 = I.input['fieldmaps']['rfdata6']['field']['Ez'] fmap7 = I.input['fieldmaps']['rfdata7']['field']['Ez'] # fmap4 = fieldmaps.process_fieldmap_solrf(rdfa['field']['Ez']ta4['data'])['Ez'] # fmap5 = fieldmaps.process_fieldmap_solrf(rdfata5['data'])['Ez'] # fmap6 = fieldmaps.process_fieldmap_solrf(rdfata6['data'])['Ez'] # fmap7 = fieldmaps.process_fieldmap_solrf(rdfata7['data'])['Ez'] In\u00a0[9]: Copied! <pre>fieldmaps.fieldmap_reconstruction_solrf(fmap4, 0)\n</pre> fieldmaps.fieldmap_reconstruction_solrf(fmap4, 0) Out[9]: <pre>0.00029705336845264885</pre> In\u00a0[10]: Copied! <pre>fmap4\n</pre> fmap4 Out[10]: <pre>{'z0': -0.052464,\n 'z1': 0.052464,\n 'L': 0.104928,\n 'fourier_coefficients': array([ 6.70002854e-01, -4.88198923e-01,  1.13480302e-08,  1.84595508e-01,\n        -7.71467877e-09, -2.13348183e-02,  6.02607452e-10, -1.74781481e-02,\n         4.51769540e-09,  1.09000464e-02, -5.96395860e-10, -2.45640689e-03,\n         5.31099067e-08, -8.37267976e-04,  7.96730829e-08,  6.58132017e-04,\n         2.30345527e-08, -2.85586070e-04, -1.99486350e-08, -6.43828139e-05,\n         1.41973546e-08, -8.32668961e-07,  5.47140406e-08, -5.38330720e-05,\n         5.84708220e-08, -2.85487322e-05, -3.37187380e-08, -2.81781237e-05,\n         2.19574641e-08, -2.54874681e-05, -8.91928108e-08, -1.42715353e-05,\n         6.80653280e-08, -2.43108787e-05, -9.59187448e-09, -1.48944953e-05,\n        -3.21672254e-09, -1.21690943e-05, -2.00760664e-08])}</pre> In\u00a0[11]: Copied! <pre>fmap = fmap6\nzlist = np.linspace(fmap['z0'],fmap['z1'], 1000)\nfieldlist = [fieldmaps.fieldmap_reconstruction_solrf(fmap, z) for z in zlist]\nfig, ax = plt.subplots(figsize=(20,5))\nax.plot(zlist, fieldlist)\n</pre> fmap = fmap6 zlist = np.linspace(fmap['z0'],fmap['z1'], 1000) fieldlist = [fieldmaps.fieldmap_reconstruction_solrf(fmap, z) for z in zlist] fig, ax = plt.subplots(figsize=(20,5)) ax.plot(zlist, fieldlist) Out[11]: <pre>[&lt;matplotlib.lines.Line2D at 0x1595f8850&gt;]</pre> In\u00a0[12]: Copied! <pre>fieldlist5 = np.array([fieldmaps.fieldmap_reconstruction_solrf(fmap5, z) for z in zlist])\nfieldlist6 = np.array([fieldmaps.fieldmap_reconstruction_solrf(fmap6, z) for z in zlist])\n</pre> fieldlist5 = np.array([fieldmaps.fieldmap_reconstruction_solrf(fmap5, z) for z in zlist]) fieldlist6 = np.array([fieldmaps.fieldmap_reconstruction_solrf(fmap6, z) for z in zlist]) In\u00a0[13]: Copied! <pre>l = c/frf\nl\n</pre> l = c/frf l Out[13]: <pre>0.10496934803921569</pre> In\u00a0[14]: Copied! <pre>fig, ax = plt.subplots(figsize=(20,5))\n\nwt = 2*np.pi/360*0\nplt.ylim(-1,1)\nplt.xlim(0,0.5)\nax.plot(zlist+l*2/3, fieldlist5*np.cos(wt))\nax.plot(zlist, fieldlist6*np.cos(wt))\n</pre> fig, ax = plt.subplots(figsize=(20,5))  wt = 2*np.pi/360*0 plt.ylim(-1,1) plt.xlim(0,0.5) ax.plot(zlist+l*2/3, fieldlist5*np.cos(wt)) ax.plot(zlist, fieldlist6*np.cos(wt)) Out[14]: <pre>[&lt;matplotlib.lines.Line2D at 0x159b375b0&gt;]</pre> In\u00a0[15]: Copied! <pre>fig, ax = plt.subplots(figsize=(20,5))\n\nwt = 2*np.pi/360*90\nplt.ylim(-1,1)\nax.plot(zlist, fieldlist5*np.cos(wt)+fieldlist6*np.cos(wt+2*np.pi*60/360))\n</pre> fig, ax = plt.subplots(figsize=(20,5))  wt = 2*np.pi/360*90 plt.ylim(-1,1) ax.plot(zlist, fieldlist5*np.cos(wt)+fieldlist6*np.cos(wt+2*np.pi*60/360)) Out[15]: <pre>[&lt;matplotlib.lines.Line2D at 0x159ba2640&gt;]</pre> In\u00a0[16]: Copied! <pre>0.0586460 +  0.3371281 + 1.1518479 + 1.1515630 +  0.3351400 + 0.0609190\n</pre> 0.0586460 +  0.3371281 + 1.1518479 + 1.1515630 +  0.3351400 + 0.0609190 Out[16]: <pre>3.095244</pre> In\u00a0[17]: Copied! <pre>0.0586460 +  0.3371281 + 1.1518479\n</pre> 0.0586460 +  0.3371281 + 1.1518479 Out[17]: <pre>1.5476219999999998</pre> In\u00a0[18]: Copied! <pre>1.1515630 +  0.3351400 + 0.0609190\n</pre> 1.1515630 +  0.3351400 + 0.0609190 Out[18]: <pre>1.5476219999999998</pre> In\u00a0[19]: Copied! <pre>from impact import ControlGroup\n</pre> from impact import ControlGroup In\u00a0[20]: Copied! <pre># Add a ControlGroup that can change the relative phase\n\nI2 = I.copy()\n\nCAV = ControlGroup(ele_names=['solrf_entrance', 'solrf_body_1', 'solrf_body_2', 'solrf_exit'],\n                   var_name = 'dtheta0_deg',\n                   attributes = 'theta0_deg'\n                  )\nCAV.link(I2.ele)\n[ele['theta0_deg'] for ele in CAV.eles]\n</pre> # Add a ControlGroup that can change the relative phase  I2 = I.copy()  CAV = ControlGroup(ele_names=['solrf_entrance', 'solrf_body_1', 'solrf_body_2', 'solrf_exit'],                    var_name = 'dtheta0_deg',                    attributes = 'theta0_deg'                   ) CAV.link(I2.ele) [ele['theta0_deg'] for ele in CAV.eles] Out[20]: <pre>[119.0, 149.0, 209.0, 119.0]</pre> In\u00a0[21]: Copied! <pre>CAV['dtheta0_deg'] = 0\n[ele['theta0_deg'] for ele in CAV.eles]\n</pre> CAV['dtheta0_deg'] = 0 [ele['theta0_deg'] for ele in CAV.eles] Out[21]: <pre>[119.0, 149.0, 209.0, 119.0]</pre> In\u00a0[22]: Copied! <pre>CAV_scale = ControlGroup(ele_names=['solrf_entrance', 'solrf_body_1', 'solrf_body_2', 'solrf_exit'],\n                   var_name = 'rf_field_scale',\n                  factors = [0.86571945106805, 1, 1, 0.86571945106805],  # sin(k*d) with d = 3.5e-2 m \n                  absolute=True\n                  )\nCAV_scale.link(I2.ele)\n</pre> CAV_scale = ControlGroup(ele_names=['solrf_entrance', 'solrf_body_1', 'solrf_body_2', 'solrf_exit'],                    var_name = 'rf_field_scale',                   factors = [0.86571945106805, 1, 1, 0.86571945106805],  # sin(k*d) with d = 3.5e-2 m                    absolute=True                   ) CAV_scale.link(I2.ele) In\u00a0[23]: Copied! <pre>CAV_scale['rf_field_scale'] = 29e6\n[ele['rf_field_scale'] for ele in CAV_scale.eles]\n</pre> CAV_scale['rf_field_scale'] = 29e6 [ele['rf_field_scale'] for ele in CAV_scale.eles] Out[23]: <pre>[25105864.08097345, 29000000.0, 29000000.0, 25105864.08097345]</pre> In\u00a0[24]: Copied! <pre>#  Changes in phases\nI.add_group('L0A', ele_names=['solrf_entrance', 'solrf_body_1', 'solrf_body_2', 'solrf_exit'], var_name='theta0_deg', attributes='theta0_deg')\n\n\n# Overall scaling, respecting the special factors. \nI.add_group('L0A_scale', ele_names=['solrf_entrance', 'solrf_body_1', 'solrf_body_2', 'solrf_exit'],\n                   var_name = 'rf_field_scale',\n                  factors = [0.86571945106805, 1, 1, 0.86571945106805],  # sin(k*d) with d = 3.5e-2 m \n                  absolute=True)\n</pre> #  Changes in phases I.add_group('L0A', ele_names=['solrf_entrance', 'solrf_body_1', 'solrf_body_2', 'solrf_exit'], var_name='theta0_deg', attributes='theta0_deg')   # Overall scaling, respecting the special factors.  I.add_group('L0A_scale', ele_names=['solrf_entrance', 'solrf_body_1', 'solrf_body_2', 'solrf_exit'],                    var_name = 'rf_field_scale',                   factors = [0.86571945106805, 1, 1, 0.86571945106805],  # sin(k*d) with d = 3.5e-2 m                    absolute=True)  Out[24]: <pre>ControlGroup(**{\"ele_names\": [\"solrf_entrance\", \"solrf_body_1\", \"solrf_body_2\", \"solrf_exit\"], \"var_name\": \"rf_field_scale\", \"attributes\": [\"rf_field_scale\", \"rf_field_scale\", \"rf_field_scale\", \"rf_field_scale\"], \"factors\": [0.86571945106805, 1, 1, 0.86571945106805], \"reference_values\": [25500000.0, 29430178.7820912, 29430178.7820912, 25500000.0], \"absolute\": true, \"value\": 0})</pre> In\u00a0[25]: Copied! <pre>from impact.autophase import autophase_and_scale\n\nfrom pmd_beamphysics import single_particle\n\n# Start particles at 1.4 m, just in front of the cavity\nP0 = single_particle(pz=6e6, z=1.4)\n</pre> from impact.autophase import autophase_and_scale  from pmd_beamphysics import single_particle  # Start particles at 1.4 m, just in front of the cavity P0 = single_particle(pz=6e6, z=1.4) In\u00a0[26]: Copied! <pre>autophase_and_scale(I, phase_ele_name='L0A', scale_ele_name='L0A_scale', target=64e6, scale_range=(10e6, 100e6), initial_particles=P0, verbose=True)\n</pre> autophase_and_scale(I, phase_ele_name='L0A', scale_ele_name='L0A_scale', target=64e6, scale_range=(10e6, 100e6), initial_particles=P0, verbose=True) <pre>Copied initial Impact object. \nPhasing L0A by changing theta0_deg\nScaling L0A_scale by changing rf_field_scale\nBounds: 1.42, 4.462852 m\nTracking initial particles to s = 1.42\nInitial particle:  1.42001364304 6021791.459371396\nDisabling solrf_1\nDisabling solrf_2\nDefault brent2 algorithm\nPhase: 180, Scale: 10000000.0, 24.856464772583482 MeV\nPhase: 180, Scale: 10000000.0, 24.856464772583482 MeV\nPhase: 42.49224000000004, Scale: 10000000.0, 8.578906397705104 MeV\nPhase: 180, Scale: 10000000.0, 24.856464772583482 MeV\nPhase: 42.49223094384001, Scale: 10000000.0, 8.57890756562477 MeV\nPhase: 42.49223999999998, Scale: 10000000.0, 8.578906397705104 MeV\nPhase: 222.4922385207506, Scale: 10000000.0, 16.496521287751712 MeV\nPhase: 127.47671094383999, Scale: 10000000.0, 21.05105889847044 MeV\nPhase: 166.52483783762918, Scale: 10000000.0, 25.312859819887922 MeV\nPhase: 167.04288955059457, Scale: 10000000.0, 25.315101189536623 MeV\nPhase: 167.517704554632, Scale: 10000000.0, 25.31578171810014 MeV\nPhase: 167.68522225919662, Scale: 10000000.0, 25.315707803718432 MeV\nPhase: 167.35018685006736, Scale: 10000000.0, 25.315691786975584 MeV\nStep 1 phasing found: 167.517704554632\nPhase: 167.517704554632, Scale: 10000000.0, 25.31578171810014 MeV\nPhase: 167.517704554632, Scale: 100000000.0, 198.2193693243856 MeV\nPhase: 167.517704554632, Scale: 30135959.545841277, 64.08457393061273 MeV\nPhase: 167.517704554632, Scale: 30092033.04856698, 64.0001401656686 MeV\nPhase: 167.517704554632, Scale: 30076987.032042693, 63.97121923669888 MeV\nStep 2  scale found: 30092033.04856698\nPhase: 166.517704554632, Scale: 30092033.04856698, 63.930448123915845 MeV\nPhase: 168.517704554632, Scale: 30092033.04856698, 64.05236338810258 MeV\nPhase: 171.75377255463198, Scale: 30092033.04856698, 64.10102785908452 MeV\nPhase: 170.99311718390493, Scale: 30092033.04856698, 64.10616594870606 MeV\nPhase: 170.99311718390493, Scale: 30092033.04856698, 64.10616594870606 MeV\nPhase: 170.04759372355207, Scale: 30092033.04856698, 64.09833350578708 MeV\nPhase: 170.63195936984778, Scale: 30092033.04856698, 64.10503293842714 MeV\nPhase: 170.99064296460674, Scale: 30092033.04856698, 64.10616600798076 MeV\nPhase: 170.99047197395376, Scale: 30092033.04856698, 64.10616600798076 MeV\nPhase: 170.9903009834718, Scale: 30092033.04856698, 64.10616600798076 MeV\nPhase: 170.8534266706823, Scale: 30092033.04856698, 64.1060003428681 MeV\nPhase: 170.93801964971286, Scale: 30092033.04856698, 64.10614171148696 MeV\nPhase: 170.97033129154124, Scale: 30092033.04856698, 64.10616241521876 MeV\nPhase: 170.98267324012386, Scale: 30092033.04856698, 64.1061654653107 MeV\nPhase: 170.98738744485615, Scale: 30092033.04856698, 64.10616592162367 MeV\nPhase: 170.98918811078093, Scale: 30092033.04856698, 64.1061659926511 MeV\nPhase: 170.98987590394157, Scale: 30092033.04856698, 64.10616600440385 MeV\nPhase: 170.99012999316082, Scale: 30092033.04856698, 64.10616600695879 MeV\nStep 3 phase found:  170.9903009834718\nPhase: 170.9903009834718, Scale: 10000000.0, 25.28060814017475 MeV\nPhase: 170.9903009834718, Scale: 100000000.0, 198.94886639590493 MeV\nPhase: 170.9903009834718, Scale: 30065527.819441315, 64.05500111759288 MeV\nPhase: 170.9903009834718, Scale: 30037065.05392999, 64.00005737067866 MeV\nPhase: 170.9903009834718, Scale: 30037035.33397374, 63.999999999932065 MeV\nStep 4 scale found:  30037035.33397374\nSet Phase: 170.9903009834718, Scale: 30037035.33397374\n</pre> Out[26]: <pre>(170.9903009834718, 30037035.33397374)</pre> In\u00a0[27]: Copied! <pre>PF = I.track(P0, 4.5)\nPF['mean_energy']\n</pre> PF = I.track(P0, 4.5) PF['mean_energy'] Out[27]: <pre>63999921.25861558</pre> In\u00a0[28]: Copied! <pre>from distgen import Generator\n\nYAML=\"\"\"\nn_particle: 20000\nrandom_type: hammersley\nstart:\n  tstart:\n    units: sec\n    value: 0\n  type: time\ntotal_charge:\n  units: pC\n  value: 250.0\nr_dist:\n  sigma_xy:\n    units: mm\n    value: 0.01\n  type: radial_gaussian\nz_dist:\n  avg_z:\n    units: m\n    value: 1.4\n  sigma_z:\n    units: mm\n    value: 0.01\n  type: gaussian\ntransforms:\n  setPz:\n    type: set_avg pz\n    avg_pz: \n      value: 6\n      units: MeV/c\n\"\"\"\nG = Generator(YAML)\nG.run()\nDP = G.particles\nDP.plot('z', 'pz')\n</pre> from distgen import Generator  YAML=\"\"\" n_particle: 20000 random_type: hammersley start:   tstart:     units: sec     value: 0   type: time total_charge:   units: pC   value: 250.0 r_dist:   sigma_xy:     units: mm     value: 0.01   type: radial_gaussian z_dist:   avg_z:     units: m     value: 1.4   sigma_z:     units: mm     value: 0.01   type: gaussian     transforms:   setPz:     type: set_avg pz     avg_pz:        value: 6       units: MeV/c    \"\"\" G = Generator(YAML) G.run() DP = G.particles DP.plot('z', 'pz')  In\u00a0[29]: Copied! <pre>DP['min_z']\n</pre> DP['min_z'] Out[29]: <pre>1.3999585342792105</pre> In\u00a0[30]: Copied! <pre>I.header['Bcurr'] = 0  # SC off\nI.header['Dt'] = 1e-11\nPF = I.track(DP, 5)\n</pre> I.header['Bcurr'] = 0  # SC off I.header['Dt'] = 1e-11 PF = I.track(DP, 5) In\u00a0[31]: Copied! <pre>PI = I.particles['initial_particles']\nPI.plot('z', 'x')\n</pre> PI = I.particles['initial_particles'] PI.plot('z', 'x') In\u00a0[32]: Copied! <pre>PF.plot('delta_z', 'delta_pz')\n</pre> PF.plot('delta_z', 'delta_pz') In\u00a0[33]: Copied! <pre># Compare these. \nkey1 = 'mean_z'\nkey2 = 'mean_kinetic_energy'\nunits1 = str(I.units(key1))\nunits2 = str(I.units(key2))\nplt.xlabel(key1+f' ({units1})')\nplt.ylabel(key2+f' ({units2})')\nplt.plot(I.stat(key1), I.stat(key2))\nplt.scatter(\n    [I.particles[name][key1] for name in I.particles], \n    [I.particles[name][key2] for name in I.particles], color='red')\n</pre> # Compare these.  key1 = 'mean_z' key2 = 'mean_kinetic_energy' units1 = str(I.units(key1)) units2 = str(I.units(key2)) plt.xlabel(key1+f' ({units1})') plt.ylabel(key2+f' ({units2})') plt.plot(I.stat(key1), I.stat(key2)) plt.scatter(     [I.particles[name][key1] for name in I.particles],      [I.particles[name][key2] for name in I.particles], color='red') Out[33]: <pre>&lt;matplotlib.collections.PathCollection at 0x15b35a550&gt;</pre>"},{"location":"examples/elements/traveling_wave_cavity/#traveling-wave-cavity","title":"Traveling Wave Cavity\u00b6","text":"<p>A traveling wave needs to be described by four fieldmaps: entrance two body exit</p> <p>http://accelconf.web.cern.ch/accelconf/p79/PDF/PAC1979_3701.PDF</p> <pre><code>0.052464 0 0 105 1.42 25500000.0 2856000000.0 119.0 4 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:entrance\n2.937928 0 0 105 1.472464 29430178.7820912 2856000000.0 149.0 5 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:body_1\n2.937928 0 0 105 1.472464 29430178.7820912 2856000000.0 209.0 6 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:body_2\n0.05246 0 0 105 4.410392 25500000.0 2856000000.0 119.0 7 0.15 0.0 0.0 0.0 0.0 0.0 0.0 /!name:exit\n</code></pre> <p>The following 4 lines define a 3-cell s-band traveling wave structure using the supperposition of two standing wave strutures. G. A. Loew et al., SLAC-PUB-2295, 1979.</p> <ul> <li>the phase of line 2 is the phase of line 1 + 30 degrees;</li> <li>the phase of line 3 is the phase of line 1 + 90 degrees.</li> <li>the phase of line 4 is the same as the line 1;</li> <li>the field scale of line 2 is the scale of the line 1/sin(beta d)</li> <li>the field scale of line 3 is the scale of the line 1/sin(beta d)</li> <li>the scale of line 4 is the same as the line 1;</li> </ul>"},{"location":"examples/elements/traveling_wave_cavity/#fieldmaps","title":"Fieldmaps\u00b6","text":""},{"location":"examples/elements/traveling_wave_cavity/#controlgroups","title":"ControlGroups\u00b6","text":""},{"location":"examples/elements/traveling_wave_cavity/#autophase-and-scale","title":"Autophase and scale\u00b6","text":""},{"location":"examples/elements/traveling_wave_cavity/#track-distgen-particles","title":"Track distgen particles\u00b6","text":""},{"location":"examples/elements/wakefield/","title":"Wakefield example","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n\nimport numpy as np\nimport os\n\nimport matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams['figure.figsize'] = (12, 8)\n%matplotlib inline\n%config InlineBackend.figure_format='retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2  import numpy as np import os  import matplotlib.pyplot as plt import matplotlib matplotlib.rcParams['figure.figsize'] = (12, 8) %matplotlib inline %config InlineBackend.figure_format='retina' In\u00a0[2]: Copied! <pre># locate the drift template\nfrom impact import Impact\n\nifile = '../templates/wakefield/ImpactT.in'\nos.path.exists(ifile)\n</pre> # locate the drift template from impact import Impact  ifile = '../templates/wakefield/ImpactT.in' os.path.exists(ifile) Out[2]: <pre>True</pre> In\u00a0[3]: Copied! <pre># gamma for 1 GeV\n1e9/0.511e6\n</pre> # gamma for 1 GeV 1e9/0.511e6 Out[3]: <pre>1956.9471624266146</pre> In\u00a0[4]: Copied! <pre>I = Impact(ifile)\nI.header['Np'] = 10000\nI.header['Nx'] = 32\nI.header['Ny'] = 32\nI.header['Nz'] = 32\nI.header['Dt'] = 10e-12\n</pre> I = Impact(ifile) I.header['Np'] = 10000 I.header['Nx'] = 32 I.header['Ny'] = 32 I.header['Nz'] = 32 I.header['Dt'] = 10e-12 In\u00a0[5]: Copied! <pre>I.lattice\n</pre> I.lattice Out[5]: <pre>[{'description': 'name:sc_off',\n  'original': '0 0 0 -8 0 -1 0 /!name:sc_off',\n  'type': 'spacecharge',\n  's': 0.0,\n  'is_on': False,\n  'name': 'sc_off'},\n {'type': 'comment',\n  'description': '!0 0 0 -5 0 0 -1000.0 /!name:2d_to_3d_spacecharge',\n  'name': '2d_to_3d_spacecharge'},\n {'description': 'name:wakefield_1',\n  'original': '0 -1 0 -6 1 1 0.0 1.0 0.0116 0.0292 0.035 /!name:wakefield_1',\n  'type': 'wakefield',\n  's_begin': 0.0,\n  's': 1.0,\n  'method': 'analytical',\n  'iris_radius': 0.0116,\n  'gap': 0.0292,\n  'period': 0.035,\n  'name': 'wakefield_1'},\n {'description': 'name:drift_1',\n  'original': '1.0 0 0 0 1.0 0.15 /!name:drift_1',\n  'L': 1.0,\n  'type': 'drift',\n  'zedge': 1.0,\n  'radius': 0.15,\n  's': 2.0,\n  'name': 'drift_1'},\n {'description': 'name:stop_1',\n  'original': '0 0 0 -99 0 0.0 1 /!name:stop_1',\n  'type': 'stop',\n  's': 1.0,\n  'name': 'stop_1'}]</pre> In\u00a0[6]: Copied! <pre>I.run()\n</pre> I.run() In\u00a0[7]: Copied! <pre>I.output['stats'].keys()\n</pre> I.output['stats'].keys() Out[7]: <pre>dict_keys(['t', 'mean_z', 'moment4_x', 'moment4_y', 'moment4_z', 'mean_y', 'sigma_y', 'norm_emit_y', 'mean_x', 'sigma_x', 'norm_emit_x', 'sigma_z', 'norm_emit_z', 'loadbalance_min_n_particle', 'loadbalance_max_n_particle', 'n_particle', 'moment3_x', 'moment3_y', 'moment3_z', 'mean_gamma', 'mean_beta', 'max_r', 'sigma_gamma', 'max_amplitude_x', 'max_amplitude_y', 'max_amplitude_z', 'moment4_px', 'moment4_py', 'moment4_pz', 'mean_py', 'sigma_py', 'cov_y__py', 'mean_px', 'sigma_px', 'cov_x__px', 'mean_pz', 'sigma_pz', 'cov_z__pz', 'moment3_px', 'moment3_py', 'moment3_pz', 'mean_kinetic_energy', 'max_amplitude_px', 'max_amplitude_py', 'max_amplitude_pz'])</pre> In\u00a0[8]: Copied! <pre>PI = I.particles['initial_particles']\nPF = I.particles['final_particles']\nPI, PF\n</pre> PI = I.particles['initial_particles'] PF = I.particles['final_particles'] PI, PF Out[8]: <pre>(&lt;ParticleGroup with 10000 particles at 0x12ffbd400&gt;,\n &lt;ParticleGroup with 10000 particles at 0x12ffbd3d0&gt;)</pre> In\u00a0[9]: Copied! <pre>PI.plot('delta_z', 'delta_pz')\nPF.plot('delta_z', 'delta_pz')\n</pre> PI.plot('delta_z', 'delta_pz') PF.plot('delta_z', 'delta_pz') In\u00a0[10]: Copied! <pre>PF.plot('delta_z', 'delta_pz')\n</pre> PF.plot('delta_z', 'delta_pz') In\u00a0[11]: Copied! <pre>#np.savetxt('/Users/chrisonian/Scratch/impactwake.dat', np.array([PF['z'], PF['pz']]).T)\n</pre> #np.savetxt('/Users/chrisonian/Scratch/impactwake.dat', np.array([PF['z'], PF['pz']]).T) In\u00a0[12]: Copied! <pre>from distgen import Generator\n\nYAML=\"\"\"\nn_particle: 20000\nrandom_type: hammersley\nstart:\n  tstart:\n    units: sec\n    value: 0\n  type: time\ntotal_charge:\n  units: nC\n  value: 1\nr_dist:\n  sigma_xy:\n    units: mm\n    value: .001\n  type: radial_gaussian\nz_dist:\n  avg_z:\n    units: mm\n    value: 0\n  sigma_z:\n    units: mm\n    value: 0.1\n  type: gaussian\ntransforms:\n  setPz:\n    type: set_avg pz\n    avg_pz: \n      value: 1\n      units: GeV/c\n\"\"\"\nG = Generator(YAML)\nG.run()\nP = G.particles\n</pre> from distgen import Generator  YAML=\"\"\" n_particle: 20000 random_type: hammersley start:   tstart:     units: sec     value: 0   type: time total_charge:   units: nC   value: 1 r_dist:   sigma_xy:     units: mm     value: .001   type: radial_gaussian z_dist:   avg_z:     units: mm     value: 0   sigma_z:     units: mm     value: 0.1   type: gaussian     transforms:   setPz:     type: set_avg pz     avg_pz:        value: 1       units: GeV/c    \"\"\" G = Generator(YAML) G.run() P = G.particles  In\u00a0[13]: Copied! <pre>I = Impact(ifile, initial_particles=P, verbose=False)\nI.run()\nPF2 = I.particles['final_particles']\n</pre> I = Impact(ifile, initial_particles=P, verbose=False) I.run() PF2 = I.particles['final_particles'] In\u00a0[14]: Copied! <pre>PF2.plot('x', 'px')\nPF2.plot('delta_z', 'delta_pz')\n</pre> PF2.plot('x', 'px') PF2.plot('delta_z', 'delta_pz') In\u00a0[15]: Copied! <pre>for k in ['x', 'z', 'pz']:\n    plt.hist(PF[k], density=True, bins=100, label='Impact-T generator', alpha=0.5)\n    plt.hist(PF2[k], density=True, bins=100, label='Distgen generator', alpha=0.5)\n    plt.xlabel(k)\n    plt.legend()\n    plt.show()\n</pre> for k in ['x', 'z', 'pz']:     plt.hist(PF[k], density=True, bins=100, label='Impact-T generator', alpha=0.5)     plt.hist(PF2[k], density=True, bins=100, label='Distgen generator', alpha=0.5)     plt.xlabel(k)     plt.legend()     plt.show() In\u00a0[16]: Copied! <pre># Define alpha function for the s00 calc. \n\ndef alpha(g):\n\"\"\"\n    SLAC-PUB-9663 equation (5)\n    \"\"\"\n    a1 = 0.4648\n    return 1 - a1*np.sqrt(g) - (1-2*a1)*g\n\ndef bane_wake(z, a=0.0116, g=0.0292, L=0.035):\n    Z0 = 120.0 * np.pi\n    \n    s00 = g/8 * (a/(alpha(g/L)*L))**2\n    \n  #   'iris_radius': 0.0116,\n  #   'gap': 0.0292,\n  #   'period': 0.035,\n\n    Z0c_over_pi = 120 * 299792458. # Ohm m/s\n\n    WL = Z0c_over_pi/a**2 * np.exp(-np.sqrt(z/s00))\n\n    return WL\n\ndef bane_wake2(z, a=0.0116, g=0.0292, L=0.035):\n\"\"\"\n    From SLAC-PUB-11829\n    \"\"\"\n    Z0 = 120.0 * np.pi\n    \n    s1 = 0.41 * a**1.8 * g**1.6 / L**2.4\n\n    Z0c_over_pi = 120 * 299792458. # Ohm m/s\n\n    WL = Z0c_over_pi/a**2 * np.exp(-np.sqrt(z/s1))\n\n    return WL\n\nplt.xlabel('z (m)')\nplt.ylabel('Wake (V/C)')\nplt.yscale('log')\n\ndzz = .00001\nzz = np.arange(0, 0.01, dzz)\n\nplt.yscale('log')\nplt.plot(zz, bane_wake(zz), label='SLAC-PUB-9663', color='red')\nplt.plot(zz, bane_wake2(zz), label='SLAC-PUB-11829', color='green')\nplt.legend()\n</pre> # Define alpha function for the s00 calc.   def alpha(g):     \"\"\"     SLAC-PUB-9663 equation (5)          \"\"\"     a1 = 0.4648     return 1 - a1*np.sqrt(g) - (1-2*a1)*g  def bane_wake(z, a=0.0116, g=0.0292, L=0.035):     Z0 = 120.0 * np.pi          s00 = g/8 * (a/(alpha(g/L)*L))**2        #   'iris_radius': 0.0116,   #   'gap': 0.0292,   #   'period': 0.035,      Z0c_over_pi = 120 * 299792458. # Ohm m/s      WL = Z0c_over_pi/a**2 * np.exp(-np.sqrt(z/s00))      return WL  def bane_wake2(z, a=0.0116, g=0.0292, L=0.035):          \"\"\"     From SLAC-PUB-11829     \"\"\"     Z0 = 120.0 * np.pi          s1 = 0.41 * a**1.8 * g**1.6 / L**2.4      Z0c_over_pi = 120 * 299792458. # Ohm m/s      WL = Z0c_over_pi/a**2 * np.exp(-np.sqrt(z/s1))      return WL  plt.xlabel('z (m)') plt.ylabel('Wake (V/C)') plt.yscale('log')  dzz = .00001 zz = np.arange(0, 0.01, dzz)  plt.yscale('log') plt.plot(zz, bane_wake(zz), label='SLAC-PUB-9663', color='red') plt.plot(zz, bane_wake2(zz), label='SLAC-PUB-11829', color='green') plt.legend() Out[16]: <pre>&lt;matplotlib.legend.Legend at 0x166f75fa0&gt;</pre> In\u00a0[17]: Copied! <pre># Compare with particles\nsigma = .0001\nQtot = -1e-9 # C \ndef density(z, sigma=0.0001):\n    \n    return 1/(np.sqrt(2*np.pi)*sigma) * np.exp(-0.5*(z/sigma)**2)\n\ndz = sigma/10\nzlist = np.arange(-6*sigma, 6*sigma, dz)\n\n# Check normalization\nnp.sum(density(zlist)) * dz\n</pre> # Compare with particles sigma = .0001 Qtot = -1e-9 # C  def density(z, sigma=0.0001):          return 1/(np.sqrt(2*np.pi)*sigma) * np.exp(-0.5*(z/sigma)**2)  dz = sigma/10 zlist = np.arange(-6*sigma, 6*sigma, dz)  # Check normalization np.sum(density(zlist)) * dz Out[17]: <pre>0.9999999979663955</pre> In\u00a0[18]: Copied! <pre>def total_bane_wake(z):\n    W = bane_wake(zz)\n    return np.sum(W * density(zz + z)*dzz)\n</pre> def total_bane_wake(z):     W = bane_wake(zz)     return np.sum(W * density(zz + z)*dzz) In\u00a0[19]: Copied! <pre>plt.xlabel('z')\nplt.ylabel('$\\Delta p_z$ (eV/c)')\nplt.scatter(PF['delta_z'], PF['pz']- PF['max_pz'], marker='x', label='Impact-T tracking')\nplt.plot(zlist, Qtot*np.array([total_bane_wake(z) for z in zlist]), color='blue', label='SLAC-PUB-9663 equation (8)')\nplt.title('Integrated total wake comparison')\nplt.legend()\n</pre> plt.xlabel('z') plt.ylabel('$\\Delta p_z$ (eV/c)') plt.scatter(PF['delta_z'], PF['pz']- PF['max_pz'], marker='x', label='Impact-T tracking') plt.plot(zlist, Qtot*np.array([total_bane_wake(z) for z in zlist]), color='blue', label='SLAC-PUB-9663 equation (8)') plt.title('Integrated total wake comparison') plt.legend() Out[19]: <pre>&lt;matplotlib.legend.Legend at 0x166eefa30&gt;</pre> In\u00a0[20]: Copied! <pre>wfile = 'Sz_p5um_10mm_per35mm_cell.sdds'\nreffile = os.path.join('../templates/wakefield', wfile)\nreffile\n</pre> wfile = 'Sz_p5um_10mm_per35mm_cell.sdds' reffile = os.path.join('../templates/wakefield', wfile) reffile  Out[20]: <pre>'../templates/wakefield/Sz_p5um_10mm_per35mm_cell.sdds'</pre> In\u00a0[21]: Copied! <pre>!head -n 8 ../templates/wakefield/Sz_p5um_10mm_per35mm_cell.sdds\n</pre> !head -n 8 ../templates/wakefield/Sz_p5um_10mm_per35mm_cell.sdds <pre>SDDS1\n&amp;column name=z, units=m, type=double,  &amp;end\n&amp;column name=W, units=V/C, type=double,  &amp;end\n&amp;column name=t, units=s, type=double,  &amp;end\n&amp;data mode=ascii, &amp;end\n! page number 1\n               20001\n0.00000000e+000  9.22430234e+012  0.00000000e+000 \n</pre> In\u00a0[22]: Copied! <pre># Load the file\nedat = np.loadtxt(reffile, skiprows=7).T\nzw = edat[0]\ndzw = np.mean(np.diff(zw))\nW_from_file = edat[1]/35e-3 # Convert to per m\n\nplt.ylabel('W (V/C)')\nplt.xlabel('z (m)')\nplt.yscale('log')\nplt.plot(zw, W_from_file, label=wfile)\nplt.plot(zw, np.array([bane_wake(z) for z in zw]), label='SLAC-PUB-9663 equation (8)')\nplt.scatter(zw, np.array([bane_wake(z) for z in zw]), label='SLAC-PUB-11829 equation (12)', color='red')\nplt.legend()\n</pre> # Load the file edat = np.loadtxt(reffile, skiprows=7).T zw = edat[0] dzw = np.mean(np.diff(zw)) W_from_file = edat[1]/35e-3 # Convert to per m  plt.ylabel('W (V/C)') plt.xlabel('z (m)') plt.yscale('log') plt.plot(zw, W_from_file, label=wfile) plt.plot(zw, np.array([bane_wake(z) for z in zw]), label='SLAC-PUB-9663 equation (8)') plt.scatter(zw, np.array([bane_wake(z) for z in zw]), label='SLAC-PUB-11829 equation (12)', color='red') plt.legend() Out[22]: <pre>&lt;matplotlib.legend.Legend at 0x166f6f7c0&gt;</pre> In\u00a0[23]: Copied! <pre>def total_wake_from_file(z):\n    return np.sum(W_from_file* density(zw + z)*dzw)\ntotal_wake_from_file(0) * 1e-9\n</pre> def total_wake_from_file(z):     return np.sum(W_from_file* density(zw + z)*dzw) total_wake_from_file(0) * 1e-9      Out[23]: <pre>106087.97587646772</pre> In\u00a0[24]: Copied! <pre>plt.xlabel('z (m)')\nplt.ylabel('$\\Delta p_z$ (eV/c)')\nplt.scatter(PF['delta_z'], PF['pz']- PF['max_pz'], marker='x', label='Impact-T tracking')\nplt.plot(zlist, Qtot*np.array([total_wake_from_file(z) for z in zlist]), color='red', label=wfile)\nplt.plot(zlist, Qtot*np.array([total_bane_wake(z) for z in zlist]), color='blue', label='SLAC-PUB-9663 equation (8)')\nplt.legend()\n</pre> plt.xlabel('z (m)') plt.ylabel('$\\Delta p_z$ (eV/c)') plt.scatter(PF['delta_z'], PF['pz']- PF['max_pz'], marker='x', label='Impact-T tracking') plt.plot(zlist, Qtot*np.array([total_wake_from_file(z) for z in zlist]), color='red', label=wfile) plt.plot(zlist, Qtot*np.array([total_bane_wake(z) for z in zlist]), color='blue', label='SLAC-PUB-9663 equation (8)') plt.legend() Out[24]: <pre>&lt;matplotlib.legend.Legend at 0x166ec3d00&gt;</pre>"},{"location":"examples/elements/wakefield/#wakefield-example","title":"Wakefield example\u00b6","text":"<p>Simple 1 m drift with a wakefield.</p> <p>This verifies that the analytic formula uses is SLAC-PUB-9663 Eq. 8</p>"},{"location":"examples/elements/wakefield/#use-impacts-built-in-gaussian-particle-generator","title":"Use Impact's built-in Gaussian particle generator\u00b6","text":""},{"location":"examples/elements/wakefield/#make-particles-in-distgen","title":"Make particles in distgen\u00b6","text":""},{"location":"examples/elements/wakefield/#compare","title":"Compare\u00b6","text":""},{"location":"examples/elements/wakefield/#checking-the-wakefield-with-slac-pub-9663","title":"Checking the wakefield with SLAC-PUB-9663\u00b6","text":"<p>Impact-T seems to use Eq. * from SLAC-PUB-9663, Karl Bane (2003).</p> <p>https://www.slac.stanford.edu/pubs/slacpubs/9500/slac-pub-9663.pdf</p>"},{"location":"examples/elements/wakefield/#comparison-with-wakefield-file","title":"Comparison with Wakefield file\u00b6","text":"<p>Many codes will use a wakefield file, with a list of z and single particle wake in V/C</p>"},{"location":"examples/templates/apex_gun/apex_gun/","title":"APEX Gun","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams['figure.figsize'] = (6,6)\n%config InlineBackend.figure_format = 'retina'\n</pre> import matplotlib.pyplot as plt import matplotlib matplotlib.rcParams['figure.figsize'] = (6,6) %config InlineBackend.figure_format = 'retina' In\u00a0[13]: Copied! <pre>from distgen import Generator\n\nG = Generator('distgen_laser.yaml')\nG['n_particle'] = 100000\nG\n</pre> from distgen import Generator  G = Generator('distgen_laser.yaml') G['n_particle'] = 100000 G Out[13]: <pre>&lt;disgten.Generator with input: \nn_particle: 100000\nrandom_type: hammersley\nstart:\n  MTE:\n    units: meV\n    value: 250\n  type: cathode\nt_dist:\n  avg_t:\n    units: ps\n    value: 0\n  n_sigma_cutoff: 3\n  sigma_t:\n    units: ps\n    value: 8.5\n  type: gaussian\ntotal_charge:\n  units: pC\n  value: 10\nxy_dist:\n  file: /Users/chrisonian/Code/GitHub/lume-astra/templates/apex_gun/2019_11_04_135614reg_out.txt\n  type: file2d\n\n&gt;</pre> In\u00a0[14]: Copied! <pre>G.run()\nG.particles\n</pre> G.run() G.particles Out[14]: <pre>&lt;ParticleGroup with 100000 particles at 0x15ccab730&gt;</pre> In\u00a0[15]: Copied! <pre>G.particles.plot('x', 'y', bins=50)\n</pre> G.particles.plot('x', 'y', bins=50) In\u00a0[16]: Copied! <pre>from impact import Impact\n</pre> from impact import Impact In\u00a0[17]: Copied! <pre>I = Impact('ImpactT.in', initial_particles=G.particles)\n</pre> I = Impact('ImpactT.in', initial_particles=G.particles) In\u00a0[18]: Copied! <pre># Turn space charge off\nI.total_charge = 0\nI.stop = 0.5\n</pre> # Turn space charge off I.total_charge = 0 I.stop = 0.5 In\u00a0[19]: Copied! <pre>I.run()\n</pre> I.run() In\u00a0[20]: Copied! <pre>I.output.keys()\n</pre> I.output.keys() Out[20]: <pre>dict_keys(['run_info', 'stats', 'slice_info', 'particles'])</pre> In\u00a0[32]: Copied! <pre>fig = I.plot(y=['norm_emit_x', 'norm_emit_y'], y2=['sigma_x', 'sigma_y'], xlim=(1e-3,.6), ylim=(0, 6e-6), ylim2=(0, 800e-6),figsize=(6,6), return_figure=True)\n#fig.axes[0].set_title('LUME-Impact')\nplt.savefig('apex-gun-lume-impact.png', dpi=150, bbox_inches='tight')\n</pre> fig = I.plot(y=['norm_emit_x', 'norm_emit_y'], y2=['sigma_x', 'sigma_y'], xlim=(1e-3,.6), ylim=(0, 6e-6), ylim2=(0, 800e-6),figsize=(6,6), return_figure=True) #fig.axes[0].set_title('LUME-Impact') plt.savefig('apex-gun-lume-impact.png', dpi=150, bbox_inches='tight') In\u00a0[12]: Copied! <pre>I.particles['final_particles'].plot('x', 'y', bins=50)\n</pre> I.particles['final_particles'].plot('x', 'y', bins=50) In\u00a0[16]: Copied! <pre>I.archive()\n</pre> I.archive() Out[16]: <pre>'impact_7915440a6365ec6b361c7970a812e9d0.h5'</pre> In\u00a0[14]: Copied! <pre>!rm *h5\n</pre> !rm *h5 In\u00a0[15]: Copied! <pre>!pwd\n</pre> !pwd  <pre>/Users/chrisonian/Code/GitHub/lume-impact/templates/apex_gun\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/templates/apex_gun/apex_gun/#apex-gun","title":"APEX Gun\u00b6","text":""},{"location":"examples/templates/tesla_9cell_cavity/plot_fieldmaps/","title":"Plot fieldmaps","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport os\n\nimport matplotlib.pyplot as plt\nimport matplotlib\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nmatplotlib.rcParams['figure.figsize'] = (8,4)\n</pre> import numpy as np import os  import matplotlib.pyplot as plt import matplotlib %matplotlib inline %config InlineBackend.figure_format = 'retina' matplotlib.rcParams['figure.figsize'] = (8,4) In\u00a0[2]: Copied! <pre>FREQ = 1.3e9\nOMEGA = 2*np.pi*FREQ\nc_light = 299792458.\n\nMU0 = 4e-7*np.pi\n\n\nLINES = open('1T9.T7').readlines()\n\nLINES[0:3], LINES[3:10]\n</pre> FREQ = 1.3e9 OMEGA = 2*np.pi*FREQ c_light = 299792458.  MU0 = 4e-7*np.pi   LINES = open('1T9.T7').readlines()  LINES[0:3], LINES[3:10] Out[2]: <pre>(['0 134.7 1347\\n', '1300.0\\n', '0 3.9 39\\n'],\n ['-2.108881786851425e-10 0.0 0 -0.0\\n',\n  '-2.1106466961613225e-10 0.0 0 -0.0\\n',\n  '-2.1195427930882333e-10 0.0 0 -0.0\\n',\n  '-2.135582002695064e-10 0.0 0 -0.0\\n',\n  '-2.1587583624503616e-10 0.0 0 -0.0\\n',\n  '-2.1890659098226744e-10 0.0 0 -0.0\\n',\n  '-2.226516569874906e-10 0.0 0 -0.0\\n'])</pre> In\u00a0[3]: Copied! <pre>nz = int(LINES[0].split()[-1]) +1\nnr = int(LINES[2].split()[-1]) +1\nnz, nr\n</pre> nz = int(LINES[0].split()[-1]) +1 nr = int(LINES[2].split()[-1]) +1 nz, nr Out[3]: <pre>(1348, 40)</pre> In\u00a0[4]: Copied! <pre>(len(LINES) -3)/2\n</pre> (len(LINES) -3)/2 Out[4]: <pre>26960.0</pre> In\u00a0[12]: Copied! <pre>nz = 1347\nnr = 39\n(nr+1)*(nz+1)\n</pre> nz = 1347 nr = 39 (nr+1)*(nz+1) Out[12]: <pre>53920</pre> In\u00a0[14]: Copied! <pre>53923 - 3\n</pre> 53923 - 3 Out[14]: <pre>53920</pre> In\u00a0[10]: Copied! <pre>2600*70\n</pre> 2600*70 Out[10]: <pre>182000</pre> In\u00a0[5]: Copied! <pre>with open('temp', 'w') as f:\n    for l in LINES[4::2]:\n        f.write(l)\n        \ndat = np.loadtxt('temp', ndmin=1)        \nH  = dat.reshape(nr, nz)\n</pre> with open('temp', 'w') as f:     for l in LINES[4::2]:         f.write(l)          dat = np.loadtxt('temp', ndmin=1)         H  = dat.reshape(nr, nz)         <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n/var/folders/wj/lfgr01993dx79p9cm_skykbw0000gn/T/ipykernel_68111/2874549498.py in &lt;module&gt;\n      4 \n      5 dat = np.loadtxt('temp', ndmin=1)\n----&gt; 6 H  = dat.reshape(nr, nz)\n\nValueError: cannot reshape array of size 107840 into shape (40,1348)</pre> In\u00a0[6]: Copied! <pre>with open('temp', 'w') as f:\n    for l in LINES[3::2]:\n        f.write(l)\n        \ndat = np.loadtxt('temp', ndmin=1).T       \ndat.shape\nEz  = dat[0].reshape(nr, nz)        \nEr  = dat[1].reshape(nr, nz)\n</pre> with open('temp', 'w') as f:     for l in LINES[3::2]:         f.write(l)          dat = np.loadtxt('temp', ndmin=1).T        dat.shape Ez  = dat[0].reshape(nr, nz)         Er  = dat[1].reshape(nr, nz)      <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n/var/folders/wj/lfgr01993dx79p9cm_skykbw0000gn/T/ipykernel_68111/3530725789.py in &lt;module&gt;\n      5 dat = np.loadtxt('temp', ndmin=1).T\n      6 dat.shape\n----&gt; 7 Ez  = dat[0].reshape(nr, nz)\n      8 Er  = dat[1].reshape(nr, nz)\n\nValueError: cannot reshape array of size 26960 into shape (40,1348)</pre> In\u00a0[7]: Copied! <pre>plt.imshow(H)\n</pre> plt.imshow(H) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n/var/folders/wj/lfgr01993dx79p9cm_skykbw0000gn/T/ipykernel_68111/4159171655.py in &lt;module&gt;\n----&gt; 1 plt.imshow(H)\n\nNameError: name 'H' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre>#plt.plot(Ez[0, :])\nplt.plot(Ez[0, :])\nplt.plot(H[10, :]/800)\n</pre> #plt.plot(Ez[0, :]) plt.plot(Ez[0, :]) plt.plot(H[10, :]/800) In\u00a0[\u00a0]: Copied! <pre>plt.plot(H[1, :]*MU0)\n</pre> plt.plot(H[1, :]*MU0) In\u00a0[\u00a0]: Copied! <pre>plt.plot(Ez[0, :]*1e6)\n</pre> plt.plot(Ez[0, :]*1e6) In\u00a0[\u00a0]: Copied! <pre>plt.plot(Er[1, :]*1e6)\n</pre> plt.plot(Er[1, :]*1e6) In\u00a0[\u00a0]: Copied! <pre>Ez[0, :]\n</pre> Ez[0, :]"}]}